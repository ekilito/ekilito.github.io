<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>sxms | kilito</title><meta name="keywords" content="面试,前端"><meta name="author" content="kilito"><meta name="copyright" content="kilito"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="sxms"><meta name="application-name" content="sxms"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="sxms"><meta property="og:url" content="https://ekilito.github.io/posts/3936.html"><meta property="og:site_name" content="kilito"><meta property="og:description" content="每天一道面试题。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp"><meta property="article:author" content="kilito"><meta property="article:tag" content="个人博客,kilito,小清"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp"><meta name="description" content="每天一道面试题。"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://ekilito.github.io/posts/3936"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走嘛！","backTitle":"♪(^∇^*)欢迎回来！"},
  LA51: {"enable":true,"ck":"3FXVpXQlU2qrgdld","LingQueMonitorID":"3FXVpXQlU2qrgdld"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.wudl.cn/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"30796eace3084cff910c7e43aa524164","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://puquan.wudl.cn/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: kilito","link":"链接: ","source":"来源: kilito","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'kilito',
  title: 'sxms',
  postAI: '',
  pageFillDescription: '前端基础, 1.h5的新特性？css3的新特性？, 2.盒子水平垂直居中, 3.css选择器优先级, 4.rem的理解, 5.position, 6.浮动 float, 7. 伪类和伪元素, 8.css预处理器, 9.vw适配, 10.如何解决 margin塌陷？, 11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？, 12. 如何理解 z-index？, 13. 谈谈你对 flex 的理解？, JavaScript, 1. let var const的区别？, 2. js数据类型区别, 3.slice 是干嘛的、splice是否会改变原数组？, 4.数组去重, 5. Javascript 创建对象的几种方式？, 6. 如何区分数组和对象？, 7. 作用域和作用域链, 8. map 和 forEach 的区别？, 9. js遍历对象的方法？, 10. new操作符具体干了什么呢?, 11.类数组转换为数组, 12.简单说说 js 中有哪几种内存泄露的情况, 13. promise和 async await 区别?, 14. defer和async区别?, 15. 同步和异步, 16. null 和 undefined 的区别, 17. call appy bind的作用和区别？, 18. this指向（普通函数、箭头函数）, 19. 继承, 20. promise, 21、JavaScript 内置的常用对象有哪些？, 22.谈谈事件委托的理解？, 23.什么是闭包？, 24.for in 和 for of 的区别, 25、split（）和 join（）的区别？, 26.深拷贝, 27.原型链, 28.防抖和节流, 29.ES6, 30.介绍下 Set、Map 的区别, 31.async await, 浏览器, 1.cookie sessionStorage localStorage区别, 2. 浏览器输入URL发生了什么, 3. 浏览器是如何渲染页面的？, 4. 重绘、重排, 5. 事件循环（Event loop）, 6. 跨域, 7.常见code码, 8. http 和 https 的区别, 9. 前端优化策略, 10.介绍一下 websocket, 11.webpack, 12.Get 和 Post 的区别以及使用场景, 13. HTTP有哪些⽅法？, 14. 各个HTTP方法的具体作用是什么？, Vue, 1.谈谈你对 Vue 生命周期的理解？, 2. keep-alive, 3. 数据双向绑定原理, 4. 路由守卫, 5. Vuex, 6. 组件通讯（⽗、⼦）, 7. 怎么定义vue-router的动态路由？, 8. 2.0和3.0的区别, 9. computed 与 watch 的区别, 10.Route和router的区别, 11.vue-router 路由模式有⼏种？, 12. Object.defineProperty 和 Proxy 的区别, 13. vue3 新特性有哪些？, 14. v-show 与 v-if 区别, 15. vue中v-if和v-for优先级在vue2和vue3中的区别, 16. script setup 是干啥的？, 17. reactive与ref的区别？, 18. v-model的使用？, 19. vuex中的辅助函数怎么使用？, 20. slot是什么？有什么作用？原理是什么？, 21. $nextTick的使用, 22. v-for中的key, 23.data必须是一个函数, 24.编程式导航如何跳转传参？, 25. 什么是 M V  VM, 26. MVVM的优缺点有哪些？, 项目, 1.分析登录流程, 2.登录模块业务实现思路, 3.主页模块的实现思路, 4.登录流程, 5.智慧园区, 1.搜索功能, 2.excel导出, 3.网络请求的优化, 4.后端返回数据字段不够前端自定义字段, 5.树状组件怎么实现的？, 6.记住我优化, 7.数据基础渲染, 8.列表基础渲染, 9.状态适配, 10.上传图片, 11.菜单路由控制权限, 12.按钮控制权限, 13.微前端, 开发中遇到的问题, 1.refresh_token, 2.实现vant组件自动按需加载和自动导入, 3.@vueusex2Fcore, 4.极速问诊, 5.问诊室-websocket介绍, 6. Vue 项目权限处理, 7. 如何处理 打包出来的项目(首屏)加载过慢的问题, 8. 你在项目中遇到过什么技术难题, 组件封装, 1.nav-bar 组件结构, 2.radio-btn 组件封装, 3.支付抽屉组件封装, 4.将树形的操作内容单独抽提成组件, 5.封装一个通用的工具栏, 6.新增员工的弹层组件, 7.个人详情组件和岗位详情组件封装, 8.封装上传图片组件前端基础的新特性的新特性新特性拖拽释放自定义属性语义化标签地理表单控件新特性盒子模型线性渐变过渡动画字体图标盒子水平垂直居中绝对定位布局选择器优先级行内样式选择器类选择器标签通配符继承浏览器默认属性的理解是新增的一个相对单位根使用为元素设定字体大小时仍然是相对大小但相对的只是根元素手淘方案拿到设计稿除以得到基准值引入设计稿基准值即可换算为静态定位默认值不脱离文档流绝对定位找最近一级带有定位的父级元素进行移动脱离文档流相对定位固定定位脱离文档流参照物浏览器窗口粘性定位浮动浮动将元素排除在普通流之外即元素将脱离文档流不占据空间浮动元素碰到包含它的边界或者浮动元素的边界停留子元素浮动后不占位置父元素的高度无法被撑开影响与父元素同级的元素与浮动元素同级的非浮动元素内联元素会跟随其后若非第一个元素浮动则该元素之前的元素也需要浮动否则会影响页面显示的结构解决方法清除浮动额外标签法双伪元素清除法单伪元素清除法构建为父元素添加溢出隐藏定高法伪类和伪元素伪类用于已有元素处于某种状态时为其添加对应的样式这个状态是根据用户行为而动态变化的伪元素用于创建一些不在树中的元素并为其添加样式例如我们可以通过预处理器用来预编译或增强了代码的复用性还有层级变量循环函数等具有很方便的组件模块化开发能力极大的提高工作效率适配开发者拿到设计稿假设设计稿尺寸为设计稿的元素标注是基于此宽度标注开始开发对设计稿的标注进行转换把换成比如页面元素字体标注的大小是换成为对于需要等比缩放的元素使用转换后的单位对于不需要缩放的元素比如边框阴影使用固定单位如何解决塌陷外边距塌陷共有两种情况第一种情况两个同级元素垂直排列上面的盒子给下面的盒子给那么他们两个的间距会重叠以大的那个计算解决这种情况的方法为两个外边距不同时出现第二种情况两个父子元素内部的盒子给其父级也会受到影响同时产生上边距父子元素会进行粘连解决方案为父盒子设置添加后父子盒子就不是真正意义上的贴合可以设置成透明为父盒子添加为父盒子设定值为父盒子添加为父盒子添加通过的哪些方式可以实现隐藏页面上的元素方式说明通过将元素的透明度设置为实现看起来隐藏的效果但是依然会占用空间并可以进行交互与透明度为的方案非常类似会占据空间但不可以进行交互只会隐藏元素溢出的部分占据空间且不可交互可以彻底隐藏元素并从文档流中消失不占据空间也不能交互且不影响布局通过将元素的层级置于最底层让其他元素覆盖住它达到看起来隐藏的效果通过将元素进行缩放缩小为依然会占据空间但不可交互只是一个视觉效果不会影响其它盒子的布局通过将元素定位到屏幕外面达到看起来看不到的效果如何理解可以将它看做三维坐标系中的轴方向上的图层层叠顺序元素默认的为可通过修改来控制设置了值的元素的图层位置的小坑如果父辈元素有定位且配置了优先按照父辈元素的定位的进行比较层级当前盒子的层级只是在父元素里面的层级谈谈你对的理解在真实的应用场景中通常会遇到各种各样不同尺和分辨率的设备为了能在所有这些设备上正常的布局我们的应用界面就需要响应式的界设计方式来满这种复杂的布局需求弹性盒模型的优势在于开发员只需要声明布局应该具有的为不需要给出具体的实现式浏览器负责完成实际布局当布局涉及到不定宽度分布对的场景时就要优先考虑弹性盒布局你能联想到的语法有哪些呢调整主轴方向主轴方向为水平向右主轴方向为竖直向下主轴方向为水平向左主轴方向是竖直向上主要用来设置主轴方向的对齐方式弹性盒子元素将向起始位置对齐弹性盒子元素将向结束位置对齐弹性盒子元素将向行中间位置对齐弹性盒子元素会平均地分布在行里第一个贴左边最后一个贴右边其他盒子均分保证每个盒子之间的空隙是相等的用于调整侧轴的对齐方式元素在侧轴的起始位置对齐元素在侧轴的结束位置对齐元素在侧轴上居中对齐元素的高度会被拉伸到最大不给高度时才拉伸属性控制容器是单行或者多行默认不换行不换行默认如果宽度溢出会压缩子盒子的宽度当宽度不够的时候会换行用来设置多行的容器的排列方式各行向侧轴的起始位置堆叠各行向弹性盒容器的结束位置堆叠各行向弹性盒容器的中间位置堆叠各行在侧轴中平均分布第一行贴上边最后一个行贴下边其他行在弹性盒容器中平均分布拉伸不设置高度的情况下可参考布局教程的区别变量声明方式在变量未赋值时变量为使用声明变量时也为作用域的作用域为方法作用域只要在方法内定义了整个方法内的定义变量后的代码都可以使用变量声明方式在变量为声明前直接使用会报错作用域为块级作用域通常比范围要小禁止重复声明变量否则会报错可以重复声明变量声明为常量声明方式声明变量时必须初始化在后面出现的代码中不能再修改常量的值实际上保证的并不是变量的值不得改动而时变量指向的哪个内存地址不得改动数据类型区别基本数据类型引用数据类型普通对象数组对象正则对象日期对象数学函数对象是一个数值类型但不是一个具体的数字是干嘛的是否会改变原数组是来截取的参数可以写返回的是一个新的数组功能有插入删除替换返回删除的值该方法会改变原数组数组去重创建对象的几种方式简单对象的创建使用对象字面量的方式一个使用工厂方式来创建关键字使用创建对象使用现有对象作为原型使用中的类创建对象其实质还是使用构造函数如何区分数组和对象通过中的通过来识别通过调用来识别返回返回通过方法来识别作用域和作用域链作用域就是一个独立的地盘让变量不会外泄暴露出去也就是说作用域最大的用处就是隔离变量不同作用域下同名变量不会有冲突全局作用域和局部作用域分为函数作用域和块级作用域之前没有块级作用域只有全局作用域和函数作用域的到来为我们提供了块级作用域可通过新增命令和来体现什么是作用域链作用域本质上是底层的变量查找机制在函数被执行时会优先查找当前函数作用域中查找变量如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域总结嵌套关系的作用域串联起来形成了作用域链相同作用域链中按着从小到大的规则查找变量子作用域能够访问父级作用域父级作用域无法访问子级作用域当代码在一个环境中执行时会创建变量对象的一个作用域链由子级作用域返回父级作用域中寻找变量就叫做作用域链作用域链中的下一个变量对象来自包含环境也叫外部环境而再下一个变量对象则来自中的最后一个对象作用域链前端始终都是当前执行的代码所在环境的变量对象如果环境是函数则将其活动对象作为变量对象如何延长作用域链执行环境的类型只有两种全局和局部函数但是有些语句可以在作用域链的前端临时增加一个变量对象该变量对象会在代码执行后被移除具体来说就是执行这两个语句时作用域链都会得到加强语句的块会创建一个新的变量对象包含的是被抛出的错误对象的声明语句语句会将指定的对象添加到作用域链中和的区别相同点都是循环遍历数组中的每一项每次执行匿名函数都支持三个参数参数分别为当前每一项索引值原数组匿名函数中的都是指向只能遍历数组不同点会分配内存空间存储新数组并返回不会返回数据允许更改原始数组的元素返回新的数组遍历对象的方法循环方法获取对象中所有的键对应方法操作符具体干了什么呢创建新对象构造函数指向新对象执行构造函数代码修改添加新的属性返回新对象类数组转换为数组使用使用使用进行属性遍历并组成新的数组简单说说中有哪几种内存泄露的情况意外的全局变量闭包未被清空的定时器未被销毁的事件监听引用和区别概念是异步编程的一种解决方案比传统的解决方案回调函数和事件更合理和更强大简单地说好比容器里面存放着一些未来才会执行完毕异步的事件的结果而这些结果一旦生成是无法改变的也是异步编程的一种解决方案他遵循的是函数的语法糖他拥有内置执行器不需要额外的调用直接会自动执行并输出结果它返回的是一个对象两者的区别的出现解决了传统函数导致的地域回调问题但它的语法导致了它向纵向发展行成了一个回调链遇到复杂的业务场景这样的语法显然也是不美观的而代码看起来会简洁些使得异步代码看起来像同步代码的本质是可以提供等同于同步效果的等待异步返回能力的语法糖只有这一句代码执行完才会执行下一句与一样是非阻塞的是基于实现的可以说是改良版的它不能用于普通的回调函数和区别要等到整个页面在内存中正常渲染结束结构完全生成以及其他脚本执行完成才会执行多个脚本会按照它们在页面出现的顺序加载渲染完再执行一旦下载完渲染引擎就会中断渲染执行这个脚本以后再继续渲染多个脚本是不能保证加载顺序的下载完就执行延迟加载有哪些方式等全部解析完成才会执行代码顺次执行代码和解析是同步的一起的不是顺次执行脚本谁先加载完谁先执行同步和异步同步指在主线程上排队执行的任务只有前一个任务执行完毕才能继续执行下一个任务也就是调用一旦开始必须这个调用返回结果划重点才能继续往后执行程序的执行顺序和任务排列顺序是一致的异步异步任务是指不进入主线程而进入任务队列的任务只有任务队列通知主线程某个异步任务可以执行了该任务才会进入主线程每一个任务有一个或多个回调函数前一个任务结束后不是执行后一个任务而是执行回调函数后一个任务则是不等前一个任务结束就执行程序的执行顺序和任务的排列顺序是不一致的异步的我们常用的和函数都是异步操作和的区别声明了一个变量但没有赋值访问对象上不存在的属性函数定义了形参但没有传递实参使用对表达式求值看过作者文献最初设计的时候借助了的语言会被隐式的转换为很不容易发现错误先有后有是为了填补之前的坑具体区别的最初版本是这样区分的是一个表示无的对象转为数值时为值转为数值才为是一个空值表示无的对象有属于自己的类型而不属于类型二进制的前三位为会被判断为对象类型的作用和区别作用都可以改变函数内部的指向区别点和会调用函数并且改变函数内部指向和传递的参数不一样传递参数形式必须数组形式不会调用函数可以改变函数内部指向应用场景检测数据类型经常和数组有关系比如借助于数学对象实现数组的最大值最小值比如改变定时器内部的指向指向普通函数箭头函数谁调用了函数或者方法那么这个函数或者对象中的就指向谁匿名函数中的匿名函数的执行具有全局性则匿名函数中的指向是而不是调用该匿名函数的对象箭头函数中的箭头函数中的是在函数定义的时候就确定下来的而不是在函数调用的时候确定的箭头函数中的指向父级作用域的执行上下文箭头函数无法使用和方法改变指向因为其值在函数定义的时候就被确定下来继承继承一些属性构造的过程和方法继承的好处提高了代码的复用性提高了代码的维护性让类与类之间产生了关系是多态的前提继承的弊端类的耦合性增强了但是开发的原则高内聚低耦合构造函数继承原型链继承原型式继承组合继承寄生式继承寄生组合式继承继承的设计之初就是为了解决回调地狱的问题的本意是承诺这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了的三种状态对象实例创建时候的初始状态可以理解为成功的状态可以理解为失败的状态无效代码不会执行当我们在构造的时候构造函数内部的代码是立即执行的的链式调用如果上一个中返回一个新的对象则可以交给下一个继续处理每次调用返回的都是一个新的实例这就是可用链式调用的原因如果中返回的是一个结果的话会把这个结果传递下一次中的成功回调如果中出现异常会走下一个的失败回调在中使用了那么的值会被包装中可以不传递参数如果不传递会透到下一个中会捕获到没有捕获的异常包装成存在一个缺点无法取消错误需要通过回调函数捕获场景异步请求定时器并行异步操作当需要同时进行多个异步操作并在它们都完成后执行一些任务时可以使用方法静态常用的方法等待机制等待完才会走赛跑机制内置的常用对象有哪些对象及方法函数参数集合函数参数的数组一个函数的参数和其他属性当前正在运行的函数传递给函数的参数的个数数组属性将一个数组转成字符串返回一个字符串将数组中各元素颠倒顺序运算符只能删除数组元素的值而所占空间还在总长度没变删除数组中第一个元素返回删除的那个值并将长度减删除数组中最后一个元素返回删除的那个值并将长度减往数组前面添加一个或多个数组元素长度要改变往数组结尾添加一个或多个数组元素长度要改变连接数组返回数组的一部分对数组元素进行排序插入删除或替换数组的元素把数组转换成局部字符串将数组转换成一个字符串遍历所有元素判断所有元素是否都符合条件排序对元素重新组装生成新数组过滤符合条件的元素字符串对象获取字符串的长度将字符串中的字母转成全大写如返回指定下标位置的一个字符如果没有找到则返回空字符串在原始字符串返回一个子字符串在原始字符串返回一个子字符串将一个字符串转成数组返回字符串中的第个字符的代码连接字符串从字符编码创建个字符串返回一个子字符串在原始字符串中的索引值查找顺序从左往右查找如果没有找到则返回从后向前检索一个字符串用本地特定的顺序来比较两个字符串找到一个或多个正则表达式的匹配替换一个与正则表达式匹配的子串检索与正则表达式相匹配的子串抽取一个子串把字符串转换小写将字符串转换成大写将字符串转换成小写返回字符串将字符串转换成大写谈谈事件委托的理解事件代理则是一种简单的技巧把事件处理器添加到一个上级元素上这样就避免了把事件处理器添加到多个子级元素上这主要得益于浏览器的事件冒泡机制优点减少事件注册节省内存在上代理所有的事件在上代理所有的事件简化了节点更新时相应事件的更新不用在新添加的上绑定事件当删除某个时不用移解绑上面的事件缺点事件委托基于冒泡对于不冒泡的事件不支持层级过多冒泡过程中可能会被某层阻止掉理论上委托会导致浏览器频繁调用处理函数虽然很可能不需要处理所以建议就近委托比如在上代理而不是在上代理把所有事件都用代理就可能会出现事件误判比如在中代理了所有的事件另外的人在引用改时可能不知道造成单击触发了两个事件什么是闭包定义一个作用域可以访问到另外一个函数内部的局部变量或者说一个函数子函数访问另一个函数父函数中的变量此时就会产生闭包那么这个变量所在的函数我们就称之为闭包函数优缺点闭包的主要作用延伸了变量的作用范围因为闭包函数中的局变量不会等着闭包函数执行完就销毁因为还有别的函数要调用它只有等着所有的函数都调用完了它才会销毁实现数据的私有闭包会造成内存泄露如何解决用完之后手动是释放优点可以减少全局变量的定义避免全局变量的污染能够读取函数内部的变量在内存中维护个变量可以做缓存缺点造成内存泄露闭包可能在函数外部改变函数内部变量的值造成性能损失使用场景封装私有变量闭包可以用于创建模块化的代码结构避免全局变量的污染在处理用户输入或频繁触发的事件时可以通过闭包来实现防抖和节流的效果防抖和节流是优化性能和减少不必要请求的常见方法缓存数据通过闭包可以在函数内部缓存一些计算结果或其他重要数据避免重复计算或请求和的区别推荐在循环对象属性的时候使用在遍历数组的时候的时候使用循环出的是循环出的是注意是新引入的特性修复了引入的的不足不能循环普通的对象需要通过和搭配使用和的区别是把一串字符根据某个分隔符分成若干个元素存放在一个数组里即切割成数组的形式是把数组中的字符串连成一个长串可以大体上认为是的逆操作深拷贝首先浅拷贝和深拷贝只针对引用类型浅拷拷贝的是地址拷贝对象展开运算符拷贝数组如果是简单数据类型拷贝值不会影响元对象引用数据类型拷贝的是地址深拷拷贝的是对象不是地址递归对象中的和里的前实现深拷的主要是利对象中的和用到处理嵌套对象和数组创建一个独立的副本这样对副本的修改不会影响原始数据操作不可变的数据序列化和反序列化当你需要将对象转换为字符串进行存储或传输时深拷贝可以帮助你创建一个完整的副本并且在后续需要时可以还原为原始对象原型链原型构造函数通过原型分配的函数是所有对象所共享的规定每一个构造函数都有一个属性指向另一个对象所以我们也称为原型对象这个对象可以挂载函数对象实例化不会多次创建原型上的函数节约内存我们可以把那些不变的方法直接定义在对象上这样所有对象的实例就可以共享这些方法构造函数和原型对象中的都指向实例化对象属性每个原型对象里面都有个属性该属性指向该原型对象的构造函数使用场景如果有多个对象的方法我们可以给原型对象采取对象形式赋值但是这样就会覆盖构造函数原型对象原来的内容这样修改后的原型对象就不再指向当前构造函数了此时我们应该在修改后的原型对象中添加一个指向原来的构造函数对象原型实例对象的原型对象都有一个属性指向构造函数的原型对象之所以我们对象可以使用构造函数原型对象上的方法和属性就是因为对象有原型的存在原型链所有的实例对象里面都有对象原型指向原型对象所有的原型对象里面有指向创造该原型对象的构造函数当访问一个对象的属性和方法时首先查找这个对象本身有没有该属性如果没有就查找它的原型也就是指向的原型对象如果还没有就查找原型对象上的原型依此类推一直找到为止对象原型的意义就在于为对象成员查找机制提供一个方向或者说一条路线可以使用运算符用于检测构造函数的属性是否出现在某个实例对象的原型链上防抖和节流防抖触发频事件后秒内函数只会执次如果秒内频事件再次被触发则重新计算时间使用场景搜索框防抖手机号邮箱验证输入检测手写防抖函数思路防抖的核心就是利用实现的声明一个定时器变量当鼠标每次滑动都先判断是否有定时器了如果有定时器先清除以前的定时器如果没有定时器则开启定时器记得存到变量里面在定时器里面调用要执行的函数节流频事件触发但在秒内只会执次所以节流会稀释函数的执频率使用场景小米轮播图切换点击效果页面尺寸缩放滚动条滚动手写节流函数思路一样声明一个定时器变量当鼠标每次滑动都先判断是否有定时器了如果有定时器则不开启新定时器如果没有定时器则开启定时器记得存到变量里面定时器里面调用执行的函数清空定时器区别防抖动是将多次执变为最后次执节流是将多次执变成每隔段时间执模板字符串箭头函数遍历对象的键合并对象常用于对象拷贝用于在一个模块中加载另一个含有接口的模块用于对外输出本模块介绍下的区别区别应用场景用于数据重组用于数据储存成员不能重复只有键值没有键名类似数组可以遍历方法有本质上是健值对的集合类似集合可以遍历可以跟各种数据格式转换用于修饰一个函数表示一个函数是异步的要用在函数中后面一般会跟一个对象只会等待成功的结果浏览器区别共同点都是保存在浏览器端且同源的区别数据始终在同源的请求中携带即使不需要即在浏览器和服务器间来回传递而和不会自动把数据发送给服务器仅在本地保存数据还有路径的概念可以限制只属于某个路径下存储大小限制也不同数据不能超过同时因为每次请求都会携带所以只适合保存很小的数据如会话标识和虽然也有存储大小的限制但比大得多可以达到或更大数据有效期不同仅在当前浏览器窗口关闭之前有效始终有效窗口或浏览器关闭也一直保存因此用作持久数只在设置的过期时间之前有效即使窗口关闭或浏览器关闭作用域不同不在不同的浏览器窗口中共享即使是同一个页面在所有同源窗口中都是共享的也是在所有同源窗口中都是共享的支持事件通知机制可以将数据更新的通知发送给监听者的接口使用更方便浏览器输入发生了什么解析查询连接处理请求接受响应渲染页面浏览器是如何渲染页面的不同浏览器内核渲染机制有所区别被解析器解析成树被解析器解析成树结合树和树生成一棵渲染树这一过程称为生成布局浏览器在屏幕上画出渲染树中的所有节点将布局绘制在屏幕上显示出整个页面重绘重排概念重排当渲染树的一部分必须更新并且节点的尺寸发生了变化浏览器会使渲染树中受到影响的部分失效并重新构造渲染树重绘是在一个元素的外观被改变所触发的浏览器行为浏览器会根据元素的新属性重新绘制使元素呈现新的外观比如改变某个元素的背景色文字颜色边框颜色等等区别重绘不一定需要重排比如颜色的改变重排必然导致重绘比如改变网页位置引发重排添加删除可见的元素的位置改变元素的尺寸改变外边距内边距边框厚度宽高等几何属性页面渲染初始化浏览器窗口尺寸改变获取某些属性当获取一些属性时浏览器为取得正确的值也会触发重排它会导致队列刷新这些属性包括所以在多次使用这些值时应进行缓存优化方案浏览器会维护个队列把所有会引起重排重绘的操作放入这个队列等队列中的操作到一定数量或者到了一定时间间隔浏览器就会队列进行一批处理这样多次重排重绘变成一次重排重绘减少不要一条一条地修改的样式可以先定义好的然后修改的不要把结点的属性值放在一个循环里当成循环里的变量为动画的元件使用或的那么修改他们的是不会的千万不要使用布局因为可能很小的一个小改动会造成整个的重新布局及其内部元素除外它可能需要多次计算才能确定好其在渲染树中节点的属性通常要花倍于同等元素的时间这也是为什么我们要避免使用做布局的一个原因不要在布局信息改变的时候做查询会导致渲染队列强制刷新事件循环是一门单线程执行的语言也就是说同一时间只能做一件事情为了防止某个耗时任务导致程序假死的问题异步代码由委托给宿主环境浏览器环境等待执行的事件分两种宏任务包括整体代码微任务非是同步的中具体执行事件的执行顺序先执行宏任务然后执行微任务任务有同步的任务和异步的任务同步的进入主线程异步的进入并注册函数异步事件完成后会将回调函数放在队列中如果还有异步的宏任务那么就会进行循环执行上述的操作主线程会不断从任务队列中按顺序取任务执行每执行完一个任务都会检查队列是否为空执行完一个任务的具体标志是函数执行栈为空如果不为空则会一次性执行完所有然后再进入下一个循环去任务队列中取下一个任务执行详细步骤选择当前要执行的宏任务队列选择一个最先进入任务队列的宏任务如果没有宏任务可以选择则会跳转至的执行步骤将事件循环的当前运行宏任务设置为已选择的宏任务运行宏任务将事件循环的当前运行任务设置为将运行完的宏任务从宏任务队列中移除步骤进入检查点更新界面渲染返回第一步跨域跨域是什么跨域指的是在浏览器中当一个请求的源与目标资源的源不一致时即发生跨域访问在默认情况下浏览器的同源策略会阻止这种跨域访问同源策略是为了保护用户的信息安全防止恶意网站对其他网站的资源进行访问和操作同源策略规定几个约束协议相同域名相同端口号相同同源策略限制内容有等节点请求跨域解决法式代理服务器的式服务端允许跨域访问取消浏览器的跨域限制常见码请求成功资源等被永久转移到其它服务器理解请求客户端的请求但是拒绝执此请求请求的资源等不存在内部服务器错误作为关或者代理作的服务器尝试执请求时从远程服务器接收到了个效的响应和的区别明传输数据都是未加密的安全性较差数据传输过程是加密的安全性较好使协议需要到数字证书认证机构申请证书般免费证书较少因需要定费响应速度快主要是因为使三次握建连接客户端和服务器需要交换个包除了的三个包还要加上握需要的个包所以共是个包和使的是完全不同的连接式的端也不样前者是后者是其实就是建构在之上的协议所以要较要更耗费服务器资源前端优化策略减少请求数将脚本往后挪减少对并发下载的影响避免频繁的操作压缩图压缩优化对传输资源进体积压缩按需加载组件化减少不必要的存储在客户端伴随着请求在浏览器和服务器之间传递由于在访问对应域名下的资源时都会通过请求发送到服务器从会影响加载速度所以尽量减少不必要的介绍一下是一种网络通信协议是开始提供的一种在单个连接上进行全双工通信的协议这个对比着协议来说协议是一种无状态的无连接的单向的应用层协议通信请求只能由客户端发起服务端对请求做出应答处理协议无法实现服务器主动向客户端发起消息连接允许客户端和服务器之间进行全双工通信以便任一方都可以通过建立的连接将数据推送到另一端只需要建立一次连接就可以一直保持连接状态的作就是处理依赖模块化打包压缩件管理插件打包原理把所有依赖打包成个件通过代码分割成单元段并按需加载的优势是以的形式来书写脚本滴但对的持也很全便旧项进代码迁移能被模块化的不仅仅是了开发便捷能替代部分的作如打包压缩混淆图转等扩展性强插件机制完善和的区别以及使用场景区别使用或传参而将数据放在中的会有长度上的限制则的数据则可以非常大比安全因为数据在地址栏上不可见最本质的区别基于协议进行请求其实和无区别只是请求时的方式不同都可以携带请求体也可以在带参数区别来自于浏览器对长度的限制请求体大小来源于服务器的限制还有语义的区别是获取是提交是用来从服务器上获得数据而是用来向服务器上传递数据有哪些法标准中定义了种请求法标准中新增了请求法各个方法的具体作用是什么方法功能通常于请求服务器发送某些资源发送数据给服务器请求资源的头部信息并且这些头部与法请求时返回的致该请求法的个使场景是在下载个件前先获取其再决定是否要下载以此可以节约带宽资源于全量修改标资源看接口也可以用于添加于删除指定的资源于获取的资源所持的通信选项跨域请求前预检请求判断目标是否安全该方法会让服务器原样返回任意客户端请求的信息内容用于诊断和判断协议中预留给能够将连接改为管道式的代理服务器把服务器作为跳板让服务器代替用户去访问其它网页之后把数据原原本本的返回给用户于对资源进部分修改参数是在地址栏中传递的参数是在请求体传递的谈谈你对生命周期的理解生命周期是什么实例有一个完整的生命周期也就是从开始创建初始化数据编译模版挂载渲染更新渲染卸载等一系列过程我们称这是的生命周期各个生命周期的作用组件实例被创建之初组件的属性生效之前组件实例已经完全创建属性也绑定但真实还没有生成还不可用在挂载开始之前被调用相关的函数首次被调用被新创建的替换并挂载到实例上去之后调用该钩子组件数据更新之前调用发生在虚拟打补丁之前组件数据更新之后专属组件被激活时调用专属组件被销毁时调用组件销毁前调用组件销毁后调用什么是是的内置组件当它包裹动态组件时会缓存不活动的组件实例不是销毁它们是个抽象组件它身不会渲染成个元素也不会出现在组件链中的优点在组件切换过程中把切换出去的组件保留在内存中防重复渲染减少加载时间及性能消耗提户体验性有三个属性只有匹配的组件会被缓存任何匹配的组件都不会被缓存最多可以缓存多少组件实例的使会触发两个命周期函数这两个函数分别是当组件被激活使的时候触发可以简单理解为进这个的时候触发当组件不被使的时候触发可以简单理解为离开这个的时候触发数据双向绑定原理数据变化更新视图输入框内容变化时中的数据同步变化即的变化中的数据变化时文本节点的内容同步变化即的变化数据双向绑定是通过数据劫持结合发布者订阅者模式的式来实现的数据劫持是通过来实现数据劫持其中会有和法当读取属性值时就会触发法在中如果数据发了变化就会通过对属性设置个函数当数据改变了就会来触发这个函数实现一个监听器实现一个解析器实现一个订阅者实现一个订阅器路由守卫全局路由守卫全局前置守卫路由跳转前触发全局解析守卫在所有组件内守卫和异步路由组件被解析之后触发全局后置守卫路由跳转完成后触发路由独享守卫路由对象单个路由配置单个路由进前触发组件路由守卫在组件命周期阶段触发当前路由改变时触发导航离开该组件的对应路由时触发参数即将要进的标路由对象即将要离开的路由对象是否可以进某个具体路由或者是某个具体路由的路径有五个核概念的基本数据来存储变量从基本数据派的数据相当于的计算属性提交更新数据的法必须是同步的如果需要异步使每个都有个字符串的事件类型和个回调函数回调函数就是我们实际进状态更改的地并且它会接受作为第个参数提交载荷作为第个参数和的功能致相同不同之处在于提交的是不是直接变更状态可以包含任意异步操作模块化可以让每个模块拥有的使得结构常清晰便管理组件通讯组件向组件传值组件通过属性的式向组件传值组件通过来接收组件向组件传值组件绑定个事件通过来触发其他式缓存事件总线怎么定义的动态路由在录下的件中对属性加上使对象的和的区别双向绑定使使的新特性来劫持数据当数据改变时发出通知根元素必须要有个根元素要求算法虚拟全量较增加了静态标记生命周期不同与的区别持缓存相依赖的数据发改变才会重新计算不持缓存只要监听的数据变化就会触发相应操作不持异步当内有异步操作时是法监听数据变化的持异步操作属性的属性值是函数函数返回值为属性的属性值中每个属性都可以设置与法监听的数据必须是中声明过或组件传递过它是计算属性主要用于值的计算并一般会返回一个值所以它更多于计算值的场景它具有缓存性当访问它来获取值时它的函数所计算出来的值会进行缓存只有当它依赖的属性值发生了改变那下次再访问时才会重新调函数来计算它适于计算较消耗性能的计算场景必须要有一个返回值它更多的是起到观察的作类似于对数据进行变化的监听并执行回调主要于观察或本组件的值当这些值发生变化时执处理操作不一定要返回某个值建议当目的是进数值计算且依赖于其他数据那么推荐使用当需要在某个数据发生变化的同时做些稍复杂的逻辑操作那么推荐使和的区别是路由信息对象包括等路由信息参数是路由实例对象包括了路由跳转法钩函数等路由模式有种有种路由模式使值来作路由持所有浏览器包括不持的浏览器依赖和服务器配置具体可以查看模式持所有运环境如服务器端如果发现没有浏览器的路由会动强制进这个模式和的区别和的区别如下可以直接监听对象而非属性可以直接监听数组的变化有多达种拦截方法不限于等等是不具备的返回的是一个新对象我们可以只操作新的对象达到目的而只能遍历对象属性直接修改作为新标准将受到浏览器厂商重点持续的性能优化也就是传说中的新标准的性能红利兼容性好支持而的存在浏览器兼容性问题而且无法用磨平因此的作者才声明需要等到下个大版本才能用重写新特性有哪些性能提升响应式性能提升由原来的改为基于的使其速度更快消除警告重写了突破了的性能瓶颈进行模板编译优化更加高效的组件初始化更好的支持有更好的类型推断使得把支持得非常好新增是新增的功能比更强大它可以把各个功能模块独立开来提高代码逻辑的可复用性同时代码压缩性更强新增组件不再限制只有一个根几点传送门允许我们将控制的内容传送到任意的中等待异步组件时渲染一些额外的内容让应用有更好的用户体验支持摇树优化摇树优化后会将不需要的模块修剪掉真正需要的模块打到包内优化后的项目体积只有原来的一半加载速度更快自定义渲染器实现的方式进行编程与区别和的区别是切换是完整的销毁和重新创建使频繁切换时运时较少改变时中和优先级在和中的区别实践中不管是或者都不应该把和放在一起使用在中在一个元素上同时使用和时会优先作用在中总是优先于生效中的优先级是高于的放在一起会先执行循环在判断条件并且如果值渲染列表中一小部分元素也得再每次重渲染的时候遍历整个列表比较浪费资源中的优先级是高于的所以执行时它调用相应的变量如果不存在就会导致异常是干啥的是的语法糖简化了组合式的写法并且运行性能更好使用语法糖的特点属性和方法无需返回可以直接使用引入组件的时候会自动注册无需通过手动注册使用接收父组件传递的值获取属性获取插槽获取自定义事件默认不会对外暴露任何属性如果有需要可使用与的区别中的和是中用于数据管理的两种不同的响应式用于创建一个包装简单值的响应式引用例如一个数字字符串或对象当创建一个响应式引用时它返回一个对象该对象具有一个属性该属性指向实际值当返回的对象中的属性更改时组件将自动重新渲染用于创建一个响应式对象该对象可以包含多个属性和嵌套属性当使用创建响应式对象时返回的对象是一个代理对象该对象具有与原始对象相同的属性并且任何对代理对象属性的更改都将触发组件的重新渲染的使用实现双向绑定的语法糖常用于表单与组件之间的数据双向绑定的原理绑定一个属性指令给当前元素绑定事件可看出绑定在表单上时其实就是绑定和监听事件的结合体组件上的双向绑定原理绑定在组件上的时候做了以下步骤在父组件内给子组件标签添加其实就是给子组件绑定了属性子组件内使用创建创建属性可以拿到父组件传递下来的值名字必须是子组件内部更改的时候必须通过派发一个事件并携最新的值会自动监听事件把接收到的最新的值同步赋值到绑定的变量上中的辅助函数怎么使用的辅助函数有个函数返回的是一个对象通常我们需要使用一个工具函数将多个对象合并为一个以使我们可以将最终对象传给属性辅助函数仅仅是将中的映射到局部计算属性因此你可以这样来使用他辅助函数将组件中的映射为其原理就是将映射为在组件中使用分发或者使用辅助函数将组件的映射为调用是什么有什么作用原理是什么又名插槽是的内容分发机制组件内部的模板引擎使用元素作为承载分发内容的出口插槽是子组件的一个模板标签元素而这一个标签元素是否显示以及怎么显示是由父组件决定的又分三类默认插槽具名插槽和作用域插槽默认插槽又名匿名插槽当没有指定属性值的时候一个默认显示插槽一个组件内只有有一个匿名插槽具名插槽带有具体名字的插槽也就是带有属性的一个组件可以出现多个具名插槽作用域插槽默认插槽具名插槽的一个变体可以是匿名插槽也可以是具名插槽该插槽的不同点是在子组件渲染作用域插槽时可以将子组件内部的数据传递给父组件让父组件根据子组件的传递过来的数据决定如何渲染该插槽实现原理当子组件实例化时获取到父组件传入的标签的内容存放在中默认插槽为具名插槽为为插槽名当组件执行渲染函数时候遇到标签使用中的内容进行替换此时可以为插槽传递数据若存在数据则可称该插槽为作用域插槽的使用用法将回调延迟到下次更新循环之后执行在修改数据之后立即使用它然后等待更新它跟全局方法一样不同的是回调的自动绑定到调用它的实例上的应用场景在的生命周期钩子函数中进行操作一定要放在函数中执行在钩子函数执行的时候其实并未进行任何渲染而此时进行操作无异于徒劳所以此处一定要将操作的代码放进的回调函数中钩子函数因为该钩子函数执行时所有的挂载和渲染都已完成此时在该钩子函数中进行任何操作都不会有问题在数据变化后要执行某个操作而这个操作需要随数据改变而改变结构时这个操作都是需要放置的回调函数中中的语法唯一值作用给列表项添加的唯一标识便于进行列表项的正确排序复用为什么加的默认行为会尝试原地修改元素就地复用实例代码删除注意的值只能是字符串或数字类型的值必须具有唯一性推荐使用作为唯一不推荐使用作为会变化不对应必须是一个函数为什么要写成函数一个组件的选项必须是一个函数目的是为了保证每个组件实例维护独立的一份数据对象每次创建新的组件实例都会新执行一次函数得到一个新对象编程式导航如何跳转传参路径跳转传参路径参数名参数值参数参数值路径参数名参数值参数名参数值动态路由传参路径参数值路径参数值命名路由跳转传参路由名字参数名参数值参数名参数值动态路由传参需要配动态路由路由名字参数名参数值什么是模式层数据模型层通过等完成客户端和服务端业务模型的同步层视图层作为视图模板存在其实就是个动态模板层视图模型层负责暴露数据给层并对层中的数据绑定声明指令声明事件绑定声明进行实际的业务逻辑实现数据变化了视图自动更新底层会做好监听当数据变化时层会自动更新视图变化了绑定的数据自动更新会监听双向绑定的表单元素的变化旦变化绑定的数据也会得到动更新的优缺点有哪些优点实现了视图和模型的分离降低代码耦合提视图或逻辑的复性提了可测试性的存在可以帮助开发者更好地编写测试代码能动更新利双向绑定数据更新后视图动更新让开发者从繁琐的动操作中解放出来缺点难被调试因为使了双向绑定的模式当我们看到界发生异常了有可能是的代码产生的也有可能是代码的问题数据绑定使得个位置的被快速传递到别的位置要定位原始出问题的地就变得不那么容易了可采用的调试方案注释掉一段代码确定代码的位置打断点或者进行调试在个的模块中也会很虽然使上来说便了但如果期持有不释放内存就会造成更多的内存消耗占用的是浏览器的内存项目分析登录流程传统思路都是登录校验通过之后直接调用接口获取之后跳转到主页的登录思路登录表单校验通过调用提供的登录的登录的中会调用接口登录接口如果成功执行会返回利用的特性将共享的到中这样就统一管理了别的地方想要使用直接通过就可以登录接口会调用单独封装的请求模块请求模块中又会使用用到封装的请求工具而请求工具又要考虑区分开发环境和生产环境的问题请求时还要考虑前后分离项目产生的跨域问题要使用代理解决跨域登录模块业务实现思路首先设计并开发出登录页面的静态页面设置校验函数对手机号和密码实现校验基础校验和统一校验使用信息作为用户登录的唯一标识并且存储在中通过统一管理并且实现的持久化利用中设置请求拦截器在每次请求的请求头中注入信息作为登录的标识配合中的前置导航守卫函数实现对信息的统一监测和拦截登录主页模块的实现思路登录成功后根据业务的需求配合实现对样式的二次修改初始化中的信息更新登录后用户的信息收集封装获取用户资料利用中的属性完成用户登陆后的视图层渲染封装实现用户退出登录调用方法清除中保存的信息根据后端检测返回的状态码设置拦截器对失效信息实现拦截登录并提示用户失效登录流程拉取代码进行一些改造设计并且开发登录页面进行表单校验基础校验统一校验基础校验表单对象规则对象属性指定一下要使用哪条规则双向绑定统一校验获取表单的实例对象调用方法中实现用户的模块删除模板中原有的内容进行重写开启命名空间导出子模块实现的数据持久化存数据时一份存入一份存入中初始化时优先从本地取取不到再初始化为空串儿实现登录的方法代理解决跨域配置文件可以直接配置代理二次封装将请求方法封装到模块配置基础地址超出时间请求拦截器根据获取仓库中的来判断然后在中统一注入响应拦截器解构数据处理异常通用配置实例化基地址配置超时时间拓展方法可以调用多次每次执行都会生成一个独一无二的实例请求拦截器请求头中添加数据接口鉴权统一配置客户端发送请求请求拦截器针对请求参数做处理后端拓展可以添加多个请求拦截器客户端请求拦截器处理参数拦截器后端最后一定要失败就执行响应拦截器数据剥离失效错误处理前端自定义错误处理后端响应拦截器客户端成功回调失败回调不在这个之间默认包裹了一层把响应数据解构出来判断如果业务成功返回用户所需要的数据业务失效错误提示一个一个所有的响应错误信息统一处理封装接口将请求封装成方法统一存放到模块与页面分离可维护性高新建提供注册函数注册接口区分环境表单开发环境生产环境登录联调封装登录的中的用户模块调用登录接口登录成功后跳转到主页区分表单不同环境下的不同数据主页鉴权验证访问主页有放过没有跳到登录页访问登录有跳到主页没有放过前置守卫中来处理逻辑白名单智慧园区搜索功能思路分析把各种搜索条件当作请求参数发给后端后端会根据字段对数据库数据做过滤筛选拿到符合条件返回表单组件的双向绑定收集到当前的请求数据把收集到的表单参数发送接口给后端那符合条件的数据把拿到的数据关系显示在列表中导出实际开发过程中的导出前端主导流程调用列表接口把要导出的数据拿到数据的二次转化工作簿工作表单元格数据使用创建一个工作簿使用方法创建一个工作表把工作表添加到工作簿使用中文替换中文表头调用的导出方法工作中遇到了需求参考代码换接口数据二次处理处理表头后端主导最常见流程前端直接调用导出接口后端会把数据转换成文件流当成返回值返回直接触发浏览器的下载功能两种方案的本质区别把数据转化成的过程发生在哪里如果发生在浏览器前端主导如果发生在后端服务器后端主导前端主导处理数据量不能太大后端主导适合处理量大或量小都可网络请求的优化场景限制了请求个数保证只有打开时才请求怎么做到判断第一个参数是否能在第二个参数中找到如果能找到代表打开了通过匹配找到符合条件的第一项然后把找到的项返回通过匹配找到符合条件的第一项然后把找到项的下标值返回只有展开时获取数据并绑定展开或关闭点击行数组对象当前行的对象数组对象先拿到当前行的数据使用当前行的企业数据获取下面的合同列表数据把拿到的合同列表存入企业对象中但是里面没有存放的位置优化网络请求只在打开时才去触发核心拿到当前是打开的条件做判断判断条件第一个是否能在第二个中找到如果找到了代表打开了如果找不到代表收起了如果找到了这一项才回去调用接口后端返回数据字段不够前端自定义字段默认的返回的企业列表数据中没有一个存放合同列表的数据的数组通过映射自定义添加字段树状组件怎么实现的树形组件用层级结构展示信息可展开或折叠提供了树组件的应用组件中放置树形组件获取后台的数据递归转化树形结构首先分析数据的关联关系封装递归函数根据关联关系转化层级结构通过分析了解到父级的为子级的封装公共方法列表型数据转化树形找到了匹配的节点当前节点的和当前节点的子节点的是想等的找到的节点的子节点将子节点赋值给当前节点将列表型的数据转化成树形数据递归算法自身调用自身一定条件不能一样否则就会死循环遍历树形有一个重点要先找一个头儿记住我优化基础实现逻辑如果当前用户选中了记住在登录时把用户的信息存入本地在组件初始化的时候去取数据回填如果当前没有选中在登录时把数据清空数据基础渲染基础实现逻辑准备静态模版解决初始报错在中把模版绑定的数据都声明一遍封装接口参数名称类型参数数量组件中封装一个独立的方法在方法中调用接口函数复用的好处调用之前做一些额外的参数处理选择一个合适生命周期钩子函数调用独立的方法都可以使用数据渲染模版数据驱动视图列表基础渲染实现步骤按照接口文档请求列表接口封装一下参数准备响应式的数据以后端接口实际返回为主在封装一个方法参数的二次处理调用接口数据赋值生命周期钩子函数调用这个方法把响应式数据绑定组件身上文档组件要求通过什么属性绑定就通过生命属性分页功能分页的逻辑页数总条数单页的条数组件分好页传入总数单页条数默认页数分出来页数总条数每页条数点击每页的时候获取当前页的数据重新渲染到上点击分页交互的实现点击时拿到当前点击的页数父组件从子组件获取内部的数据子传父回调参数拿到的是当前页把点击的页数赋值给请求参数页数使用最新的请求参数获取列表数据使用当前的页数去后端要当前页的数据重新渲染到状态适配场景后端返回的数据无法直接显示到页面中男女转化的状态码数量只有两个解决方案三元表达式女男转化的状态码比较多解决方案映射的方案女男带有模板的状态格式化直接可以把后端的数据渲染出来指定要渲染的字段不能直接渲染需要格式化格式化出来的内容一九是一个文本不需要手动传参自动传入插槽插值表达式渲染出来的是函数的返回值上传图片上传的流程点击上传按钮打开本地文件选择框上传前的文件校验接口要求传递一个类型的数据往的对象中字段使用完整的对象提交接口完成上传细节问题非常简单不需要做任何的自定义配置默认的配置项完成上传就行了需要自定义场景如果添加了上传前的校验流程先执行上传前的校验函数函数返回值为再执行上传函数函数参数上传前的函数对象做校验上传函数对象上传接口接口参数常规的接口上传接口前后端校验逻辑要保持一致文件大小小于文件类型前端要以这个为主因为接口不只是可以通过浏览器提交也可以通过其他方式提交基于界面操作类校验会失败自定义上传本来是一个用来配置默认上传的接口地址因为我们覆盖了所以用一个占个位置消除必填警告本身具备选择文件的能力覆盖原因默认的配置上传不够灵活仅支持一些简单的上传如果想要完全自定义上传在选择文件之后自动执行函数并且把一个对象传给我们对象中有一个属性就是我们要上传的对象上传前校验上传图片之前加一层校验目的为了限制用户上传的文件类型和大小如果我们添加了这个属性方法这个函数中必须的数据为才会继续执行方法如果校验不通过暂停执行不会走上传逻辑对象中两个属性文件大小文件类型文件类型营业执照点击上传只能上传文件且不超过上传实现流程打开本地文件并且校验这个文件是否符合要求按照接口的要求格式得到类型为对象按照要求往中添加字段数据字段名字段值调用上传接口拿到返回的文件地址和其有用的信息存入中的响应式数据的位置将来提交表单菜单路由控制权限权限数据的生成新增一个角色给角色配置权限数据新增一个员工给员工分配这个角色员工就有了当前角色下所有的权限数据完整的实现流程调用接口获取当前员工的权限数据在中编写逻辑里存放个人用户信息里调用时把目标数据出去给另一个模块使用文件中触发获取用户信息有时对权限数据做格式化处理产生两个权限数据一级路由权限数组二级路由权限数组把路由表拆分成两部分动态路由表需要加权限控制静态路由表不需要加权限控制拆分动态路由表导出使用初始化时候只处理静态路由表以一级和二级权限数组作为对主动态路由表做过滤筛选处理有资格加入到路由系统中的动态路由表使用一级权限点过滤一级路由使用二级权限点过滤二级路由最终得到显示左侧的路由表调用函数获取最终的动态路由调用的方法把动态路由表依次添加到路由系统中访问可以渲染对应的组件使用动态路由表数据通过存入然后利用它响应式的特性渲染到左侧菜单中新增一个模块模块先以静态的路由表作为初始值在得到过滤之后的动态路由表之后和之前的静态做一个结合在组件中结合指令做使用中的数据做渲染解决切换用户有缓存的方案在用户退出登录时调用清空路由的方法手动把中的数据也清空用户信息也清空每一个独立的小功能封装成一个独立的小函数维护方便调用函数获取用户权限数据把后端的权限数组格式化成我们自己的俩个权限数据当前的权限数据为一级路由权限二级路由权限根据权限标识过滤路由表最终得到显示到左侧的路由表最终路由表动态添加当浏览器中访问路由的路径显示渲染出来对应的组件存入渲染左侧菜单按钮控制权限概念根据当前用户的权限数据控制按钮的显示和隐藏思路每一个需要做权限控制的按钮都有一个自己独有的标识如果标识可以在权限数据列表中找到则显示找不到就隐藏方案应用中可能会有很多按钮需要做权限控制所以方案一定是全局生效的我们提供俩种可选的方案全局指令方案和高阶组件方案微前端微前端是一种前端架构模式它将大型单体应用程序分解为小的松散耦合的部分每个部分都可以独立开发测试和部署使用乾坤方案进行改造基础运行原理监听路由变化实现一个注册子应用配置的方法匹配子应用实现路由的匹配加载子应用实现加载子应用渲染子应用实现子应用的渲染前端加载模型下载模型解析包拉取模型并渲染添加进入条大屏适配安装组件使用组件并制定高度开发中遇到的问题中使用样式无法生效解决页面访问问题当我们刷新页面发现这是因为我们采用了的模式地址的变化会引起服务器的刷新我们只需要在对所有的地址进行一下处理即可在中使用下载文档出现乱码使用打包项目导致图片无法显示文件路径错误配置问题配置文件中是否有正确的配置来处理图片文件在调用登录接口成功后会返回和当有效时间设置了个小时有效时间设置了天当失效后仍然有效此时可以通过来为续期所谓的续期就是调用后端提供的一个接口然后把发送给服务端服务端重新返回新的和判断当前的有没有失效可以根据接口返回的状态码进行判断当失效后会返回在响应拦截器中可以统一获取所有接口返回的状态码然后对其进行判断要想通过应用实例来读取必须提前读取本地存储的数据并存储到应用实例当中调用接口把发送给服务端换取新的和接口中所需要的接口需要通过自定义的头信息来传递实现组件自动按需加载和自动导入安装配置里的介绍组合库使用函数获取设备宽度动态设置滚动距离介绍文档是一个基于组合封装的库提供了一些网站开发常用的工具函数且得到的是响应式数据需求在宽度设备滚动宽度为在其他设备需要等比例设置滚动的宽度就可以适配应用小结如果遇见一些常见的需求可以先看看是否提供这样可以提高开发效率如果窗口尺寸滚动距离是否进入可视区倒计时等等极速问诊问诊室介绍什么是是一种网络通信协议和协议一样为什么需要因为协议有一个缺陷通信只能由客户端发起我们项目中使用来实现客户端代码它是基于的库问诊室使用目的掌握的基本使用什么是一个基于的客户端服务端的实时通信库使用它可以在后端提供一个即时通讯服务它也提供一个库在前端可以去链接后端的创建的服务总结它是一套基于前后端即时通讯解决方案如何使用大家可以体验下这个官方如何建立连接参数不传默认是当前服务域名开发中传入服务器地址参数配置参数根据需要再来介绍如何确定连接成功建立连接成功如何发送消息发送消息事件由后台约定可变消息内容如何接收消息接收消息事件由后台约定可变是服务器发送的消息如何关闭连接离开组件需要使用小结在前端使用的库需要知道哪些内容如何建立链接地址连接成功的事件如何发消息事件如何收消息事件如果关闭连接项目权限处理现在权限相关管理系统用的框架都是提供的模板框架比较常见权限控制常见分为三大块菜单权限控制按钮权限控制请求权限控制权限管理在后端中主要体现在对接口访问权限的控制在前端中主要体现在对菜单访问权限的控制按钮权限控制比较容易主要采取的方式是从后端返回按钮的权限标识然后在前端进行显隐操作权限控制主要是后端代码来控制前端只需要规范好格式即可剩下的菜单权限控制是相对复杂一些的需要在路由设计时就拆分成静态路由和动态路由静态路由所有用户都能访问到的路由不会动态变化的登录页首页动态路由动态控制的路由只有用户有这个权限才将这个路由添加给你审批页社保页权限管理页用户登录进入首页时需要立刻发送请求获取个人信息包含权限的标识利用权限信息的标识筛选出合适的动态路由通过路由的方法动态添加路由即可拿的是默认配置的项拿不到动态新增的不是响应式的为了能正确的显示菜单为了能够将来正确的获取到用户路由我们需要用管理路由数组利用中的动态渲染菜单如何处理打包出来的项目首屏加载过慢的问题应用单页应用程序所有的功能都在一个页面中如果第一次将所有的路由资源组件都加载了就会很慢加载过慢一次性加载了过多的资源一次性加载了过大的资源加载过多路由懒加载访问到路由再加载该路由相关的组件内容加载过大图片压缩文件压缩合并处理开启压缩等比如配置异步组件路由懒加载图片压缩使用格式的图片提升首页加载的速度加速配置加速加快资源的加载效率花钱开启压缩一般默认服务器开启的如果没开确实可能会很慢可以让后台开一下你在项目中遇到过什么技术难题问题考察解决问题的能力话术前端要学的东西确实很多但是并不夸张肯多花点时间沉淀一般都会有解决方案一般遇到难题这些前端所谓的难题一般都是一些没有做过没有尝试过得一些业务我们要时刻保持独立思考知道自己要做什么业务由此决定要学什么知识然后实现业务举一反三总结归纳比如如果之前没有做过国际化换肤没有做过支付权限控制没有做过即时通信导入导出就会觉得很难但其实真正上手花时间去学着做了也都能逐步思考解决相关页面这些其实也都还比如有时候复杂的或者困难的并不是技术层面的而是业务需求方面的需要进行大量树形结构的处理展示列表式数据时展示图表数据时筛选条件关联条件多了组件与组件的联动关系的控制也比较麻烦将联动的条件存然后进行分模块管理也是比较合适的选择组件封装组件结构掌握组件的基础使用抽取到组件作为通用组件组件封装实现按钮组单选框组件支付抽屉组件封装组件需要实现哪些功能展示微信支付和支付宝支付可以选择展示支付金额传入订单用于生成订单支付链接打开关闭抽屉关闭后的业务可自定义需要暴露哪些参数需要提供哪些事件将树形的操作内容单独抽提成组件目标将树形的操作内容单独抽提成组件封装单独的树操作栏组件通过第一个章节我们发现树形的顶级内容实际和子节点的内容是一致的此时可以将该部分抽提成一个组件节省代码封装一个通用的工具栏目标封装一个通用的工具栏供大家使用新增员工的弹层组件个人详情组件和岗位详情组件封装封装上传图片组件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-29 00:10:49',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/cursur.css"><link rel="stylesheet" href="/css/fenleiye.css"><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://wudl.cn" title="主页"><img class="back-menu-item-icon" src="/img/48.png" alt="主页"/><span class="back-menu-item-text">主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.wudl.cn" title="博客"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://ccv-engineer.gitee.io/" title="旧站"><img class="back-menu-item-icon" src="/img/32.png" alt="旧站"/><span class="back-menu-item-text">旧站</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://7bu.top/" title="图床"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">kilito</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tag faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://chatgpt.wudl.cn"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> ChatGPT</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://gpt.zhizhubao.com/chat"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 私人助理</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=891137324&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/kongtiao/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zaobao/"><span> 早报</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Generato/" style="font-size: 1.05rem;">Generato<sup>1</sup></a><a href="/tags/fetch/" style="font-size: 1.05rem;">fetch<sup>1</sup></a><a href="/tags/koa/" style="font-size: 1.05rem;">koa<sup>1</sup></a><a href="/tags/this/" style="font-size: 1.05rem;">this<sup>1</sup></a><a href="/tags/vue%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">vue原理<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99/" style="font-size: 1.05rem;">手写<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99Promise/" style="font-size: 1.05rem;">手写Promise<sup>1</sup></a><a href="/tags/%E6%99%BA%E6%85%A7%E5%9B%AD%E5%8C%BA/" style="font-size: 1.05rem;">智慧园区<sup>1</sup></a><a href="/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/" style="font-size: 1.05rem;">柯里化<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>1</sup></a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 1.05rem;">继承<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url">面试</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">sxms</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-13T06:43:53.500Z" title="发表于 2023-10-13 14:43:53">2023-10-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-28T16:10:49.617Z" title="更新于 2023-10-29 00:10:49">2023-10-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">23.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>77分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为安徽"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>安徽</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://ekilito.github.io/posts/3936.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url">面试</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">sxms</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">kilito</span><time itemprop="dateCreated datePublished" datetime="2023-10-13T06:43:53.500Z" title="发表于 2023-10-13 14:43:53">2023-10-13</time><time itemprop="dateCreated datePublished" datetime="2023-10-28T16:10:49.617Z" title="更新于 2023-10-29 00:10:49">2023-10-29</time></header><h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="1-h5的新特性？css3的新特性？"><a href="#1-h5的新特性？css3的新特性？" class="headerlink" title="1.h5的新特性？css3的新特性？"></a>1.h5的新特性？css3的新特性？</h2><p><strong>H5新特性</strong></p>
<ol>
<li>拖拽释放api</li>
<li>自定义属性data-id</li>
<li>语义化标签</li>
<li>audio、video</li>
<li>canvas</li>
<li>地理api</li>
<li>localStorage、sessionStorage</li>
<li>表单控件</li>
<li>webworker、websocket</li>
</ol>
<p><strong>css3新特性</strong></p>
<ol>
<li>rgba</li>
<li>border-radius</li>
<li>盒子模型</li>
<li>线性渐变</li>
<li>过渡</li>
<li>动画</li>
<li>flex</li>
<li>字体图标</li>
</ol>
<h2 id="2-盒子水平垂直居中"><a href="#2-盒子水平垂直居中" class="headerlink" title="2.盒子水平垂直居中"></a>2.盒子水平垂直居中</h2><ol>
<li>绝对定位 + transform：translate（-50%，-50%）</li>
<li>flex布局</li>
</ol>
<h2 id="3-css选择器优先级"><a href="#3-css选择器优先级" class="headerlink" title="3.css选择器优先级"></a>3.css选择器优先级</h2><p>！Important&gt;行内样式&gt;ID 选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性</p>
<h2 id="4-rem的理解"><a href="#4-rem的理解" class="headerlink" title="4.rem的理解"></a>4.rem的理解</h2><p>rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。</p>
<p>手淘方案：</p>
<ol>
<li>拿到设计稿除以 10，得到 font-size 基准值</li>
<li>引入 flexible</li>
<li>设计稿 px&#x2F; font-size 基准值，即可换算为 rem</li>
</ol>
<h2 id="5-position"><a href="#5-position" class="headerlink" title="5.position"></a>5.position</h2><ol>
<li>static 静态定位（默认值）：不脱离文档流</li>
<li>absolute 绝对定位 ：找最近一级带有定位的父级元素进行移动 脱离文档流</li>
<li>relative 相对定位 </li>
<li>fixed 固定定位 脱离文档流 参照物浏览器窗口</li>
<li>sticky 粘性定位</li>
</ol>
<h2 id="6-浮动-float"><a href="#6-浮动-float" class="headerlink" title="6.浮动 float"></a>6.浮动 float</h2><p>浮动将元素排除在普通流之外，即元素将脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留。</p>
<p>1、子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素；</p>
<p>2、与浮动元素同级的非浮动元素（内联元素）会跟随其后；</p>
<p>3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法</p>
<p>清除浮动</p>
<ol>
<li>额外标签法  clear：both</li>
<li>双伪元素清除法</li>
<li>单伪元素清除法</li>
<li>构建BFC  为父元素添加 <code>overflow: hidden</code>   溢出隐藏</li>
<li>定高法</li>
</ol>
<h2 id="7-伪类和伪元素"><a href="#7-伪类和伪元素" class="headerlink" title="7. 伪类和伪元素"></a>7. 伪类和伪元素</h2><p>伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的;	:hover</p>
<p>伪元素：用于创建一些不在DOM树中的元素，并为其添加样式 ;	例如，我们可以通过  :before  :after</p>
<h2 id="8-css预处理器"><a href="#8-css预处理器" class="headerlink" title="8.css预处理器"></a>8.css预处理器</h2><p>Less、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率</p>
<h2 id="9-vw适配"><a href="#9-vw适配" class="headerlink" title="9.vw适配"></a>9.vw适配</h2><ul>
<li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li>
<li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100&#x2F;750)*32 vw</li>
<li>对于需要等比缩放的元素，CSS使用转换后的单位</li>
<li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li>
</ul>
<h2 id="10-如何解决-margin“塌陷”？"><a href="#10-如何解决-margin“塌陷”？" class="headerlink" title="10.如何解决 margin“塌陷”？"></a><strong>10.如何解决 margin“塌陷”？</strong></h2><p><strong>外边距塌陷共有两种情况：</strong></p>
<p>第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同时出现</p>
<p>第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。</p>
<p><strong>解决方案：</strong></p>
<p>1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成透明：border：1px solid transparent）；</p>
<p>2、为父盒子添加 overflow：hidden；</p>
<p>3、为父盒子设定 padding 值；</p>
<p>4、为父盒子添加 position：fixed；</p>
<p>5、为父盒子添加 display：table；</p>
<h2 id="11-通过-CSS-的哪些方式可以实现隐藏页面上的元素？"><a href="#11-通过-CSS-的哪些方式可以实现隐藏页面上的元素？" class="headerlink" title="11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？"></a>11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>opacity: 0</td>
<td>通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互</td>
</tr>
<tr>
<td>visibility: hidden</td>
<td>与透明度为0的方案非常类似，会占据空间，但不可以进行交互</td>
</tr>
<tr>
<td>overflow: hidden</td>
<td>只会隐藏元素溢出的部分；占据空间且不可交互</td>
</tr>
<tr>
<td>display: none</td>
<td>可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局</td>
</tr>
<tr>
<td>z-index: -9999</td>
<td>通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果</td>
</tr>
<tr>
<td>transform: scale(0,0)</td>
<td>通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互,只是一个视觉效果，不会影响其它盒子的布局。</td>
</tr>
<tr>
<td>left: -9999px</td>
<td>通过将元素定位到屏幕外面，达到看起来看不到的效果</td>
</tr>
</tbody></table>
<h2 id="12-如何理解-z-index？"><a href="#12-如何理解-z-index？" class="headerlink" title="12. 如何理解 z-index？"></a>12. 如何理解 z-index？</h2><p>可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。</p>
<p>元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。</p>
<p><code>z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级，当前盒子的z-index层级只是在父元素里面的层级</code></p>
<h2 id="13-谈谈你对-flex-的理解？"><a href="#13-谈谈你对-flex-的理解？" class="headerlink" title="13. 谈谈你对 flex 的理解？"></a>13. 谈谈你对 flex 的理解？</h2><p>在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。</p>
<p>flex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。 </p>
<p>你能联想到的flex语法有哪些呢?</p>
<p><code>flex-direction</code>: 调整主轴方向</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row：主轴方向为水平向右</span><br><span class="line">column：主轴方向为竖直向下</span><br><span class="line">row-reverse:主轴方向为水平向左</span><br><span class="line">column-reverse:主轴方向是竖直向上。</span><br></pre></td></tr></table></figure>

<p><code>justify-content</code>主要用来设置<strong>主轴方向的对齐方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start: 弹性盒子元素将向起始位置对齐</span><br><span class="line">flex-end: 弹性盒子元素将向结束位置对齐。</span><br><span class="line">center: 弹性盒子元素将向行中间位置对齐</span><br><span class="line">space-around: 弹性盒子元素会平均地分布在行里</span><br><span class="line">space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。</span><br></pre></td></tr></table></figure>

<p><code>align-items</code>用于调整<strong>侧轴的对齐方式</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex-start： 元素在侧轴的起始位置对齐。 </span><br><span class="line">flex-end： 元素在侧轴的结束位置对齐。</span><br><span class="line">center： 元素在侧轴上居中对齐。</span><br><span class="line">stretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。</span><br></pre></td></tr></table></figure>

<p><code>flex-wrap</code>属性控制flex容器是单行或者多行,默认不换行</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。</span><br><span class="line">wrap： 当宽度不够的时候，会换行。</span><br></pre></td></tr></table></figure>

<p><code>align-content</code>用来设置多行的flex容器的排列方式</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-start： 各行向侧轴的起始位置堆叠。 </span><br><span class="line">flex-end： 各行向弹性盒容器的结束位置堆叠。</span><br><span class="line">center： 各行向弹性盒容器的中间位置堆叠。</span><br><span class="line">space-around： 各行在侧轴中平均分布。 </span><br><span class="line">space-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 </span><br><span class="line">stretch：拉伸，不设置高度的情况下。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可参考 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex布局教程</a></p>
</blockquote>
<hr>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-let-var-const的区别？"><a href="#1-let-var-const的区别？" class="headerlink" title="1. let var const的区别？"></a>1. let var const的区别？</h2><p><strong>var ES5变量声明方式</strong></p>
<ol>
<li>在变量未赋值时，变量undefined（为使用声明变量时也为undefined）</li>
<li>作用域 var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</li>
</ol>
<p><strong>let ES6变量声明方式</strong></p>
<ol>
<li>在变量为声明前直接使用会报错</li>
<li>作用域   let为块级作用域   通常let比var范围要小</li>
<li>let禁止 重复声明变量，否则会报错；var可以重复声明</li>
</ol>
<p><strong>const ES6变量声明</strong></p>
<ol>
<li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值</li>
<li>const实际上保证的，并不是变量的值不得改动，而时变量指向的哪个内存地址不得改动</li>
</ol>
<h2 id="2-js数据类型，区别"><a href="#2-js数据类型，区别" class="headerlink" title="2. js数据类型，区别"></a>2. js数据类型，区别</h2><p><strong>基本数据类型：</strong></p>
<p>number，string，boolean，null，undefined，symbol，bigint</p>
<p><strong>引用数据类型：</strong></p>
<p>object，function</p>
<p>object：普通对象，数组对象，正则对象，日期对象，math数学函数对象。</p>
<p>(NaN 是一个数值类型，但不是一个具体的数字。)</p>
<h2 id="3-slice-是干嘛的、splice是否会改变原数组？"><a href="#3-slice-是干嘛的、splice是否会改变原数组？" class="headerlink" title="3.slice 是干嘛的、splice是否会改变原数组？"></a>3.slice 是干嘛的、splice是否会改变原数组？</h2><ol>
<li><p>slice 是来截取的  参数可以写 slice(3)、slice(-3)、slice(1,3) 返回的是一个新的数组</p>
</li>
<li><p>splice 功能有：插入、删除、替换</p>
<p>返回：删除的值</p>
<p>该方法会改变原数组</p>
</li>
</ol>
<h2 id="4-数组去重"><a href="#4-数组去重" class="headerlink" title="4.数组去重"></a>4.数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br></pre></td></tr></table></figure>



<h2 id="5-Javascript-创建对象的几种方式？"><a href="#5-Javascript-创建对象的几种方式？" class="headerlink" title="5. Javascript 创建对象的几种方式？"></a>5. <strong>Javascript 创建对象的几种方式？</strong></h2><ol>
<li>简单对象的创建 使用对象字面量的方式{}</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Cat</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>new 一个function</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personOne=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用工厂方式来创建（Object 关键字）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wcDog =<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 Object.create() 创建对象（使用现有对象作为原型）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(anotherPerson);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="6-如何区分数组和对象？"><a href="#6-如何区分数组和对象？" class="headerlink" title="6. 如何区分数组和对象？"></a>6. 如何区分数组和对象？</h2><ol>
<li>通过 ES6 中的 Array.isArray</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 instanceof 来识别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过调用 constructor 来识别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.<span class="property">constructor</span> <span class="comment">//返回 object</span></span><br><span class="line">[].<span class="property">constructor</span> <span class="comment">//返回 Array</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 Object.prototype.toString.call 方法来识别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">//[&quot;object Array&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">//[&quot;object Object&quot;]</span></span><br></pre></td></tr></table></figure>



<h2 id="7-作用域和作用域链"><a href="#7-作用域和作用域链" class="headerlink" title="7. 作用域和作用域链"></a>7. 作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离<br>变量，不同作用域下同名变量不会有冲突。</p>
<p>全局作用域 和 局部作用域（分为 函数作用域 和 块级作用域）</p>
<ol>
<li>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。</li>
<li>ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现</li>
</ol>
<p><strong>什么是作用域链？</strong></p>
<p>作用域本质上是底层的变量查找机制。</p>
<p>在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。</p>
<p>总结：</p>
<ol>
<li>嵌套关系的作用域串联起来形成了作用域链</li>
<li>相同作用域链中按着从小到大的规则查找变量</li>
<li>子作用域能够访问父级作用域，父级作用域无法访问子级作用域</li>
</ol>
<ul>
<li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链</p>
</li>
<li><p>由子级作用域返回父级作用域中寻找变量，就叫做作用域链</p>
</li>
<li><p>作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自中的最后一个对象</p>
</li>
<li><p>作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象</p>
</li>
</ul>
<p><strong>如何延长作用域链？</strong></p>
<p>执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除具体来说就是执行这两个语句时，作用域链都会得到加强</p>
<ol>
<li><p>try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明</p>
</li>
<li><p>with 语句。with 语句会将指定的对象添加到作用域链中</p>
</li>
</ol>
<h2 id="8-map-和-forEach-的区别？"><a href="#8-map-和-forEach-的区别？" class="headerlink" title="8. map 和 forEach 的区别？"></a>8. map 和 forEach 的区别？</h2><p><strong>相同点：</strong></p>
<ol>
<li>都是循环遍历数组中的每一项</li>
<li>每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），<br>arr（原数组）</li>
<li>匿名函数中的this都是指向window</li>
<li>只能遍历数组</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</li>
<li>forEach()允许callback更改原始数组的元素。map()返回新的数组。</li>
</ol>
<h2 id="9-js遍历对象的方法？"><a href="#9-js遍历对象的方法？" class="headerlink" title="9. js遍历对象的方法？"></a>9. js遍历对象的方法？</h2><ol>
<li><code>for...in</code> 循环</li>
<li><code>Object.keys()</code> 方法   获取对象中所有的键  对应 object.value</li>
<li><code>Object.entries()</code> 方法</li>
</ol>
<h2 id="10-new操作符具体干了什么呢"><a href="#10-new操作符具体干了什么呢" class="headerlink" title="10. new操作符具体干了什么呢?"></a>10. new操作符具体干了什么呢?</h2><ol>
<li>创建新对象</li>
<li>构造函数this指向新对象</li>
<li>执行构造函数代码，修改this，添加新的属性</li>
<li>返回新对象</li>
</ol>
<h2 id="11-类数组转换为数组"><a href="#11-类数组转换为数组" class="headerlink" title="11.类数组转换为数组"></a>11.类数组转换为数组</h2><ul>
<li>使用 Array.from()</li>
<li>使用 Array.prototype.slice.call()</li>
<li>使用 Array.prototype.forEach() 进行属性遍历并组成新的数组</li>
</ul>
<h2 id="12-简单说说-js-中有哪几种内存泄露的情况"><a href="#12-简单说说-js-中有哪几种内存泄露的情况" class="headerlink" title="12.简单说说 js 中有哪几种内存泄露的情况"></a>12.简单说说 js 中有哪几种内存泄露的情况</h2><ol>
<li>意外的全局变量；</li>
<li>闭包；</li>
<li>未被清空的定时器；</li>
<li>未被销毁的事件监听；</li>
<li>DOM 引用；</li>
</ol>
<h2 id="13-promise和-async-await-区别"><a href="#13-promise和-async-await-区别" class="headerlink" title="13. promise和 async await 区别?"></a>13. promise和 async await 区别?</h2><p><strong>概念</strong><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强<br>大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而<br>这些结果一旦生成是无法改变的<br>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执<br>行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象<br><strong>两者的区别</strong></p>
<ol>
<li>Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向<br>发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async<br>await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同<br>于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li>
<li>async await与Promise一样，是非阻塞的。</li>
<li>async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函<br>数。</li>
</ol>
<h2 id="14-defer和async区别"><a href="#14-defer和async区别" class="headerlink" title="14. defer和async区别?"></a>14. defer和async区别?</h2><ul>
<li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。多个defer脚本会按照它们在页面出现的顺序加载。&#x3D;&#x3D;“渲染完再执行”&#x3D;&#x3D;</li>
<li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本是不能保证加载顺序的。&#x3D;&#x3D;“下载完就执行”&#x3D;&#x3D;</li>
</ul>
<p><strong>延迟加载有哪些js方式？</strong></p>
<ol>
<li><strong>defer</strong> : 等 html 全部解析完成，才会执行 js 代码，顺次执行 js 代码。</li>
<li><strong>async</strong>：async 和 html 解析是同步的（一起的），不是顺次执行 js 脚本（谁先加载完谁先执行）</li>
</ol>
<h2 id="15-同步和异步"><a href="#15-同步和异步" class="headerlink" title="15. 同步和异步"></a>15. 同步和异步</h2><p><strong>同步</strong></p>
<ul>
<li>指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。</li>
<li>也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序<br>和任务排列顺序是一致的。</li>
</ul>
<p><strong>异步</strong></p>
<ul>
<li>异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</li>
<li>每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。</li>
<li>程序的执行顺序和任务的排列顺序是不一致的，异步的。</li>
<li>我们常用的setTimeout和setInterval函数，Ajax都是异步操作。</li>
</ul>
<h2 id="16-null-和-undefined-的区别"><a href="#16-null-和-undefined-的区别" class="headerlink" title="16. null 和 undefined 的区别"></a>16. null 和 undefined 的区别</h2><p><strong>undefined</strong></p>
<ol>
<li>声明了一个变量，但没有赋值</li>
<li>访问对象上不存在的属性</li>
<li>函数定义了形参，但没有传递实参</li>
<li>使用 void 对表达式求值</li>
</ol>
<p><strong>null</strong></p>
<p>看过作者文献：最初设计js的时候借助了java的语言。</p>
<p>null 会被隐式的转换为 0，很不容易发现错误。</p>
<p>先有null 后有 undefined 是为了填补之前的坑。</p>
<p>具体区别：js 的最初版本是这样区分的，null 是一个表示 “无” 的对象，转为数值时为 0 值，转为数值才为 NaN。</p>
<ol>
<li>null是一个空值，表示无的对象</li>
<li>null 有属于自己的类型 Null，而不属于Object类型</li>
<li>二进制的前三位为 0 会被 typeof 判断为对象类型</li>
</ol>
<h2 id="17-call-appy-bind的作用和区别？"><a href="#17-call-appy-bind的作用和区别？" class="headerlink" title="17. call appy bind的作用和区别？"></a>17. call appy bind的作用和区别？</h2><p><strong>作用：</strong></p>
<p>都可以改变函数内部的this指向</p>
<p><strong>区别点：</strong></p>
<ol>
<li>call 和 apply 会调用函数，并且改变函数内部this指向。</li>
<li>call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg]</li>
<li>bind 不会调用函数，可以改变函数内部this指向</li>
</ol>
<p>应用场景</p>
<ol>
<li>object.prototype.toString.call()  检测数据类型</li>
<li>apply 经常和数组有关系，比如借助于数学对象实现数组的最大值最小值</li>
<li>比如改变定时器内部 的this 指向</li>
</ol>
<h2 id="18-this指向（普通函数、箭头函数）"><a href="#18-this指向（普通函数、箭头函数）" class="headerlink" title="18. this指向（普通函数、箭头函数）"></a>18. this指向（普通函数、箭头函数）</h2><ol>
<li>谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁</li>
<li>匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象</li>
</ol>
<p><strong>箭头函数中的this</strong></p>
<ul>
<li>箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的</li>
<li>箭头函数中的this指向父级作用域的执行上下文；</li>
<li>箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来</li>
</ul>
<h2 id="19-继承"><a href="#19-继承" class="headerlink" title="19. 继承"></a>19. 继承</h2><p>继承一些属性构造的过程和方法</p>
<p><strong>继承的好处</strong></p>
<p>a：提高了代码的复用性</p>
<p>b：提高了代码的维护性</p>
<p>c：让类与类之间产生了关系，是多态的前提</p>
<p><strong>继承的弊端</strong></p>
<p>类的耦合性增强了,但是开发的原则：高内聚，低耦合</p>
<ol>
<li>构造函数继承</li>
<li>原型链继承</li>
<li>原型式继承</li>
<li>组合继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
<li>class extends 继承</li>
</ol>
<h2 id="20-promise"><a href="#20-promise" class="headerlink" title="20. promise"></a>20. promise</h2><p>promise的设计之初就是为了解决回调地狱的问题的。</p>
<p>本意是承诺，<strong>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了</strong></p>
<p><strong>Promise的三种状态</strong></p>
<ul>
<li><p>Pending—-Promise对象实例创建时候的初始状态</p>
</li>
<li><p>Fulfilled—-可以理解为成功的状态</p>
</li>
<li><p>Rejected—-可以理解为失败的状态</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)<span class="comment">//无效代码不会执行</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(reason)<span class="comment">//reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>promise的链式调用</p>
<p>如果上一个.then中返回一个新的promise对象，则可以交给下一个.then继续处理。</p>
<ul>
<li>每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)</li>
<li>如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调</li>
<li>如果then中出现异常,会走下一个then的失败回调</li>
<li>在 then中使用了return，那么 return 的值会被Promise.resolve() 包装</li>
<li>then中可以不传递参数，如果不传递会透到下一个then中</li>
<li>catch 会捕获到没有捕获的异常</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">//包装成 Promise.resolve(2)</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="number">3</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="title function_">ajax</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">ajax</span>(url1)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">ajax</span>(url2)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>

<p>存在一个缺点：无法取消promise，错误需要通过回调函数捕获</p>
<p>场景：</p>
<ol>
<li>异步请求</li>
<li>定时器</li>
<li>并行异步操作  当需要同时进行多个异步操作，并在它们都完成后执行一些任务时，可以使用 Promise.all 方法。</li>
</ol>
<p><strong>promise静态常用的方法</strong></p>
<ol>
<li>promise.all（[promise1,promise2…]）  等待机制  等待完才会走 .then</li>
<li>promise.race   赛跑机制</li>
</ol>
<h2 id="21、JavaScript-内置的常用对象有哪些？"><a href="#21、JavaScript-内置的常用对象有哪些？" class="headerlink" title="21、JavaScript 内置的常用对象有哪些？"></a>21、JavaScript 内置的常用对象有哪些？</h2><p><strong>对象及方法</strong></p>
<p>Arguments 函数参数集合</p>
<p>Arguments[ ] 函数参数的数组</p>
<p>Arguments 一个函数的参数和其他属性</p>
<p>Arguments.callee 当前正在运行的函数</p>
<p>Arguments.length 传递给函数的参数的个数</p>
<p><strong>Array 数组</strong></p>
<p>length 属性 </p>
<p>join() 将一个数组转成字符串。返回一个字符串。</p>
<p>reverse() 将数组中各元素颠倒顺序</p>
<p>delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。</p>
<p>shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。</p>
<p>pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。</p>
<p>unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，“b，“c”)</p>
<p>push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，“c”)</p>
<p>concat( ) 连接数组</p>
<p>slice( ) 返回数组的一部分</p>
<p>sort( ) 对数组元素进行排序</p>
<p>splice( ) 插入、删除或替换数组的元素</p>
<p>toLocaleString( ) 把数组转换成局部字符串</p>
<p>toString( ) 将数组转换成一个字符串</p>
<p>forEach 遍历所有元素</p>
<p>every 判断所有元素是否都符合条件</p>
<p>sort 排序</p>
<p>map 对元素重新组装，生成新数组</p>
<p>filter 过滤符合条件的元素</p>
<p><strong>String 字符串对象</strong></p>
<p>Length 获取字符串的长度。</p>
<p>toUpperCase() 将字符串中的字母转成全大写。如：strObj.toUpperCase()</p>
<p>charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串</p>
<p>substr() 在原始字符串，返回一个子字符串</p>
<p>substring() 在原始字符串，返回一个子字符串</p>
<p>split() 将一个字符串转成数组</p>
<p>charCodeAt( ) 返回字符串中的第 n 个字符的代码</p>
<p>concat( ) 连接字符串</p>
<p>fromCharCode( ) 从字符编码创建—个字符串</p>
<p>indexOf( ) 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没有找到，则返回-1</p>
<p>lastIndexOf( ) 从后向前检索一个字符串</p>
<p>localeCompare( ) 用本地特定的顺序来比较两个字符串</p>
<p>match( ) 找到一个或多个正则表达式的匹配</p>
<p>replace( ) 替换一个与正则表达式匹配的子串</p>
<p>search( ) 检索与正则表达式相匹配的子串</p>
<p>slice( ) 抽取一个子串</p>
<p>toLocaleLowerCase( ) 把字符串转换小写</p>
<p>toLocaleUpperCase( ) 将字符串转换成大写</p>
<p>toLowerCase( ) 将字符串转换成小写</p>
<p>toString( ) 返回字符串</p>
<p>toUpperCase( ) 将字符串转换成大写</p>
<p>valueOf( )</p>
<h2 id="22-谈谈事件委托的理解？"><a href="#22-谈谈事件委托的理解？" class="headerlink" title="22.谈谈事件委托的理解？"></a>22.谈谈事件委托的理解？</h2><p>JavaScript 事件代理则是一种简单的技巧，把事件处理器添加到一个上级元素上，这样就避免了把事件处理器添加到多个子级元素上。这主要得益于浏览器的事件冒泡机制。</p>
<p><strong>优点：</strong></p>
<p>1、减少事件注册，节省内存。</p>
<p>2、在 table 上代理所有 td 的 click 事件。</p>
<p>3、在 ul 上代理所有 li 的 click 事件。</p>
<p>4、简化了 dom 节点更新时，相应事件的更新。</p>
<p>5、不用在新添加的 li 上绑定 click 事件。</p>
<p>6、当删除某个 li 时，不用移解绑上面的 click 事件。</p>
<p><strong>缺点：</strong></p>
<p>1、事件委托基于冒泡，对于不冒泡的事件不支持</p>
<p>2、层级过多，冒泡过程中，可能会被某层阻止掉。</p>
<p>3、理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在 table 上代理 td，而不是在 document 上代理 td。</p>
<p>4、把所有事件都用代理就可能会出现事件误判。比如，在 document 中代理了所有 button 的 click事件，另外的人在引用改 js 时，可能不知道，造成单击 button 触发了两个 click 事件</p>
<h2 id="23-什么是闭包？"><a href="#23-什么是闭包？" class="headerlink" title="23.什么是闭包？"></a>23.什么是闭包？</h2><p><strong>定义：</strong></p>
<p> 一个作用域可以访问到另外一个函数内部的局部变量，或者说一个函数（子函数）访问另一个函数（父函数）中的变量。此时就会产生闭包，那么这个变量所在的函数我们就称之为闭包函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(a++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fun = <span class="title function_">aaa</span>()</span><br><span class="line"><span class="title function_">fun</span>()              <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>优缺点：</strong></p>
<p>闭包的主要作用：延伸了变量的作用范围，因为闭包函数中的局变量不会等着闭包函数执行完就销毁，因为还有别的函数要调用它，只有等着所有的函数都调用完了它才会销毁。 <strong>实现数据的私有。</strong></p>
<p>闭包会造成内存泄露，如何解决：用完之后手动是释放。</p>
<p>优点:</p>
<p>1）可以减少全局变量的定义，避免全局变量的污染</p>
<p>2）能够读取函数内部的变量</p>
<p>3）在内存中维护⼀个变量，可以⽤做缓存</p>
<p>缺点:</p>
<p>1）造成内存泄露</p>
<p>2）闭包可能在⽗函数外部，改变⽗函数内部变量的值。</p>
<p>3）造成性能损失</p>
<p>使用场景：</p>
<ol>
<li>封装私有变量</li>
<li>闭包可以用于创建模块化的代码结构，避免全局变量的污染。</li>
<li>在处理用户输入或频繁触发的事件时，可以通过闭包来实现防抖（debounce）和节流（throttle）的效果。防抖和节流是优化性能和减少不必要请求的常见方法。</li>
<li>缓存数据：通过闭包，可以在函数内部缓存一些计算结果或其他重要数据，避免重复计算或请求。</li>
</ol>
<h2 id="24-for-in-和-for-of-的区别"><a href="#24-for-in-和-for-of-的区别" class="headerlink" title="24.for in 和 for of 的区别"></a>24.for in 和 for of 的区别</h2><p>1、推荐在循环对象属性的时候使用 for…in，在遍历数组的时候的时候使用 for…of</p>
<p>2、for…in 循环出的是 key，for…of 循环出的是 value</p>
<p>3、注意，for…of 是 ES6 新引入的特性。修复了 ES5 引入的 for…in 的不足</p>
<p>4、for…of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</p>
<h2 id="25、split（）和-join（）的区别？"><a href="#25、split（）和-join（）的区别？" class="headerlink" title="25、split（）和 join（）的区别？"></a>25、split（）和 join（）的区别？</h2><p>split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里即切割成数组的形式；</p>
<p>join() 是把数组中的字符串连成一个长串，可以大体上认为是 split()的逆操作</p>
<h2 id="26-深拷贝"><a href="#26-深拷贝" class="headerlink" title="26.深拷贝"></a>26.深拷贝</h2><blockquote>
<p>首先浅拷贝和深拷贝只针对引用类型</p>
</blockquote>
<p><strong>浅拷⻉</strong>: 拷贝的是地址</p>
<p>拷贝对象</p>
<ol>
<li>object.assign() </li>
<li>展开运算符</li>
</ol>
<p>拷贝数组</p>
<ol>
<li>object.prototype.concat()</li>
</ol>
<p>如果是简单数据类型拷贝值，不会影响元对象，引用数据类型拷贝的是地址。</p>
<p><strong>深拷⻉</strong>: 拷贝的是对象，不是地址</p>
<ol>
<li>递归</li>
<li>JSON 对象中的 parse 和 stringify</li>
<li>lodash  里的 cloneDeep</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">⽬前实现深拷⻉的主要是利⽤ <span class="title class_">JSON</span> 对象中的 parse 和 stringify  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloneArray = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(originArray));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArray === originArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>用到？</p>
<ol>
<li>处理嵌套对象和数组：创建一个独立的副本。这样，对副本的修改不会影响原始数据。</li>
<li>操作不可变的数据</li>
<li>序列化和反序列化：当你需要将对象转换为字符串进行存储或传输时，深拷贝可以帮助你创建一个完整的副本，并且在后续需要时可以还原为原始对象。</li>
</ol>
<h2 id="27-原型链"><a href="#27-原型链" class="headerlink" title="27.原型链"></a>27.原型链</h2><p><strong>原型</strong></p>
<ol>
<li>构造函数通过原型分配的函数是所有对象所共享的</li>
<li>js 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象。</li>
<li>这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存。</li>
<li>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</li>
<li>构造函数和原型对象中的this 都指向实例化对象。</li>
</ol>
<p><strong>constructor属性</strong></p>
<p>每个原型对象里面都有个 constructor 属性，该属性指向该原型对象的构造函数。</p>
<p>使用场景：</p>
<p>如果有多个对象的方法，我们可以给原型对象采取 对象形式赋值。</p>
<p>但是这样就会覆盖构造函数原型对象原来的内容。</p>
<p>这样修改后的原型对象 constructor 就不再指向当前构造函数了。</p>
<p>此时，我们应该在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p>
<p><strong>对象原型 –proto–</strong></p>
<p>实例对象的原型，对象都有一个属性 –proto–，指向构造函数的 prototype 原型对象。</p>
<p>之所以我们对象可以使用构造函数prototype原型对象上的方法和属性，就是因为对象有–proto–原型的存在。</p>
<p><strong>原型链：</strong></p>
<p>所有的实例对象里面都有–proto–对象原型，指向原型对象</p>
<p>所有的原型对象里面有 constructor，指向创造该原型对象的构造函数</p>
<ol>
<li>当访问一个对象的属性和方法时，首先查找这个对象本身有没有该属性</li>
<li>如果没有就查找它的原型（也就是–proto–指向的prototype原型对象）</li>
<li>如果还没有就查找原型对象上的原型</li>
<li>依此类推，一直找到为止</li>
<li>–proto–对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li>
<li>可以使用 instanceof 运算符用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/10/29/653d326d4d351.png" alt="Snipaste_2023-10-29_00-09-55.png"></li>
</ol>
<h2 id="28-防抖和节流"><a href="#28-防抖和节流" class="headerlink" title="28.防抖和节流"></a>28.防抖和节流</h2><p>**防抖(debounce)**：触发⾼频事件后 n 秒内函数只会执⾏⼀次，如果 n 秒内⾼频事件再次被触发，则重新计算时间</p>
<p>使用场景：</p>
<ol>
<li>搜索框防抖</li>
<li>手机号、邮箱验证输入检测</li>
</ol>
<p><strong>手写防抖函数</strong>：</p>
<p>思路：防抖的核心就是利用 settimeout 实现的</p>
<ol>
<li>声明一个定时器变量</li>
<li>当鼠标每次滑动都先判断 是否有定时器了，如果有定时器先清除以前的定时器</li>
<li>如果没有定时器则开启定时器，记得存到变量里面</li>
<li>在定时器里面调用要执行的函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeId</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timeId) <span class="built_in">clearTimeout</span>(timeId)</span><br><span class="line">        timeId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">fn</span>() </span><br><span class="line">        &#125;,t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="title function_">debounce</span>(mouseMove,<span class="number">500</span>))</span><br></pre></td></tr></table></figure>



<p>**节流(throttle)**：⾼频事件触发，但在 n 秒内只会执⾏⼀次，所以节流会稀释函数的执⾏频率</p>
<p>使用场景：</p>
<ol>
<li>小米轮播图切换点击效果</li>
<li>页面尺寸缩放resize</li>
<li>滚动条滚动</li>
</ol>
<p><strong>手写节流函数</strong></p>
<p>思路：一样</p>
<ol>
<li>声明一个定时器变量</li>
<li>当鼠标每次滑动都先判断 是否有定时器了，如果有定时器，则不开启新定时器</li>
<li>如果没有定时器则开启定时器，记得存到变量里面</li>
<li>定时器里面调用执行的函数</li>
<li>清空定时器</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!timeId) &#123;</span><br><span class="line">            timeId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">               <span class="title function_">fn</span>()</span><br><span class="line">                timeId = <span class="literal">null</span></span><br><span class="line">            &#125;,t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="title function_">throttle</span>(mouseMove,<span class="number">500</span>))</span><br></pre></td></tr></table></figure>



<p>区别：防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏变成每隔⼀段时间执⾏。</p>
<h2 id="29-ES6"><a href="#29-ES6" class="headerlink" title="29.ES6"></a>29.ES6</h2><ol>
<li>let  const</li>
<li>模板字符串</li>
<li>箭头函数</li>
<li>object.keys() 遍历对象的键</li>
<li>object.assign() 合并对象 常用于对象拷贝</li>
<li>for of</li>
<li>import（用于在一个模块中加载另一个含有 export 接口的模块）  export（用于对外输出本模块）</li>
<li>promise</li>
<li>set</li>
<li>class</li>
</ol>
<h2 id="30-介绍下-Set、Map-的区别"><a href="#30-介绍下-Set、Map-的区别" class="headerlink" title="30.介绍下 Set、Map 的区别"></a>30.介绍下 Set、Map 的区别</h2><p><strong>区别</strong></p>
<p>应用场景 Set 用于数据重组，Map 用于数据储存</p>
<p>Set：</p>
<p>成员不能重复</p>
<p>只有键值没有键名，类似数组</p>
<p>可以遍历，方法有 add, delete,has</p>
<p>Map: </p>
<p>本质上是健值对的集合，类似集合</p>
<p>可以遍历，可以跟各种数据格式转换</p>
<h2 id="31-async-await"><a href="#31-async-await" class="headerlink" title="31.async await"></a>31.async await</h2><ol>
<li>async 用于修饰一个函数，表示一个函数是异步的</li>
<li>await 要用在 async 函数中</li>
<li>await 后面一般会跟一个 promise 对象</li>
<li>await 只会等待 promise 成功的结果</li>
</ol>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="1-cookie-sessionStorage-localStorage区别"><a href="#1-cookie-sessionStorage-localStorage区别" class="headerlink" title="1.cookie sessionStorage localStorage区别"></a>1.cookie sessionStorage localStorage区别</h2><p><strong>共同点：</strong></p>
<p>都是保存在浏览器端、且同源的</p>
<p><strong>区别：</strong></p>
<ol>
<li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p>
</li>
<li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 </p>
</li>
<li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 </p>
</li>
<li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </p>
</li>
<li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p>
</li>
<li><p>Storage的api接口使用更方便</p>
</li>
</ol>
<h2 id="2-浏览器输入URL发生了什么"><a href="#2-浏览器输入URL发生了什么" class="headerlink" title="2. 浏览器输入URL发生了什么"></a>2. 浏览器输入URL发生了什么</h2><ol>
<li>URL 解析</li>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面</li>
</ol>
<h2 id="3-浏览器是如何渲染页面的？"><a href="#3-浏览器是如何渲染页面的？" class="headerlink" title="3. 浏览器是如何渲染页面的？"></a>3. 浏览器是如何渲染页面的？</h2><p>不同浏览器内核渲染机制有所区别</p>
<ol>
<li>HTML 被 HTML 解析器解析成 DOM 树；</li>
<li>CSS 被 CSS 解析器解析成 CSSOM 树；</li>
<li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li>
<li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li>
<li>将布局绘制(paint)在屏幕上，显示出整个页面。</li>
</ol>
<h2 id="4-重绘、重排"><a href="#4-重绘、重排" class="headerlink" title="4. 重绘、重排"></a>4. 重绘、重排</h2><p><strong>概念</strong></p>
<ol>
<li>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树</li>
<li>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</li>
</ol>
<p><strong>区别：</strong></p>
<p>重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p>
<p><strong>引发重排</strong></p>
<ol>
<li>添加、删除可见的dom</li>
<li>元素的位置改变</li>
<li>元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</li>
<li>页面渲染初始化</li>
<li>浏览器窗口尺寸改变</li>
<li>获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存</li>
</ol>
<p><strong>优化方案</strong></p>
<p>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p>
<p>减少 reflow&#x2F;repaint：</p>
<ol>
<li><p>不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的className。</p>
</li>
<li><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。</p>
</li>
<li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会reflow 的。</p>
</li>
<li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)</p>
</li>
<li><p>不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</p>
</li>
</ol>
<h2 id="5-事件循环（Event-loop）"><a href="#5-事件循环（Event-loop）" class="headerlink" title="5. 事件循环（Event loop）"></a>5. 事件循环（Event loop）</h2><p>js 是一门单线程执行的语言。也就是说，同一时间只能做一件事情。</p>
<p>为了防止某个耗时任务导致程序假死的问题，异步代码由js 委托给宿主环境（浏览器、node环境）等待执行。</p>
<p><strong>JavaScript 的事件分两种</strong></p>
<ol>
<li>宏任务：包括整体代码 script，setTimeout，setInterval</li>
<li>微任务：Promise.then(非 new Promise是同步的)，catch、process.nextTick(node 中)</li>
</ol>
<p><strong>具体执行：</strong></p>
<p>事件的执行顺序——先执行宏任务，然后执行微任务，任务有同步的任务和异步的任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放在队列中，如果还有异步的宏任务，那么就会进行循环执行上述的操作</p>
<p>主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行</p>
<p><strong>详细步骤</strong>：</p>
<ol>
<li><p>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</p>
</li>
<li><p>将事件循环的当前运行宏任务设置为已选择的宏任务。</p>
</li>
<li><p>运行宏任务。</p>
</li>
<li><p>将事件循环的当前运行任务设置为null。</p>
</li>
<li><p>将运行完的宏任务从宏任务队列中移除。</p>
</li>
<li><p>microtasks步骤：进入microtask检查点。</p>
</li>
<li><p>更新界面渲染。</p>
</li>
<li><p>返回第一步。</p>
</li>
</ol>
<h2 id="6-跨域"><a href="#6-跨域" class="headerlink" title="6. 跨域"></a>6. 跨域</h2><p><strong>跨域是什么？</strong></p>
<p>跨域（Cross-Origin）指的是在浏览器中，当一个请求的源（Origin）与目标资源的源不一致时，即发生跨域访问。在默认情况下，浏览器的同源策略（Same-Origin Policy）会阻止这种跨域访问。同源策略是为了保护用户的信息安全，防止恶意网站对其他网站的资源进行访问和操作。</p>
<p><strong>同源策略规定几个约束</strong></p>
<ol>
<li>协议相同</li>
<li>域名相同</li>
<li>端口号相同</li>
</ol>
<p><strong>同源策略限制内容有</strong></p>
<ul>
<li>cookie、localstorage、indexedDB 等</li>
<li>dom节点</li>
<li>ajax 请求</li>
</ul>
<p><strong>跨域解决⽅法：</strong></p>
<p>1、jsonp⽅式</p>
<p>2、代理服务器的⽅式</p>
<p>3、服务端允许跨域访问(CORS)</p>
<p>4、取消浏览器的跨域限制</p>
<h2 id="7-常见code码"><a href="#7-常见code码" class="headerlink" title="7.常见code码"></a>7.常见code码</h2><p>200 - 请求成功</p>
<p>301 - 资源（⽹⻚等）被永久转移到其它URL</p>
<p>403 - Forbidden 服务器理解请求客户端的请求，但是拒绝执⾏此请求</p>
<p>404 - 请求的资源（⽹⻚等）不存在</p>
<p>500 - 内部服务器错误</p>
<p>502 - Bad Gateway 作为⽹关或者代理⼯作的服务器尝试执⾏请求时，从远程服务器接收到了⼀个⽆效的响应</p>
<h2 id="8-http-和-https-的区别"><a href="#8-http-和-https-的区别" class="headerlink" title="8. http 和 https 的区别"></a>8. http 和 https 的区别</h2><ol>
<li><p>HTTP 明⽂传输，数据都是未加密的，安全性较差，HTTPS 数据传输过程是加密的，安全性较好。</p>
</li>
<li><p>使⽤ HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，⼀般免费证书较少，因⽽需要⼀定费⽤</p>
</li>
<li><p>HTTP ⻚⾯响应速度⽐ HTTPS 快，主要是因为 HTTP 使⽤ TCP 三次握⼿建⽴连接，客户端和服务器需要交换 3 个包，⽽ HTTPS除了 TCP 的三个包，还要加上 ssl 握⼿需要的 9 个包，所以⼀共是 12 个包。</p>
</li>
<li><p>HTTP 和 HTTPS 使⽤的是完全不同的连接⽅式，⽤的端⼝也不⼀样，前者是 80，后者是 443。</p>
</li>
<li><p>HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要⽐较 HTTPS ⽐ HTTP 要更耗费服务器资源。</p>
</li>
</ol>
<h2 id="9-前端优化策略"><a href="#9-前端优化策略" class="headerlink" title="9. 前端优化策略"></a>9. 前端优化策略</h2><p>1、减少http请求数</p>
<p>2、将脚本往后挪，减少对并发下载的影响</p>
<p>3、避免频繁的DOM操作</p>
<p>4、压缩图⽚</p>
<p>5、gzip压缩优化，对传输资源进⾏体积压缩(html,js,css)</p>
<p>6、按需加载</p>
<p>7、组件化</p>
<p>8、减少不必要的Cookie（Cookie存储在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从⽽会影响加载速度，所以尽量减少不必要的Cookie。）</p>
<h2 id="10-介绍一下-websocket"><a href="#10-介绍一下-websocket" class="headerlink" title="10.介绍一下 websocket"></a>10.介绍一下 websocket</h2><p>websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通 信的协议，这个对比着 HTTP 协议来说，HTTP 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。HTTP 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信， 以 便 任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接， 就 可 以一直保持连接状态</p>
<h2 id="11-webpack"><a href="#11-webpack" class="headerlink" title="11.webpack"></a>11.webpack</h2><p>webpack 的作⽤就是处理依赖，模块化，打包压缩⽂件，管理插件。</p>
<p>1、webpack打包原理</p>
<p> 把所有依赖打包成⼀个 bundle.js ⽂件，通过代码分割成单元⽚段并按需加载。</p>
<p>2、webpack的优势</p>
<p>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的⽀持也很全⾯，⽅便</p>
<p>旧项⽬进⾏代码迁移。</p>
<p>（2）能被模块化的不仅仅是 JS 了。</p>
<p>（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的⼯作，⽐如打包、压缩混淆、图⽚转base64等。</p>
<p>（4）扩展性强，插件机制完善</p>
<h2 id="12-Get-和-Post-的区别以及使用场景"><a href="#12-Get-和-Post-的区别以及使用场景" class="headerlink" title="12.Get 和 Post 的区别以及使用场景"></a><strong>12.Get 和 Post 的区别以及使用场景</strong></h2><p><strong>区别</strong></p>
<p>1、Get 使用 URL 或 Cookie 传参。而 Post 将数据放在 body 中</p>
<p>2、Get 的 URL 会有长度上的限制，则 Post 的数据则可以非常大</p>
<p>3、Post 比 Get 安全，因为数据在地址栏上不可见</p>
<p><strong>最本质的区别</strong></p>
<p>基于 http 协议进行请求， 其实 GET 和 POST 无区别， 只是请求时的方式不同， 都可以携带请求体， 也可以在 URL 带参数区别来自于浏览器对 URL 长度的限制， 请求体大小来源于服务器的限制</p>
<p><strong>还有语义的区别：</strong></p>
<p>GET 是获取， POST 是提交</p>
<p>Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据</p>
<h2 id="13-HTTP有哪些⽅法？"><a href="#13-HTTP有哪些⽅法？" class="headerlink" title="13. HTTP有哪些⽅法？"></a>13. HTTP有哪些⽅法？</h2><p>HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD</p>
<p>HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT</p>
<h2 id="14-各个HTTP方法的具体作用是什么？"><a href="#14-各个HTTP方法的具体作用是什么？" class="headerlink" title="14. 各个HTTP方法的具体作用是什么？"></a>14. 各个HTTP方法的具体作用是什么？</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td>通常⽤于请求服务器发送某些资源</td>
</tr>
<tr>
<td align="center">POST</td>
<td>发送数据给服务器</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td>请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个<code>使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</code></td>
</tr>
<tr>
<td align="center">PUT</td>
<td>⽤于全量修改⽬标资源 (看接口, 也可以用于添加)</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td>⽤于删除指定的资源</td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td>⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全)</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td>该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户)</td>
</tr>
<tr>
<td align="center">PATCH</td>
<td>⽤于对资源进⾏部分修改</td>
</tr>
</tbody></table>
<p>GET POST PUT PATCH DELETE</p>
<p>GET&#x2F;DELETE  参数是在地址栏中传递的</p>
<p>PUT&#x2F;PATCH&#x2F;POST 参数是在请求体传递的</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-谈谈你对-Vue-生命周期的理解？"><a href="#1-谈谈你对-Vue-生命周期的理解？" class="headerlink" title="1.谈谈你对 Vue 生命周期的理解？"></a>1.谈谈你对 Vue 生命周期的理解？</h2><p><strong>（1）生命周期是什么？</strong></p>
<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期</p>
<p><strong>（2）各个生命周期的作用</strong></p>
<table>
<thead>
<tr>
<th align="left">beforeCreate</th>
<th align="left">组件实例被创建之初，组件的属性生效之前</th>
</tr>
</thead>
<tbody><tr>
<td align="left">created</td>
<td align="left">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td align="left">update</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td align="left">activited</td>
<td align="left">keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td align="left">deadctivated</td>
<td align="left">keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td align="left">beforeDestory</td>
<td align="left">组件销毁前调用</td>
</tr>
<tr>
<td align="left">destoryed</td>
<td align="left">组件销毁后调用</td>
</tr>
</tbody></table>
<h2 id="2-keep-alive"><a href="#2-keep-alive" class="headerlink" title="2. keep-alive"></a>2. keep-alive</h2><p><strong>1、什么是keep-alive？</strong></p>
<p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，⽽不是销毁它们。keep-alive 是⼀个抽象组件：它⾃身不会渲染成⼀个 DOM 元素，也不会出现在⽗组件链中</p>
<p><strong>2、keep-alive的优点</strong>？</p>
<p>在组件切换过程中 把切换出去的组件保留在内存中，防⽌重复渲染DOM，减少加载时间及性能消耗，提⾼⽤户体验性。</p>
<p><strong>3、keep-alive有三个属性</strong></p>
<p>include ： 只有匹配的组件会被缓存</p>
<p>exclude ： 任何匹配的组件都不会被缓存</p>
<p>max ： 最多可以缓存多少组件实例</p>
<p><strong>4、keep-alive的使⽤会触发两个⽣命周期函数？</strong></p>
<p>这两个函数分别是</p>
<p>activated 当组件被激活（使⽤）的时候触发 可以简单理解为进⼊这个⻚⾯的时候触发</p>
<p>deactivated 当组件不被使⽤的时候触发 可以简单理解为离开这个⻚⾯的时候触发</p>
<h2 id="3-数据双向绑定原理"><a href="#3-数据双向绑定原理" class="headerlink" title="3. 数据双向绑定原理"></a>3. 数据双向绑定原理</h2><p>数据变化更新视图</p>
<ul>
<li>输入框内容变化时，Data 中的数据同步变化。即 View &#x3D;&gt; Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即 Data &#x3D;&gt; View 的变化</li>
</ul>
<p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的⽅式来实现的.</p>
<p> 数据劫持、vue是通过Object.defineProperty()来实现数据劫持，</p>
<p> 其中会有getter()和setter⽅法；当读取属性值时，就会触发getter()⽅法，</p>
<p> 在view中如果数据发⽣了变化，就会通过Object.defineProperty( )对属性设置⼀个setter函数，</p>
<p> 当数据改变了就会来触发这个函数；</p>
<p>实现一个监听器 -&gt;实现一个解析器 -&gt; 实现一个订阅者 -&gt; 实现一个订阅器 Dep</p>
<h2 id="4-路由守卫"><a href="#4-路由守卫" class="headerlink" title="4. 路由守卫"></a>4. 路由守卫</h2><p><strong>1.全局路由守卫</strong></p>
<p>beforeEach(to, from, next) 全局前置守卫，路由跳转前触发</p>
<p>beforeResolve(to, from, next) 全局解析守卫 在所有组件内守卫和异步路由组件被解析之后触发</p>
<p>afterEach(to, from) 全局后置守卫，路由跳转完成后触发</p>
<p><strong>2.路由独享守卫</strong></p>
<p>beforeEnter(to,from,next) 路由对象单个路由配置 ，单个路由进⼊前触发</p>
<p><strong>3.组件路由守卫</strong></p>
<p>beforeRouteEnter(to,from,next) 在组件⽣命周期beforeCreate阶段触发</p>
<p>beforeRouteUpdadte(to,from,next) 当前路由改变时触发</p>
<p>beforeRouteLeave(to,from,next) 导航离开该组件的对应路由时触发</p>
<p><strong>4.参数</strong></p>
<p>to： 即将要进⼊的⽬标路由对象</p>
<p>from： 即将要离开的路由对象</p>
<p>next(Function)：是否可以进⼊某个具体路由，或者是某个具体路由的路径</p>
<h2 id="5-Vuex"><a href="#5-Vuex" class="headerlink" title="5. Vuex"></a>5. Vuex</h2><p>Vuex有五个核⼼概念：state,getters,mutations,actions,modules</p>
<ol>
<li><p>state：vuex的基本数据，⽤来存储变量</p>
</li>
<li><p>geeter：从基本数据(state)派⽣的数据，相当于state的计算属性</p>
</li>
<li><p>mutation：提交更新数据的⽅法，必须是同步的(如果需要异步使⽤action)。每个 mutation 都有⼀个字符串的 事件类型 (type) 和 ⼀个 回调函数 (handler)。</p>
</li>
</ol>
<p>回调函数就是我们实际进⾏状态更改的地⽅，并且它会接受 state 作为第⼀个参数，提交载荷作为第⼆个参数。</p>
<ol start="4">
<li><p>action：和mutation的功能⼤致相同，不同之处在于 &#x3D;&#x3D;》1. Action 提交的是 mutation，⽽不是直接变更状态。 2. Action 可以包含任意异步操作。</p>
</li>
<li><p>modules：模块化vuex，可以让每⼀个模块拥有⾃⼰的state、mutation、action、getters,使得结构⾮常清晰，⽅便管理。</p>
</li>
</ol>
<h2 id="6-组件通讯（⽗、⼦）"><a href="#6-组件通讯（⽗、⼦）" class="headerlink" title="6. 组件通讯（⽗、⼦）"></a>6. 组件通讯（⽗、⼦）</h2><ol>
<li><p>⽗组件向⼦组件传值:⽗组件通过属性的⽅式向⼦组件传值，⼦组件通过 props 来接收</p>
</li>
<li><p>⼦组件向⽗组件传值:⼦组件绑定⼀个事件，通过 this.$emit() 来触发</p>
</li>
<li><p>其他⽅式：缓存、vuex、eventBus事件总线、provide  inject</p>
</li>
</ol>
<h2 id="7-怎么定义vue-router的动态路由？"><a href="#7-怎么定义vue-router的动态路由？" class="headerlink" title="7. 怎么定义vue-router的动态路由？"></a>7. 怎么定义vue-router的动态路由？</h2><p>在router⽬录下的index.js⽂件中，对path属性加上&#x2F;:id。 使⽤router对象的params.id </p>
<h2 id="8-2-0和3-0的区别"><a href="#8-2-0和3-0的区别" class="headerlink" title="8. 2.0和3.0的区别"></a>8. 2.0和3.0的区别</h2><p>双向绑定:</p>
<p>V2：使⽤Object.defineProperty</p>
<p>V3：使⽤ES6的新特性proxy来劫持数据，当数据改变时发出通知</p>
<p>根元素:</p>
<p>V2: 必须要有⼀个根元素</p>
<p>V3: ⽆要求</p>
<p>diff算法:</p>
<p>V2: 虚拟Dom全量⽐较</p>
<p>V3: 增加了静态标记PatchFlag</p>
<p>生命周期不同</p>
<h2 id="9-computed-与-watch-的区别"><a href="#9-computed-与-watch-的区别" class="headerlink" title="9. computed 与 watch 的区别"></a>9. computed 与 watch 的区别</h2><p>computed⽀持缓存，相依赖的数据发⽣改变才会重新计算；watch不⽀持缓存，只要监听的数据变化就会触发相应操作</p>
<p>computed不⽀持异步，当computed内有异步操作时是⽆法监听数据变化的；watch⽀持异步操作</p>
<p>computed属性的属性值是⼀函数，函数返回值为属性的属性值，computed中每个属性都可以设置set与get⽅法。watch监听的数据必须是data中声明过或⽗组件传递过</p>
<p><strong>computed</strong></p>
<ol>
<li>它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景 </li>
<li>它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存</li>
<li>只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算 </li>
<li>它适⽤于计算⽐较消耗性能的计算场景 </li>
<li>必须要有一个返回值</li>
</ol>
<p><strong>watch</strong></p>
<ol>
<li><p>它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。</p>
<p>主要⽤于观察 <code>props</code> 或 本组件data的值，当这些值发生变化时，执⾏处理操作</p>
</li>
<li><p>不一定要返回某个值</p>
</li>
</ol>
<p><strong>建议</strong></p>
<ol>
<li><p>当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 <code>computed</code></p>
</li>
<li><p>当需要在某个数据发生变化的, 同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ <code>watch</code></p>
</li>
</ol>
<h2 id="10-Route和router的区别"><a href="#10-Route和router的区别" class="headerlink" title="10.Route和router的区别"></a>10.Route和router的区别</h2><ol>
<li><p>route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。</p>
</li>
<li><p>Router:是路由实例对象，包括了路由跳转⽅法，钩⼦函数等。</p>
</li>
</ol>
<h2 id="11-vue-router-路由模式有⼏种？"><a href="#11-vue-router-路由模式有⼏种？" class="headerlink" title="11.vue-router 路由模式有⼏种？"></a>11.vue-router 路由模式有⼏种？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract：</p>
<p>hash: 使⽤ URL hash 值来作路由。⽀持所有浏览器，包括不⽀持 HTML5 History Api 的浏览器；</p>
<p>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p>
<p>abstract : ⽀持所有 JavaScript 运⾏环境，如 Node.js 服务器端。如果发现没有浏览器的API，路由会⾃动强制进⼊这个模式.</p>
<h2 id="12-Object-defineProperty-和-Proxy-的区别"><a href="#12-Object-defineProperty-和-Proxy-的区别" class="headerlink" title="12. Object.defineProperty 和 Proxy 的区别"></a>12. Object.defineProperty 和 Proxy 的区别</h2><p>Object.defineProperty 和 Proxy 的区别如下:</p>
<ol>
<li>Proxy 可以直接监听对象而非属性；&#x20;</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等 是 Object.defineProperty 不具备的&#x20;</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准 的性能红利&#x20;</li>
<li>Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题, 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重 写</li>
</ol>
<h2 id="13-vue3-新特性有哪些？"><a href="#13-vue3-新特性有哪些？" class="headerlink" title="13. vue3 新特性有哪些？"></a>13. vue3 新特性有哪些？</h2><p>1、性能提升</p>
<ul>
<li>响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快，消除警告。</li>
<li>重写了 Vdom ，突破了 Vdom 的性能瓶颈。</li>
<li></li>
<li>进行模板编译优化。</li>
<li>更加高效的组件初始化</li>
</ul>
<p>2、更好的支持 typeScript</p>
<ul>
<li>有更好的类型推断，使得 Vue3 把 typeScript 支持得非常好</li>
</ul>
<p>3、新增Composition API</p>
<ul>
<li>Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强</li>
</ul>
<p>4、新增组件</p>
<ul>
<li>Fragment 不再限制 template 只有一个根几点。</li>
<li>Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。</li>
<li>Supense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。</li>
</ul>
<p>5、Tree-shaking：支持摇树优化</p>
<ul>
<li>摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快</li>
</ul>
<p>6、Custom Renderer API： 自定义渲染器</p>
<ul>
<li>实现 DOM 的方式进行 WebGL 编程</li>
</ul>
<h2 id="14-v-show-与-v-if-区别"><a href="#14-v-show-与-v-if-区别" class="headerlink" title="14. v-show 与 v-if 区别"></a>14. v-show 与 v-if 区别</h2><p>v-show和v-if的区别：</p>
<p>v-show是css切换，v-if是完整的销毁和重新创建。</p>
<p>使⽤频繁切换时⽤v-show，运⾏时较少改变时⽤v-if</p>
<h2 id="15-vue中v-if和v-for优先级在vue2和vue3中的区别"><a href="#15-vue中v-if和v-for优先级在vue2和vue3中的区别" class="headerlink" title="15. vue中v-if和v-for优先级在vue2和vue3中的区别"></a>15. vue中v-if和v-for优先级在vue2和vue3中的区别</h2><p>实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。</p>
<ul>
<li>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。</li>
<li>在 vue 3.x 中， v-if 总是优先于 v-for 生效。</li>
<li>vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。</li>
<li>vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常</li>
</ul>
<h2 id="16-script-setup-是干啥的？"><a href="#16-script-setup-是干啥的？" class="headerlink" title="16. script setup 是干啥的？"></a>16. script setup 是干啥的？</h2><p>scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：</p>
<ul>
<li>属性和方法无需返回，可以直接使用。</li>
<li>引入组件的时候，会自动注册，无需通过 components 手动注册。</li>
<li>使用 defineProps 接收父组件传递的值。</li>
<li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。</li>
<li>默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。</li>
</ul>
<h2 id="17-reactive与ref的区别？"><a href="#17-reactive与ref的区别？" class="headerlink" title="17. reactive与ref的区别？"></a>17. reactive与ref的区别？</h2><p>Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。</p>
<p>ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。</p>
<p>reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。</p>
<h2 id="18-v-model的使用？"><a href="#18-v-model的使用？" class="headerlink" title="18. v-model的使用？"></a>18. v-model的使用？</h2><p>v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.</p>
<p>V-model的原理：</p>
<ul>
<li><p>v-bind绑定一个value属性</p>
</li>
<li><p>v-on指令给当前元素绑定input事件</p>
</li>
</ul>
<p>可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体</p>
<p>组件上的双向绑定（原理）</p>
<p>v-model绑定在组件上的时候做了以下步骤</p>
<ul>
<li>在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性</li>
<li>子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。</li>
<li>子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值</li>
<li>v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上</li>
</ul>
<h2 id="19-vuex中的辅助函数怎么使用？"><a href="#19-vuex中的辅助函数怎么使用？" class="headerlink" title="19. vuex中的辅助函数怎么使用？"></a>19. vuex中的辅助函数怎么使用？</h2><p>vuex的辅助函数有4个</p>
<ul>
<li>mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。</li>
<li>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他</li>
<li>mapMutations 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.$store.commit(‘montify’)</li>
<li>mapActions在组件中使用 this.$store.dispatch(‘prodect’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用</li>
</ul>
<h2 id="20-slot是什么？有什么作用？原理是什么？"><a href="#20-slot是什么？有什么作用？原理是什么？" class="headerlink" title="20. slot是什么？有什么作用？原理是什么？"></a>20. slot是什么？有什么作用？原理是什么？</h2><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p>
<p><strong>slot又分三类，默认插槽，具名插槽和作用域插槽。</strong></p>
<ul>
<li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>
<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p><strong>实现原理：</strong></p>
<p>当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default具名插槽为vm.$slot.xxx，xxx 为插槽名</p>
<p>当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽</p>
<h2 id="21-nextTick的使用"><a href="#21-nextTick的使用" class="headerlink" title="21. $nextTick的使用"></a>21. $nextTick的使用</h2><p>用法：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p>
<p><strong>$nextTick() 的应用场景</strong></p>
<p>在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 $nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p>
<p>mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题</p>
<p>在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 $nextTick() 的回调函数中。</p>
<h2 id="22-v-for中的key"><a href="#22-v-for中的key" class="headerlink" title="22. v-for中的key"></a>22. v-for中的key</h2><p><strong>语法：</strong> key&#x3D;”唯一值”</p>
<p><strong>作用：</strong>给列表项添加的<strong>唯一标识</strong>。便于Vue进行列表项的<strong>正确排序复用</strong>。</p>
<p><strong>为什么加key：</strong>Vue 的默认行为会尝试原地修改元素（<strong>就地复用</strong>）</p>
<p>实例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in booksList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item.author &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;del(item.id)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><strong>key 的值只能是字符串 或 数字类型</strong></li>
<li><strong>key 的值必须具有唯一性</strong></li>
<li>推荐使用  id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li>
</ol>
<h2 id="23-data必须是一个函数"><a href="#23-data必须是一个函数" class="headerlink" title="23.data必须是一个函数"></a>23.data必须是一个函数</h2><p><strong>1、data为什么要写成函数</strong></p>
<p>一个组件的 <strong>data</strong> 选项必须<strong>是一个函数</strong>。目的是为了：<strong>保证每个组件实例</strong>，维护<strong>独立</strong>的一份<strong>数据</strong>对象。</p>
<p>每次创建新的组件实例，都会新<strong>执行一次data 函数</strong>，得到一个新对象。</p>
<h2 id="24-编程式导航，如何跳转传参？"><a href="#24-编程式导航，如何跳转传参？" class="headerlink" title="24.编程式导航，如何跳转传参？"></a><strong>24.编程式导航，如何跳转传参？</strong></h2><p>1.path路径跳转</p>
<ul>
<li><p>query传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/路径?参数名1=参数值1&amp;参数2=参数值2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/路径&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    参数名<span class="number">1</span>: <span class="string">&#x27;参数值1&#x27;</span>,</span><br><span class="line">    参数名<span class="number">2</span>: <span class="string">&#x27;参数值2&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态路由传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/路径/参数值&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/路径/参数值&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.name命名路由跳转</p>
<ul>
<li><p>query传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;路由名字&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    参数名<span class="number">1</span>: <span class="string">&#x27;参数值1&#x27;</span>,</span><br><span class="line">    参数名<span class="number">2</span>: <span class="string">&#x27;参数值2&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态路由传参 (需要配动态路由)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;路由名字&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    参数名: <span class="string">&#x27;参数值&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="25-什么是-M-V-VM"><a href="#25-什么是-M-V-VM" class="headerlink" title="25. 什么是 M V  VM"></a>25. 什么是 M V  VM</h2><p><code>Model-View-ViewModel 模式</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="web/面试/面试加强/02-笔记/前端面试手册.assets/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" />



<p><strong>Model 层</strong>: <code>数据模型层</code></p>
<p>通过 <code>Ajax</code>、<code>fetch</code> 等 API 完成客户端和服务端业务模型的同步。</p>
<p><strong>View 层</strong>: <code>视图层</code></p>
<p>作为视图模板存在，其实View 就是⼀个动态模板。</p>
<p><strong>ViewModel 层</strong>: <code>视图模型层</code></p>
<p>负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明, 进行实际的业务逻辑实现。</p>
<p><strong><code>数据变化了, 视图自动更新</code></strong> &#x3D;&gt; ViewModel 底层会做好监听Object.defineProperty，当数据变化时，View 层会自动更新</p>
<p><strong><code>视图变化了, 绑定的数据自动更新</code></strong> &#x3D;&gt;  会监听双向绑定的表单元素的变化，⼀旦变化，绑定的数据也会得到⾃动更新。</p>
<h2 id="26-MVVM的优缺点有哪些？"><a href="#26-MVVM的优缺点有哪些？" class="headerlink" title="26. MVVM的优缺点有哪些？"></a>26. MVVM的优缺点有哪些？</h2><p><strong>优点</strong></p>
<ol>
<li><p>实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性</p>
</li>
<li><p>提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码 </p>
</li>
<li><p>能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>Bug 难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，</p>
<p>也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，</p>
<p>要定位原始出问题的地⽅就变得不那么容易了</p>
<p>可采用的<code>调试方案</code>:</p>
<p>(1) 注释掉一段代码, 确定代码的位置</p>
<p>(2) debugger 打断点 或者 console 进行调试</p>
</li>
<li><p>在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，但如果⻓期持有不释放内存，就会造成更多的内存消耗 </p>
<p>占用的是 浏览器的 内存</p>
</li>
</ol>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="1-分析登录流程"><a href="#1-分析登录流程" class="headerlink" title="1.分析登录流程"></a>1.分析登录流程</h2><blockquote>
<p>传统思路都是登录校验通过之后，直接调用接口，获取token之后，跳转到主页。</p>
</blockquote>
<ul>
<li>vue-element-admin的登录思路：</li>
</ul>
<ol>
<li>登录表单校验通过</li>
<li>调用Vuex提供的登录的action</li>
<li>登录的Action中会调用接口</li>
<li>登录接口如果成功执行，会返回token</li>
<li>利用Vuex的特性，将token共享的到Vuex中，这样Vuex就统一管理了token,别的地方想要使用，直接通过Vuex就可以</li>
<li>登录接口会调用单独封装的请求模块(api)</li>
<li>请求模块中又会使用用到axios封装的请求工具</li>
<li>而请求工具又要考虑区分 开发环境和生产环境的问题</li>
<li>请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域</li>
</ol>
<h2 id="2-登录模块业务实现思路"><a href="#2-登录模块业务实现思路" class="headerlink" title="2.登录模块业务实现思路"></a>2.登录模块业务实现思路</h2><ol>
<li>首先设计并开发出登录页面的静态页面，设置Rules校验函数，对手机号和密码实现校验。基础校验和统一校验。</li>
<li>使用token 信息作为用户登录的唯一标识，并且存储在LocalStorage中，通过Vuex 统一管理token ，并且实现token 的持久化。</li>
<li>利用 axios 中设置请求拦截器，在每次请求的请求头中，注入 token 信息，作为登录的标识。</li>
<li>配合Vue-Router 中的beforeEach 前置导航守卫函数，实现对 token 信息的统一监测，和拦截登录。</li>
</ol>
<h2 id="3-主页模块的实现思路"><a href="#3-主页模块的实现思路" class="headerlink" title="3.主页模块的实现思路"></a>3.主页模块的实现思路</h2><ol>
<li>登录成功后，根据业务的需求，配合suss 实现对样式的二次修改。</li>
<li>初始化 Vuex 中的 mutations 信息，更新登录后用户的信息收集，封装 action 获取用户资料</li>
<li>利用 Vuex 中的 getters 属性，完成用户登陆后的视图层渲染</li>
<li>封装 action ，实现用户退出登录，调用 commit 方法，清除 Vuex 中保存的 token 信息</li>
<li>根据后端检测 token 返回的状态码，设置拦截器，对失效 token 信息实现拦截登录，并提示用户token失效</li>
</ol>
<h2 id="4-登录流程"><a href="#4-登录流程" class="headerlink" title="4.登录流程"></a>4.登录流程</h2><ol>
<li><p>拉取 vue-admin-template 代码，进行一些改造。</p>
</li>
<li><p>设计并且开发登录页面，进行表单校验，基础校验 + 统一校验</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 基础校验</span></span><br><span class="line"><span class="comment">el-form  :model=&quot;表单对象&quot;  :rules=&quot;规则对象&quot;</span></span><br><span class="line"><span class="comment">el-form-item  prop属性指定一下要使用哪条规则</span></span><br><span class="line"><span class="comment">el-input v-model双向绑定</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">统一校验</span></span><br><span class="line"><span class="comment">1. 获取表单的实例对象</span></span><br><span class="line"><span class="comment">2. 调用validate方法    const res = await this.$refs.loginForm.validate() </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Vuex 中实现用户的模块</p>
<ol>
<li><p>删除模板中原有的内容进行重写  </p>
</li>
<li><p>开启命名空间，导出 vuex 子模块</p>
</li>
<li><p>实现 token 的vue数据持久化   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 存<span class="title class_">Token</span>数据时，一份存入vuex，一份存入cookie</span><br><span class="line"><span class="number">2.</span> vuex中初始化<span class="title class_">Token</span>时，优先从本地cookie取，取不到再初始化为空串儿</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现登录的actions方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">form</span>.<span class="title function_">validate</span>(<span class="function">(<span class="params">isOK</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOK) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;user/login&quot;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Vue-cli 代理解决跨域：配置文件可以直接配置代理 vue.config.js  -&gt; devServer  -&gt;  proxy -&gt; api</p>
</li>
<li><p>axios 二次封装，将 <code>axios </code>请求方法，封装到 request 模块</p>
<ol>
<li><p>配置基础地址  ，超出时间</p>
</li>
<li><p>请求拦截器 - 根据获取仓库中的token 来判断  然后 在header 中统一注入 token</p>
</li>
<li><p>响应拦截器 - 解构数据  -  处理异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用配置</span></span><br><span class="line"><span class="comment">// 1. axios实例化  axios.create() 基地址配置 baseURL + 超时时间 timeout（100ms）</span></span><br><span class="line"><span class="comment">// 拓展：create方法可以调用多次 每次执行都会生成一个独一无二的实例</span></span><br><span class="line"><span class="comment">// export default const a = asiox.create(&#123; baseURL: &#x27;a.com&#x27; &#125;)</span></span><br><span class="line"><span class="comment">// export default const b = asiox.create(&#123; baseURL: &#x27;b.com&#x27; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求拦截器  请求头中添加token数据  接口鉴权  统一配置</span></span><br><span class="line"><span class="comment">// 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端</span></span><br><span class="line"><span class="comment">// 拓展：可以添加多个请求拦截器</span></span><br><span class="line"><span class="comment">// 客户端请求 - 拦截器1(处理参数) - 拦截器2 - 后端 </span></span><br><span class="line"><span class="comment">// 最后一定要return  config  失败就执行promise.reject(error)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 响应拦截器 数据剥离 res.data / token失效401错误处理 / 前端自定义错误处理？ </span></span><br><span class="line"><span class="comment">// 后端 - 响应拦截器 - 客户端</span></span><br><span class="line"><span class="comment">// 成功回调 200-300</span></span><br><span class="line"><span class="comment">// 失败回调 不在这个之间</span></span><br><span class="line"><span class="comment">// axios默认包裹了一层data 把响应数据解构出来  判断如果业务成功 返回用户所需要的数据   业务失效 错误提示  return 一个error  （new一个）</span></span><br><span class="line"><span class="comment">// // 所有的响应错误信息，统一处理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>封装 api 接口</p>
<p><strong>将请求封装成方法，统一存放到 api 模块，与页面分离,可维护性高</strong></p>
<p>新建 <code>api/user.js</code> 提供注册 Api 函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">register</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> request.<span class="title function_">post</span>(<span class="string">&#x27;/user/register&#x27;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>区分环境（表单）</p>
<ol>
<li>开发环境  developent</li>
<li>生产环境   production</li>
</ol>
</li>
<li><p>登录联调</p>
<ol>
<li>封装登录的api</li>
<li>vuex 中的用户模块调用登录接口</li>
<li>登录成功后，跳转到主页</li>
<li>区分表单不同环境下的不同数据</li>
</ol>
</li>
<li><p>主页鉴权验证</p>
<ol>
<li>访问主页-有token放过，没有token跳到登录页</li>
<li>访问登录-有token跳到主页，没有token放过</li>
<li>前置守卫 - beforeEach 中 来处理逻辑  白名单</li>
</ol>
</li>
</ol>
<h2 id="5-智慧园区"><a href="#5-智慧园区" class="headerlink" title="5.智慧园区"></a>5.智慧园区</h2><h3 id="1-搜索功能"><a href="#1-搜索功能" class="headerlink" title="1.搜索功能"></a>1.搜索功能</h3><p>  思路分析：把各种搜索条件当作请求参数发给后端 后端会根据字段对数据库数据做过滤筛选拿到符合条件返回</p>
<pre><code>        1. 表单组件的双向绑定收集到当前的请求数据
        2. 把收集到的表单参数发送接口给后端那符合条件的数据
        3. 把拿到的数据关系显示在列表中
</code></pre>
<h3 id="2-excel导出"><a href="#2-excel导出" class="headerlink" title="2.excel导出"></a>2.excel导出</h3><ol>
<li><p>实际开发过程中的导出</p>
<ol>
<li><p>前端主导（xlsx）</p>
<p>流程：调用列表接口把要导出的数据拿到 -&gt; 数据的二次转化  -&gt;  [excel 工作簿 - 工作表 - 单元格数据] - 使用xlsx创建一个工作簿 - 使用xlsx方法创建一个工作表 - 把工作表添加到工作簿 – [使用中文替换中文表头] 调用xlsx的导出方法</p>
<p>工作中遇到了需求，参考代码 换接口 数据二次处理 处理表头</p>
</li>
<li><p>后端主导（最常见）</p>
<p>流程：前端直接调用导出接口 - 后端会把数据转换成excel文件流当成返回值返回 - 直接触发浏览器的下载功能</p>
</li>
</ol>
</li>
<li><p>两种方案的本质区别：</p>
<p>把数据转化成excel的过程发生在哪里？如果发生在浏览器 前端主导 如果发生在后端服务器 后端主导</p>
<p>前端主导 - 处理数据量不能太大</p>
<p>后端主导 - 适合处理量大或量小都可</p>
</li>
</ol>
<h3 id="3-网络请求的优化"><a href="#3-网络请求的优化" class="headerlink" title="3.网络请求的优化"></a>3.网络请求的优化</h3><ol>
<li>场景: 限制了请求个数 保证只有打开时才请求</li>
<li>怎么做到？<ol>
<li>判断第一个参数row是否能在第二个参数rows中找到 如果能找到代表打开了</li>
<li>find 通过匹配找到符合条件的第一项 然后把找到的项返回</li>
<li>findIndex 通过匹配找到符合条件的第一项 然后把找到项的下标值返回 splice(index,1)</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有展开时获取数据并绑定</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">expandHandle</span>(<span class="params">row, rows</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;展开或关闭&#x27;, row, rows) 点击行row.id  rows数组对象</span></span><br><span class="line">  <span class="comment">// row: 当前行的对象  rows数组对象</span></span><br><span class="line">  <span class="comment">// 1. 先拿到当前行的数据</span></span><br><span class="line">  <span class="comment">// 2. 使用当前行的企业数据，获取下面的合同列表数据</span></span><br><span class="line">  <span class="comment">// 3. 把拿到的合同列表存入企业对象中 但是row里面没有存放的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化网络请求 只在打开时才去触发 核心：拿到当前是打开的条件 做判断</span></span><br><span class="line">    <span class="comment">// 判断条件：第一个row是否能在第二个rows中找到 如果找到了 代表打开了 如果找不到 代表收起了</span></span><br><span class="line">    <span class="comment">// find findIndex</span></span><br><span class="line">  <span class="keyword">const</span> isExpend = rows.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === row.<span class="property">id</span>)</span><br><span class="line">  <span class="keyword">if</span> (isExpend) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了这一项，才回去调用接口</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getRentListAPI</span>(row.<span class="property">id</span>)</span><br><span class="line">    <span class="comment">// eslint-disable-next-line require-atomic-updates</span></span><br><span class="line">    row.<span class="property">rentList</span> = res.<span class="property">data</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-后端返回数据字段不够前端自定义字段"><a href="#4-后端返回数据字段不够前端自定义字段" class="headerlink" title="4.后端返回数据字段不够前端自定义字段"></a>4.后端返回数据字段不够前端自定义字段</h3><p>  默认的返回的企业列表数据中没有一个存放合同列表的数据的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">list</span> = res.<span class="property">data</span>.<span class="property">rows</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">rendList</span>: []  <span class="comment">// 通过映射自定义添加字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="5-树状组件怎么实现的？"><a href="#5-树状组件怎么实现的？" class="headerlink" title="5.树状组件怎么实现的？"></a>5.树状组件怎么实现的？</h3><p>树形组件：用层级结构展示信息，可展开或折叠。</p>
<ol>
<li><p>element-ui提供了树组件<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/tree">el-tree</a>的应用</p>
</li>
<li><p>组件中放置树形组件</p>
</li>
<li><p>获取后台的数据</p>
</li>
<li><p>递归转化树形结构</p>
<ol>
<li>首先分析数据的关联关系</li>
<li>封装递归函数根据关联关系转化层级结构</li>
<li>通过分析了解到，父级的id为子级的pid</li>
<li>封装公共方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 列表型数据转化树形</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">transListToTreeData</span>(<span class="params">list, rootValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">pid</span> === rootValue) &#123;</span><br><span class="line">      <span class="comment">// 找到了匹配的节点</span></span><br><span class="line">      <span class="comment">// 当前节点的id 和 当前节点的子节点的pid是想等的</span></span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">transListToTreeData</span>(list, item.<span class="property">id</span>) <span class="comment">// 找到的节点的子节点</span></span><br><span class="line">      item.<span class="property">children</span> = children  <span class="comment">// 将子节点赋值给当前节点</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将列表型的数据转化成树形数据 =&gt; 递归算法 =&gt; 自身调用自身 =&gt; 一定条件不能一样， 否则就会死循环</span></span><br><span class="line"><span class="comment">//  *  遍历树形 有一个重点 要先找一个头儿</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-记住我优化"><a href="#6-记住我优化" class="headerlink" title="6.记住我优化"></a>6.记住我优化</h3><ol>
<li>基础实现逻辑<br>如果当前用户选中了记住，在登录时把用户的信息存入本地 在组件初始化的时候去取数据 回填<br>  如果当前没有选中，在登录时把数据清空</li>
</ol>
<h3 id="7-数据基础渲染"><a href="#7-数据基础渲染" class="headerlink" title="7.数据基础渲染"></a>7.数据基础渲染</h3><ol>
<li>基础实现逻辑<ol>
<li>准备静态模版（elementUI）</li>
<li>解决初始报错 在data中把模版绑定的数据都声明一遍</li>
<li>封装接口（url&#x2F; method &#x2F; 参数[名称 + 类型 + 参数数量]）</li>
<li>组件中封装一个独立的方法 在方法中调用接口函数 （复用的好处 调用之前做一些额外的参数处理）</li>
<li>选择一个合适生命周期钩子函数调用独立的方法 （created &#x2F; mounted 都可以）</li>
<li>使用数据渲染模版 （数据驱动视图）</li>
</ol>
</li>
</ol>
<h3 id="8-列表基础渲染"><a href="#8-列表基础渲染" class="headerlink" title="8.列表基础渲染"></a>8.列表基础渲染</h3><ol>
<li><p>实现步骤</p>
<ol>
<li>按照接口文档请求列表接口封装一下（url&#x2F;method&#x2F;参数）</li>
<li>data准备响应式的数据（以后端接口实际返回为主）</li>
<li>在methods封装一个方法（参数的二次处理 + 调用接口 + 数据赋值）</li>
<li>生命周期钩子函数调用这个方法（created &#x2F; mounted）</li>
<li>把响应式数据绑定组件身上（文档组件要求通过什么属性绑定就通过生命属性）</li>
</ol>
</li>
<li><p>分页功能</p>
<ol>
<li><p>分页的逻辑<br>页数 &#x3D; 总条数 &#x2F; 单页的条数</p>
</li>
<li><p>组件分好页<br>传入总数  :total&#x3D;”100”<br>单页条数  :pageSize&#x3D;”2” 默认10</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">   1. 页数分出来 （页数 = 总条数 / 每页条数）</span><br><span class="line">   2. 点击每页的时候获取当前页的数据重新渲染到table上</span><br><span class="line">--&gt;</span><br><span class="line">&lt;el-pagination</span><br><span class="line">  layout=&quot;total, prev, pager, next&quot;</span><br><span class="line">  :page-size=&quot;params.pageSize&quot;</span><br><span class="line">  :total=&quot;total&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>点击分页交互的实现</p>
<ol>
<li><p>点击时拿到当前点击的页数（父组件从子组件获取内部的数据 子传父）<br>@current-change&#x3D;”pageChange”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pageChange</span>(<span class="params">page</span>) &#123; </span><br><span class="line">   <span class="comment">// console.log(page) // 回调参数 拿到的是当前页</span></span><br><span class="line">   <span class="comment">// 把点击的页数赋值给请求参数页数  </span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line">   <span class="comment">// 使用最新的请求参数获取列表数据</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getCardList</span>()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用当前的页数去后端要当前页的数据重新渲染到table</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="9-状态适配"><a href="#9-状态适配" class="headerlink" title="9.状态适配"></a>9.状态适配</h3><ol>
<li><p>场景<br>后端返回的数据无法直接显示到页面中 0&#x2F;1 男女</p>
</li>
<li><p>转化的状态码数量只有两个<br>解决方案：三元表达式  status &#x3D;&#x3D;&#x3D; 0? ‘女’ ：’男’</p>
<p>转化的状态码比较多<br>解决方案：映射的方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">status</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAP</span> = &#123;</span><br><span class="line">   <span class="number">0</span>:<span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">   <span class="number">1</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">MAP</span>[status]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>带有模板的状态格式化</strong></p>
<ol>
<li><p>直接可以把后端的数据渲染出来 prop指定要渲染的字段</p>
</li>
<li><p>不能直接渲染  需要格式化  格式化出来的内容一九是一个文本  string</p>
<ol>
<li>：formatter&#x3D;”formatStatus” 不需要手动传参 自动传入</li>
<li>插槽 + 插值表达式  [渲染出来的是函数的返回值]</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">default</span>=<span class="string">&quot;&#123;row&#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; formatStatus(row.status) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-上传图片"><a href="#10-上传图片" class="headerlink" title="10.上传图片"></a>10.上传图片</h3><ol>
<li><p>上传的流程<br>点击上传按钮 -&gt; el-upload [打开本地文件选择框 + 上传前的文件校验] -&gt; File -&gt;<br>new FormData()[接口要求传递一个formdata类型的数据] -&gt; 往formData的对象中append字段<br>-&gt; append(‘file’,file) append(‘type’,’business…’) -&gt; 使用完整的formData对象提交接口完成    上传</p>
</li>
<li><p>细节问题</p>
<ol>
<li>el-upload<ol>
<li>非常简单  不需要做任何的自定义配置 默认的配置项完成上传就行了</li>
<li>需要自定义场景  :http-request&#x3D;’function’</li>
<li>如果添加了上传前的校验 流程：先执行上传前的校验函数 函数返回值为true 再执行upload上传函数</li>
<li>函数参数 ：上传前的函数 file对象 [size &#x2F; type做校验] 上传函数  res对象 { file：File }</li>
</ol>
</li>
<li>上传接口接口参数<ol>
<li>常规的接口  contentType  application&#x2F;json</li>
<li>上传接口    contentType  application&#x2F;form-data</li>
</ol>
</li>
<li>前后端校验逻辑要保持一致<br>文件大小  小于5m  &#x2F; 文件类型 jpeg  前端要以这个为主<br>[因为接口不只是可以通过浏览器提交 也可以通过其他方式提交 基于界面操作类校验会失败]</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> :http-request=&quot;uploadRequest&quot; 自定义上传</span><br><span class="line">  action 本来是一个用来配置默认上传的接口地址</span><br><span class="line">  因为我们覆盖了  所以用一个 # 占个位置 消除必填警告</span><br><span class="line">  input type=&quot;file&quot; 本身具备选择文件的能力</span><br><span class="line">  覆盖原因：默认的配置上传不够灵活 仅支持一些简单的上传 </span><br><span class="line"></span><br><span class="line">  如果想要完全自定义上传 http-request</span><br><span class="line">  在选择文件之后 自动执行upload函数 并且把一个对象传给我们</span><br><span class="line">  对象中有一个file属性 就是我们要上传的对象</span><br><span class="line">      </span><br><span class="line">  上传前校验：</span><br><span class="line">    1. 上传图片之前加一层校验 目的为了限制用户上传的文件类型和大小</span><br><span class="line">    2. 如果我们添加了beforeUpload这个属性方法 这个函数中必须return的数据为true</span><br><span class="line">       才会继续执行 upload 方法 如果校验不通过 暂停执行 不会走上传逻辑</span><br><span class="line">    3. file对象中两个属性</span><br><span class="line">       size: 文件大小 / 1024/1024 = M</span><br><span class="line">       type: 文件类型  image/文件类型</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=&quot;营业执照&quot;&gt;</span><br><span class="line">    &lt;el-upload</span><br><span class="line">      action=&quot;#&quot;</span><br><span class="line">      :http-request=&quot;uploadRequest&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">      &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">    &lt;/el-upload&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- </span><br><span class="line">    上传实现流程：</span><br><span class="line">      1. el-upload 打开本地文件  并且校验这个文件是否符合要求 - File</span><br><span class="line">      2. :http-request = &#x27;upload&#x27;</span><br><span class="line">      3. 按照接口的要求格式 得到类型为FormData对象 new FormData()</span><br><span class="line">      4. 按照要求往 formData中添加字段数据 fd.append(&#x27;字段名&#x27;,&#x27;字段值&#x27;)</span><br><span class="line">      5. 调用上传接口</span><br><span class="line">      6. 拿到返回的文件地址和其有用的信息id 存入data中的响应式数据的位置 将来提交表单</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure>



<h3 id="11-菜单路由控制权限"><a href="#11-菜单路由控制权限" class="headerlink" title="11.菜单路由控制权限"></a>11.菜单路由控制权限</h3><ol>
<li>权限数据的生成（RBAC）<ol>
<li>新增一个角色 给角色配置权限数据</li>
<li>新增一个员工 给员工分配这个角色 员工就有了当前角色下所有的权限数据</li>
</ol>
</li>
<li>完整的实现流程<ol>
<li><p>调用接口获取当前员工的权限数据  permission [‘park:building:add_edit’]</p>
<ol>
<li>在Vuex中编写逻辑，user&#x2F;state里存放个人用户信息 </li>
<li>action里调用时，把permissions目标数据return出去 给另一个js模块使用</li>
<li>permission文件中触发action，获取用户信息（有token时）</li>
</ol>
</li>
<li><p>对权限数据做格式化处理 产生两个权限数据  一级路由权限数组 + 二级路由权限数组</p>
</li>
<li><p>把路由表拆分成两部分 动态路由表[需要加权限控制] + 静态路由表[不需要加权限控制]</p>
<ol>
<li>拆分动态路由表导出使用 asyncRoutes</li>
<li>初始化时候只处理静态路由表  routes: […routes]</li>
</ol>
</li>
<li><p>以一级和二级权限数组作为对主动态路由表做过滤筛选处理 -&gt; 有资格加入到路由系统中的动态路由表</p>
<ol>
<li>使用一级权限点过滤一级路由 使用二级权限点过滤二级路由 最终得到显示左侧的路由表</li>
<li>调用函数获取最终的动态路由</li>
</ol>
</li>
<li><p>调用router的addRoute方法把动态路由表依次添加到路由系统中 访问url可以渲染对应的组件</p>
</li>
<li><p>使用动态路由表数据通过存入Vuex然后利用它响应式的特性 渲染到左侧菜单中</p>
<ol>
<li>vuex新增一个模块，menu模块，先以静态的路由表作为初始值</li>
<li>在得到过滤之后的动态路由表之后，和之前的静态做一个结合</li>
<li>在sidebar组件中结合v-for指令做使用Vuex中的数据做渲染</li>
</ol>
</li>
<li><p>解决切换用户有缓存的bug 方案：在用户退出登录时</p>
<ol>
<li><p>调用清空路由的reset方法</p>
</li>
<li><p>手动把Vuex中的数据也清空</p>
</li>
<li><p>用户信息也清空</p>
</li>
</ol>
</li>
</ol>
</li>
<li>每一个独立的小功能封装成一个独立的小函数 维护方便</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">profile</span>.<span class="property">id</span>) &#123;</span><br><span class="line">       <span class="comment">// 1. 调用action函数获取用户权限数据</span></span><br><span class="line">       <span class="keyword">const</span> permissions = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getProfile&#x27;</span>)</span><br><span class="line">       <span class="comment">// 2. 把后端的权限数组格式化成我们自己的俩个权限数据</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前的权限数据为:&#x27;</span>, permissions)</span><br><span class="line">       <span class="keyword">const</span> firstRoutePerms = <span class="title function_">getFirstRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一级路由权限&#x27;</span>, firstRoutePerms)</span><br><span class="line">       <span class="keyword">const</span> secondRoutePerms = <span class="title function_">getSecondRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;二级路由权限&#x27;</span>, secondRoutePerms)</span><br><span class="line">       <span class="comment">// 3. 根据权限标识过滤路由表 最终得到显示到左侧的路由表</span></span><br><span class="line">       <span class="keyword">const</span> routes = <span class="title function_">getRoutes</span>(firstRoutePerms, secondRoutePerms, asyncRoutes)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最终路由表&#x27;</span>, routes)</span><br><span class="line">       <span class="comment">// 4. addRoute动态添加 (当浏览器中访问路由的路径 显示渲染出来对应的组件)</span></span><br><span class="line">       routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> router.<span class="title function_">addRoute</span>(route))</span><br><span class="line">       <span class="comment">// 5. 存入Vuex渲染左侧菜单</span></span><br><span class="line">       store.<span class="title function_">commit</span>(<span class="string">&#x27;menu/setMenuList&#x27;</span>, routes)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-按钮控制权限"><a href="#12-按钮控制权限" class="headerlink" title="12.按钮控制权限"></a>12.按钮控制权限</h3><blockquote>
<p>概念：根据当前用户的权限数据控制按钮的显示和隐藏</p>
</blockquote>
<p>思路：每一个需要做权限控制的按钮都有一个自己独有的 <code>标识</code> , 如果标识可以在权限数据列表中找到，则显示，找不到就隐藏<br>方案：应用中可能会有很多按钮需要做权限控制，所以方案一定是全局生效的，我们提供俩种可选的方案</p>
<p>全局指令方案  和  高阶组件  方案。</p>
<h3 id="13-微前端"><a href="#13-微前端" class="headerlink" title="13.微前端"></a>13.微前端</h3><p>微前端是一种前端架构模式，它将大型单体应用程序分解为小的、松散耦合的部分，每个部分都可以独立开发、测试和部署。</p>
<p>使用乾坤方案进行改造.</p>
<p><strong>1. 基础运行原理</strong></p>
<ol>
<li><p>监听路由变化  实现一个注册子应用配置的方法</p>
</li>
<li><p>匹配子应用  实现路由的匹配</p>
</li>
<li><p>加载子应用  实现加载子应用</p>
</li>
<li><p>渲染子应用  实现子应用的渲染</p>
</li>
<li><p><strong>前端加载3D模型</strong></p>
<ol>
<li>下载模型解析包</li>
<li>拉取模型并渲染</li>
<li>添加进入条</li>
</ol>
</li>
<li><p><strong>大屏适配</strong></p>
<ol>
<li>安装组件  npm i v-scale-screen</li>
<li>使用组件并制定高度</li>
</ol>
</li>
</ol>
<h2 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h2><ol>
<li><p>Vue 中使用样式无法生效  deep</p>
</li>
<li><p>解决history页面404访问问题</p>
<ol>
<li>当我们刷新页面，发现404</li>
</ol>
<blockquote>
<p>  这是因为我们采用了history的模式，地址的变化会引起服务器的刷新，我们只需要在app.js对所有的地址进行一下处理即可</p>
</blockquote>
</li>
<li><p>在 Vue 中使用 axios 下载 excel 文档，出现乱码</p>
<p>4．使用 webpack 打包项目，导致图片无法显示 ： 文件路径错误      配置问题：Webpack配置文件中是否有正确的loader配置来处理图片文件。</p>
</li>
</ol>
<h3 id="1-refresh-token"><a href="#1-refresh-token" class="headerlink" title="1.refresh_token"></a>1.refresh_token</h3><p>在调用登录接口成功后会返回 <code>token</code> 和 <code>refreshToken</code> 当 <code>token</code> 有效时间设置了 8 个小时，<code>refreshToken</code> 有效时间设置了 3 天，当 <code>token</code> 失效后 <code>refreshToken</code> 仍然有效，此时可以通过 <code>refreshToken</code> 来为 <code>token</code> 续期，所谓的续期就是调用后端提供的一个接口，然后把 <code>refreshToken</code> 发送给服务端，服务端重新返回新的 <code>token</code> 和 <code>refreshToken</code>。</p>
<ol>
<li><p>判断当前的 <code>token</code> 有没有失效可以根据接口返回的状态码进行判断，当 <code>token</code> 失效后会返回 <code>401</code>，在响应拦截器中可以统一获取所有接口返回的状态码，然后对其进行判断</p>
</li>
<li><p>要想通过应用实例 getApp 来读取 <code>refreshToken</code> 必须提前读取本地存储的数据并存储到应用实例当中</p>
</li>
<li><p>调用接口把 <code>refreshToken</code> 发送给服务端换取新的 <code>token</code> 和 <code>refreshToken</code></p>
<p>接口中所需要的接口 <code>refreshToken</code> 需要通过自定义的头信息 <code>Authorization</code> 来传递</p>
</li>
</ol>
<h3 id="2-实现vant组件自动按需加载，和自动导入"><a href="#2-实现vant组件自动按需加载，和自动导入" class="headerlink" title="2.实现vant组件自动按需加载，和自动导入"></a>2.实现vant组件自动按需加载，和自动导入</h3><ol>
<li>安装 yarn add unplugin-vue-components -D</li>
<li>配置 plugins 里的 Components</li>
</ol>
<h3 id="3-vueuse-core"><a href="#3-vueuse-core" class="headerlink" title="3.@vueuse&#x2F;core"></a>3.@vueuse&#x2F;core</h3><p>介绍 @vueuse&#x2F;core 组合api库，使用 useXxx 函数获取设备宽度，动态设置滚动距离</p>
<p>@vueuse&#x2F;core 介绍：<a target="_blank" rel="noopener" href="https://vueuse.org/functions.html">文档</a></p>
<ul>
<li>是一个基于 组合API 封装的库</li>
<li>提供了一些网站开发常用的工具函数，且得到的是响应式数据</li>
</ul>
<p>需求：</p>
<ul>
<li>在 375 宽度设备，滚动宽度为 150</li>
<li>在其他设备需要等比例设置滚动的宽度</li>
<li>scrollWidth &#x3D; 150 &#x2F; 375 * deviceWidth 就可以适配</li>
</ul>
<p>@vueuse&#x2F;core 应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @vueuse/core</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useWindowSize &#125; from &#x27;@vueuse/core&#x27;</span><br><span class="line"></span><br><span class="line">const &#123; width &#125; = useWindowSize()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>如果遇见一些常见的需求可以先看看 @vueuse&#x2F;core 是否提供，这样可以提高开发效率。<ul>
<li>如果：窗口尺寸，滚动距离，是否进入可视区，倒计时，…等等。</li>
</ul>
</li>
</ul>
<h3 id="4-极速问诊"><a href="#4-极速问诊" class="headerlink" title="4.极速问诊"></a>4.极速问诊</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/10/29/653d31d9160d7.png" alt="image-20231028232009299.png"></p>
<h3 id="5-问诊室-websocket介绍"><a href="#5-问诊室-websocket介绍" class="headerlink" title="5.问诊室-websocket介绍"></a>5.问诊室-websocket介绍</h3><p>什么是 websocket ? <a target="_blank" rel="noopener" href="https://websocket.org/">https://websocket.org/</a></p>
<ul>
<li>是一种网络通信协议，和 HTTP 协议 一样。</li>
</ul>
<p>为什么需要websocket ?</p>
<ul>
<li>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</li>
</ul>
<p>我们项目中使用 socket.io-client 来实现客户端代码，它是基于 websocket 的库。</p>
<p><strong>问诊室-socket.io使用</strong></p>
<blockquote>
<p>目的：掌握 <a target="_blank" rel="noopener" href="http://socket.io/">socket.io</a> 的基本使用</p>
</blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="http://socket.io/">socket.io</a> 什么？<ul>
<li><a target="_blank" rel="noopener" href="http://socket.io/">socket.io</a> 是一个基于 WebSocket 的 CS（客户端-服务端）的实时通信库</li>
<li>使用它可以在后端提供一个即时通讯服务</li>
<li>它也提供一个 js 库，在前端可以去链接后端的 <a target="_blank" rel="noopener" href="http://socket.io/">socket.io</a> 创建的服务</li>
<li>总结：它是一套基于 websocket 前后端即时通讯解决方案</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://socket.io/">socket.io</a> 如何使用？<ul>
<li>大家可以体验下这个 <a target="_blank" rel="noopener" href="https://socket.io/get-started/chat#getting-this-example">官方Demo</a></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add socket.io-client</span><br></pre></td></tr></table></figure>

<p>如何建立连接？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import io from &#x27;socket.io-client&#x27;</span><br><span class="line">// 参数1：不传默认是当前服务域名，开发中传入服务器地址</span><br><span class="line">// 参数2：配置参数，根据需要再来介绍</span><br><span class="line">const socket = io()</span><br></pre></td></tr></table></figure>

<p>如何确定连接成功？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&#x27;connect&#x27;, () =&gt; &#123;</span><br><span class="line">  // 建立连接成功</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如何发送消息？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// chat message 发送消息事件，由后台约定，可变</span><br><span class="line">socket.emit(&#x27;chat message&#x27;, &#x27;消息内容&#x27;)</span><br></pre></td></tr></table></figure>

<p>如何接收消息？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// chat message 接收消息事件，由后台约定，可变</span><br><span class="line">socket.on(&#x27;chat message&#x27;, (ev) =&gt; &#123;</span><br><span class="line">  // ev 是服务器发送的消息</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如何关闭连接？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 离开组件需要使用</span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li><p>sockt.io</p>
<p>在前端使用的js库需要知道哪些内容？</p>
<ul>
<li>如何建立链接 <code>io(&#39;地址&#39;)</code></li>
<li>连接成功的事件 <code>connect</code></li>
<li>如何发消息 <code>emit</code> + 事件</li>
<li>如何收消息 <code>on</code> + 事件</li>
<li>如果关闭连接 <code>close()</code></li>
</ul>
</li>
</ul>
<h3 id="6-Vue-项目权限处理"><a href="#6-Vue-项目权限处理" class="headerlink" title="6. Vue 项目权限处理"></a>6. Vue 项目权限处理</h3><p>现在权限相关管理系统用的框架都是element提供的<a target="_blank" rel="noopener" href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>模板框架比较常见。</p>
<p>权限控制常见分为三大块</p>
<ul>
<li><strong>菜单权限控制</strong></li>
<li><strong>按钮权限控制</strong></li>
<li>请求url权限控制。</li>
</ul>
<p><strong>权限管理在后端中主要体现在对接口访问权限的控制，在前端中主要体现在对菜单访问权限的控制。</strong></p>
<ol>
<li><p>按钮权限控制比较容易，主要采取的方式是从后端返回按钮的权限标识，然后在前端进行显隐操作 v-if &#x2F; disabled。</p>
</li>
<li><p>url权限控制，主要是后端代码来控制，前端只需要规范好格式即可。</p>
</li>
<li><p>剩下的菜单权限控制，是相对复杂一些的</p>
<p>(1) <strong>需要在路由设计时, 就拆分成静态路由和动态路由</strong></p>
<p>​       静态路由: 所有用户都能访问到的路由, 不会动态变化的 (登录页, 首页, 404, …)</p>
<p>​	   动态路由: 动态控制的路由, 只有用户有这个权限, 才将这个路由添加给你 (审批页, 社保页, 权限管理页…)</p>
<p>(2) 用户登录进入首页时, 需要立刻发送请求, 获取个人信息 (包含权限的标识)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/web/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA/02-%E7%AC%94%E8%AE%B0/images/image-20210309031043592.png" alt="image-20210309031043592"></p>
<p>(3) <strong>利用权限信息的标识, 筛选出合适的动态路由</strong>, 通过路由的 <strong>addRoutes 方法</strong>, 动态添加路由即可!</p>
<p>(4) router.options.routes (拿的是默认配置的项, 拿不到动态新增的) 不是响应式的! </p>
<p>​	  为了能正确的显示菜单, 为了能够将来正确的获取到用户路由, 我们需要用<strong>vuex管理routes路由数组</strong></p>
<p>(5) 利用vuex中的 routes, 动态渲染菜单</p>
</li>
</ol>
<h3 id="7-如何处理-打包出来的项目-首屏-加载过慢的问题"><a href="#7-如何处理-打包出来的项目-首屏-加载过慢的问题" class="headerlink" title="7. 如何处理 打包出来的项目(首屏)加载过慢的问题"></a>7. 如何处理 打包出来的项目(首屏)加载过慢的问题</h3><p>SPA应用: 单页应用程序, 所有的功能, 都在一个页面中, 如果第一次将所有的路由资源, 组件都加载了, 就会很慢!</p>
<p>加载过慢 &#x3D;&gt; 一次性加载了过多的资源,  一次性加载了过大的资源</p>
<ul>
<li>加载过多 &#x3D;&gt; 路由懒加载, 访问到路由, 再加载该路由相关的组件内容</li>
<li>加载过大 &#x3D;&gt; 图片压缩, 文件压缩合并处理, 开启gzip压缩等</li>
</ul>
<p>比如:</p>
<ol>
<li><p>配置异步组件, 路由懒加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;../pages/login.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片压缩: 使用 webp 格式的图片, 提升首页加载的速度</p>
</li>
<li><p>CDN加速: 配置CDN加速, 加快资源的加载效率 (花钱)</p>
</li>
<li><p>开启 gzip 压缩 (一般默认服务器开启的, 如果没开, 确实可能会很慢, 可以让后台开一下)</p>
</li>
</ol>
<h3 id="8-你在项目中遇到过什么技术难题"><a href="#8-你在项目中遇到过什么技术难题" class="headerlink" title="8. 你在项目中遇到过什么技术难题"></a>8. 你在项目中遇到过什么技术难题</h3><p><strong>问题: 考察解决问题的能力!</strong></p>
<p>话术: 前端要学的东西确实很多，但是并不夸张, 肯多花点时间沉淀一般都会有解决方案</p>
<p>一般遇到难题 (这些前端所谓的难题, 一般都是一些没有做过, 没有尝试过得一些业务),  我们要时刻保持独立思考，</p>
<p><strong>知道自己要做什么业务</strong>，<strong>由此决定要学什么知识</strong>, 然后<strong>实现业务</strong>, 举一反三，总结归纳!</p>
<p>比如1: 如果之前没有做过国际化, 换肤, 没有做过支付, 权限控制,  没有做过即时通信websocket,  excel导入导出, 就会觉得很难, </p>
<p>但其实真正上手花时间去学着做了, 也都能逐步思考解决相关页面, 这些其实也都还 ok</p>
<p>比如2: 有时候, <code>复杂的或者困难的</code>, 并不是技术层面的, 而是<code>业务需求方面</code>的, 需要进行大量树形结构的处理</p>
<p>展示列表式数据时,  展示图表数据时,  筛选条件关联条件多了,  组件与组件的联动关系的控制也比较麻烦, </p>
<p>将联动的条件, 存vuex,  然后 &#x3D;&gt; 进行分模块管理也是比较合适的选择 </p>
<h1 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h1><h2 id="1-nav-bar-组件结构"><a href="#1-nav-bar-组件结构" class="headerlink" title="1.nav-bar 组件结构"></a>1.nav-bar 组件结构</h2><blockquote>
<p>掌握：van-nav-bar组件的基础使用，抽取到 cp-nav-bar 组件，作为通用组件</p>
</blockquote>
<h2 id="2-radio-btn-组件封装"><a href="#2-radio-btn-组件封装" class="headerlink" title="2.radio-btn 组件封装"></a>2.radio-btn 组件封装</h2><blockquote>
<p>实现：按钮组单选框组件</p>
</blockquote>
<h2 id="3-支付抽屉组件封装"><a href="#3-支付抽屉组件封装" class="headerlink" title="3.支付抽屉组件封装"></a>3.支付抽屉组件封装</h2><ul>
<li>组件需要实现哪些功能？<ul>
<li>展示微信支付和支付宝支付，可以选择</li>
<li>展示支付金额，传入订单ID用于生成订单支付链接</li>
<li>打开关闭抽屉</li>
<li>关闭后的业务可自定义</li>
</ul>
</li>
<li>需要暴露哪些 props 参数？<ul>
<li>orderId actualPayment onClose show</li>
</ul>
</li>
<li>需要提供哪些 emits 事件？<ul>
<li>update:show</li>
</ul>
</li>
</ul>
<h2 id="4-将树形的操作内容单独抽提成组件"><a href="#4-将树形的操作内容单独抽提成组件" class="headerlink" title="4.将树形的操作内容单独抽提成组件"></a>4.将树形的操作内容单独抽提成组件</h2><p>**<code>目标</code>**： 将树形的操作内容单独抽提成组件</p>
<p>封装单独的树操作栏组件</p>
<blockquote>
<p>通过第一个章节，我们发现，树形的顶级内容实际和子节点的内容是一致的，此时可以将该部分抽提成一个组件，节省代码</p>
</blockquote>
<h2 id="5-封装一个通用的工具栏"><a href="#5-封装一个通用的工具栏" class="headerlink" title="5.封装一个通用的工具栏"></a>5.封装一个通用的工具栏</h2><p>**<code>目标</code>**：封装一个通用的工具栏供大家使用</p>
<h2 id="6-新增员工的弹层组件"><a href="#6-新增员工的弹层组件" class="headerlink" title="6.新增员工的弹层组件"></a>6.新增员工的弹层组件</h2><h2 id="7-个人详情组件和岗位详情组件封装"><a href="#7-个人详情组件和岗位详情组件封装" class="headerlink" title="7.个人详情组件和岗位详情组件封装"></a>7.个人详情组件和岗位详情组件封装</h2><h2 id="8-封装上传图片组件"><a href="#8-封装上传图片组件" class="headerlink" title="8.封装上传图片组件"></a>8.封装上传图片组件</h2></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">kilito</div><div class="post-copyright__author_desc">生活明朗,万物可爱</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://ekilito.github.io/posts/3936.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://ekilito.github.io/posts/3936.html')">sxms</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://ekilito.github.io/posts/3936.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=sxms&amp;url=https://ekilito.github.io/posts/3936.html&amp;pic=https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ekilito.github.io" target="_blank">kilito</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/883eae6.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/09/04/64f5e41cda997.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智慧园区后台</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/01/64c884ccc8322.png" ait="status"/></div></div><div class="author-info__description">以欢喜心，慢度日常，四季清宁，万物可爱.</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">kilito</h1><div class="author-info__desc">生活明朗,万物可爱</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ekilito" target="_blank" title="github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/194984444" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://cdn.jsdelivr.net/gh/ekilito/picgoblog/img/weixinhao.jpg" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://res.abeim.cn/api/qq/?qq=2856509748" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-qq"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://m.weibo.cn/u/7520593701" target="_blank" title="微博"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weibo"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://music.163.com/#/user/home?id=573476405" target="_blank" title="网易云"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">🍧今天也是元气满满的一天呢~ 开心一点！🍧</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80"><span class="toc-text">前端基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-h5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Fcss3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">1.h5的新特性？css3的新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">2.盒子水平垂直居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">3.css选择器优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-rem%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.rem的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-position"><span class="toc-text">5.position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%B5%AE%E5%8A%A8-float"><span class="toc-text">6.浮动 float</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">7. 伪类和伪元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">8.css预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-vw%E9%80%82%E9%85%8D"><span class="toc-text">9.vw适配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-margin%E2%80%9C%E5%A1%8C%E9%99%B7%E2%80%9D%EF%BC%9F"><span class="toc-text">10.如何解决 margin“塌陷”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E9%80%9A%E8%BF%87-CSS-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-text">11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-z-index%EF%BC%9F"><span class="toc-text">12. 如何理解 z-index？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-flex-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">13. 谈谈你对 flex 的理解？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-let-var-const%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. let var const的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">2. js数据类型，区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-slice-%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%E3%80%81splice%E6%98%AF%E5%90%A6%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-text">3.slice 是干嘛的、splice是否会改变原数组？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">4.数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">5. Javascript 创建对象的几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">6. 如何区分数组和对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">7. 作用域和作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-map-%E5%92%8C-forEach-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8. map 和 forEach 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-js%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">9. js遍历对象的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2"><span class="toc-text">10. new操作符具体干了什么呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-text">11.类数组转换为数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-js-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">12.简单说说 js 中有哪几种内存泄露的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-promise%E5%92%8C-async-await-%E5%8C%BA%E5%88%AB"><span class="toc-text">13. promise和 async await 区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-defer%E5%92%8Casync%E5%8C%BA%E5%88%AB"><span class="toc-text">14. defer和async区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">15. 同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">16. null 和 undefined 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-call-appy-bind%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">17. call appy bind的作用和区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-this%E6%8C%87%E5%90%91%EF%BC%88%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">18. this指向（普通函数、箭头函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E7%BB%A7%E6%89%BF"><span class="toc-text">19. 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-promise"><span class="toc-text">20. promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81JavaScript-%E5%86%85%E7%BD%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">21、JavaScript 内置的常用对象有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E8%B0%88%E8%B0%88%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">22.谈谈事件委托的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-text">23.什么是闭包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">24.for in 和 for of 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81split%EF%BC%88%EF%BC%89%E5%92%8C-join%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">25、split（）和 join（）的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">26.深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">27.原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">28.防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-ES6"><span class="toc-text">29.ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E4%BB%8B%E7%BB%8D%E4%B8%8B-Set%E3%80%81Map-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">30.介绍下 Set、Map 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-async-await"><span class="toc-text">31.async await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-cookie-sessionStorage-localStorage%E5%8C%BA%E5%88%AB"><span class="toc-text">1.cookie sessionStorage localStorage区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">2. 浏览器输入URL发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">3. 浏览器是如何渲染页面的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%87%8D%E7%BB%98%E3%80%81%E9%87%8D%E6%8E%92"><span class="toc-text">4. 重绘、重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-loop%EF%BC%89"><span class="toc-text">5. 事件循环（Event loop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B7%A8%E5%9F%9F"><span class="toc-text">6. 跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81code%E7%A0%81"><span class="toc-text">7.常见code码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. http 和 https 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">9. 前端优化策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-websocket"><span class="toc-text">10.介绍一下 websocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-webpack"><span class="toc-text">11.webpack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Get-%E5%92%8C-Post-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">12.Get 和 Post 的区别以及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-HTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E2%BD%85%E6%B3%95%EF%BC%9F"><span class="toc-text">13. HTTP有哪些⽅法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%90%84%E4%B8%AAHTTP%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">14. 各个HTTP方法的具体作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">1.谈谈你对 Vue 生命周期的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-keep-alive"><span class="toc-text">2. keep-alive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">3. 数据双向绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">4. 路由守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Vuex"><span class="toc-text">5. Vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E2%BD%97%E3%80%81%E2%BC%A6%EF%BC%89"><span class="toc-text">6. 组件通讯（⽗、⼦）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-text">7. 怎么定义vue-router的动态路由？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-0%E5%92%8C3-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. 2.0和3.0的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-computed-%E4%B8%8E-watch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9. computed 与 watch 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Route%E5%92%8Crouter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10.Route和router的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-vue-router-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E2%BC%8F%E7%A7%8D%EF%BC%9F"><span class="toc-text">11.vue-router 路由模式有⼏种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Object-defineProperty-%E5%92%8C-Proxy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12. Object.defineProperty 和 Proxy 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-vue3-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">13. vue3 新特性有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-v-show-%E4%B8%8E-v-if-%E5%8C%BA%E5%88%AB"><span class="toc-text">14. v-show 与 v-if 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-vue%E4%B8%ADv-if%E5%92%8Cv-for%E4%BC%98%E5%85%88%E7%BA%A7%E5%9C%A8vue2%E5%92%8Cvue3%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">15. vue中v-if和v-for优先级在vue2和vue3中的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-script-setup-%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">16. script setup 是干啥的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-reactive%E4%B8%8Eref%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">17. reactive与ref的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-v-model%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">18. v-model的使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-vuex%E4%B8%AD%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">19. vuex中的辅助函数怎么使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-slot%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">20. slot是什么？有什么作用？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-nextTick%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">21. $nextTick的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-v-for%E4%B8%AD%E7%9A%84key"><span class="toc-text">22. v-for中的key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-data%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-text">23.data必须是一个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%8F%82%EF%BC%9F"><span class="toc-text">24.编程式导航，如何跳转传参？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E4%BB%80%E4%B9%88%E6%98%AF-M-V-VM"><span class="toc-text">25. 什么是 M V  VM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">26. MVVM的优缺点有哪些？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%86%E6%9E%90%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.分析登录流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">2.登录模块业务实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BB%E9%A1%B5%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">3.主页模块的实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-text">4.登录流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%99%BA%E6%85%A7%E5%9B%AD%E5%8C%BA"><span class="toc-text">5.智慧园区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD"><span class="toc-text">1.搜索功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-excel%E5%AF%BC%E5%87%BA"><span class="toc-text">2.excel导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">3.网络请求的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%A4%9F%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5"><span class="toc-text">4.后端返回数据字段不够前端自定义字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%91%E7%8A%B6%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">5.树状组件怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%B0%E4%BD%8F%E6%88%91%E4%BC%98%E5%8C%96"><span class="toc-text">6.记住我优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%B8%B2%E6%9F%93"><span class="toc-text">7.数据基础渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%97%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B8%B2%E6%9F%93"><span class="toc-text">8.列表基础渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%8A%B6%E6%80%81%E9%80%82%E9%85%8D"><span class="toc-text">9.状态适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87"><span class="toc-text">10.上传图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%8F%9C%E5%8D%95%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="toc-text">11.菜单路由控制权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%8C%89%E9%92%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="toc-text">12.按钮控制权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-text">13.微前端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">开发中遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-refresh-token"><span class="toc-text">1.refresh_token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0vant%E7%BB%84%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%92%8C%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5"><span class="toc-text">2.实现vant组件自动按需加载，和自动导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-vueuse-core"><span class="toc-text">3.@vueuse&#x2F;core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%81%E9%80%9F%E9%97%AE%E8%AF%8A"><span class="toc-text">4.极速问诊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%97%AE%E8%AF%8A%E5%AE%A4-websocket%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.问诊室-websocket介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Vue-%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86"><span class="toc-text">6. Vue 项目权限处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-%E6%89%93%E5%8C%85%E5%87%BA%E6%9D%A5%E7%9A%84%E9%A1%B9%E7%9B%AE-%E9%A6%96%E5%B1%8F-%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">7. 如何处理 打包出来的项目(首屏)加载过慢的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E9%9A%BE%E9%A2%98"><span class="toc-text">8. 你在项目中遇到过什么技术难题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">组件封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-nav-bar-%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1.nav-bar 组件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-radio-btn-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">2.radio-btn 组件封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%94%AF%E4%BB%98%E6%8A%BD%E5%B1%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">3.支付抽屉组件封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B0%86%E6%A0%91%E5%BD%A2%E7%9A%84%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9%E5%8D%95%E7%8B%AC%E6%8A%BD%E6%8F%90%E6%88%90%E7%BB%84%E4%BB%B6"><span class="toc-text">4.将树形的操作内容单独抽提成组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-text">5.封装一个通用的工具栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%96%B0%E5%A2%9E%E5%91%98%E5%B7%A5%E7%9A%84%E5%BC%B9%E5%B1%82%E7%BB%84%E4%BB%B6"><span class="toc-text">6.新增员工的弹层组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%AA%E4%BA%BA%E8%AF%A6%E6%83%85%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B2%97%E4%BD%8D%E8%AF%A6%E6%83%85%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">7.个人详情组件和岗位详情组件封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B0%81%E8%A3%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%BB%84%E4%BB%B6"><span class="toc-text">8.封装上传图片组件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3936.html" title="sxms"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="sxms"/></a><div class="content"><a class="title" href="/posts/3936.html" title="sxms">sxms</a><time datetime="2023-10-13T06:43:53.500Z" title="发表于 2023-10-13 14:43:53">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/883eae6.html" title="智慧园区后台"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/09/04/64f5e41cda997.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智慧园区后台"/></a><div class="content"><a class="title" href="/posts/883eae6.html" title="智慧园区后台">智慧园区后台</a><time datetime="2023-09-04T14:01:29.006Z" title="发表于 2023-09-04 22:01:29">2023-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f82ea27.html" title="Vue原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2022/07/17/62d4106238e7c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue原理"/></a><div class="content"><a class="title" href="/posts/f82ea27.html" title="Vue原理">Vue原理</a><time datetime="2023-08-20T08:31:26.861Z" title="发表于 2023-08-20 16:31:26">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/undefined.html" title="设计模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2022/11/30/6386ccb347d84.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/undefined.html" title="设计模式">设计模式</a><time datetime="2023-08-19T08:57:01.871Z" title="发表于 2023-08-19 16:57:01">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/882eae5.html" title="JS原理二"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/02/20/63f371a777341.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS原理二"/></a><div class="content"><a class="title" href="/posts/882eae5.html" title="JS原理二">JS原理二</a><time datetime="2023-08-17T13:09:03.001Z" title="发表于 2023-08-17 21:09:03">2023-08-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:2856509748@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/7520593701" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://res.abeim.cn/api/qq/?qq=2856509748" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/ekilito" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/194984444" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAAyFaeLYIe730NcTBynr1H-tGRx3EfYELNjx05MMP4pEc" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/糖果屋-营业中-6adea8?style=social&amp;logo=cakephp" alt="小小清" title="小小清"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2023 By <a class="footer-bar-link" href="/" title="kilito" target="_blank">kilito</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期.","你今天真好看！","今天也是元气满满的一天呢！","以欢喜心&#44;慢度日常&#44;四季清宁&#44;万物可爱."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.0.15/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/ekilito/blog" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://7bu.top/" title="图床">图床</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://wudl.cn" title="主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/48.png" alt="主页"/><span class="back-menu-item-text">主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.wudl.cn" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://ccv-engineer.gitee.io/" title="旧站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/32.png" alt="旧站"/><span class="back-menu-item-text">旧站</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://7bu.top/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tag faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://chatgpt.wudl.cn"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> ChatGPT</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://gpt.zhizhubao.com/chat"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 私人助理</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=891137324&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/kongtiao/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zaobao/"><span> 早报</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Generato/" style="font-size: 0.88rem;">Generato<sup>1</sup></a><a href="/tags/fetch/" style="font-size: 0.88rem;">fetch<sup>1</sup></a><a href="/tags/koa/" style="font-size: 0.88rem;">koa<sup>1</sup></a><a href="/tags/this/" style="font-size: 0.88rem;">this<sup>1</sup></a><a href="/tags/vue%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">vue原理<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99/" style="font-size: 0.88rem;">手写<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99Promise/" style="font-size: 0.88rem;">手写Promise<sup>1</sup></a><a href="/tags/%E6%99%BA%E6%85%A7%E5%9B%AD%E5%8C%BA/" style="font-size: 0.88rem;">智慧园区<sup>1</sup></a><a href="/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/" style="font-size: 0.88rem;">柯里化<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>1</sup></a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 0.88rem;">继承<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7061615494" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/user/home?id=573476405&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script> // 消除控制台打印
 var HoldLog = console.log;
 console.log = function () {};
 let now1 = new Date();
 queueMicrotask(() => {
   const Log = function () {
     HoldLog.apply(console, arguments);
   }; //在恢复前输出日志
   const grt = new Date("08/04/2023 20:00:00"); //此处修改你的建站时间或者网站上线时间
   now1.setTime(now1.getTime() + 250);
   const days = (now1 - grt) / 1000 / 60 / 60 / 24;
   const dnum = Math.floor(days);
   const ascll = [
     `欢迎来到ekilito🥝の小窝!`,
     `Future is now 🍭🍭🍭`,
     `
         
  
██    ██   ██   ██        ██   ████████    ██████  
██  ██     ██   ██        ██      ██      ██    ██ 
████       ██   ██        ██      ██      ██    ██ 
██  ██     ██   ██        ██      ██      ██    ██ 
██    ██   ██   ███████   ██      ██       ██████  
         
         `,
     "已上线",
     dnum,
     "天",
     "©2022 By kilito V1.6.6",
   ];
   const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

   setTimeout(
     Log.bind(
       console,
       `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
       "color:#3b70fc",
       "",
       "color:#3b70fc",
       "color:#3b70fc",
       "",
       "color:#3b70fc",
       ""
     )
   );
   setTimeout(
     Log.bind(
       console,
       `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
       "color:white; background-color:#4fd953",
       "",
       "",
       'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
     )
   );

   setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

   setTimeout(
     console.warn.bind(
       console,
       "%c ⚡ Powered by 小小清 %c 你正在访问 kilito 的博客.",
       "color:white; background-color:#f0ad4e",
       ""
     )
   );

   setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

   setTimeout(
     console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
   );
 });</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("08/04/2023 20:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://img.shields.io/badge/糖果屋-打烊了-6adea8?style=social&amp;logo=coffeescript";
      img.title = "小小清";
      img.alt = "小小清";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.wudl.cn/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.wudl.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.wudl.cn/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "longlong1015@outlook.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/gghello.js"></script><script src="/js/iconfont.js"></script><script src="/js/cursur.js"></script><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="/js/fps.js"></script><div id="fps"></div><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>