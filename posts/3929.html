<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>八股文 | kilito</title><meta name="keywords" content="面试,前端,八股文"><meta name="author" content="kilito"><meta name="copyright" content="kilito"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="八股文"><meta name="application-name" content="八股文"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="八股文"><meta property="og:url" content="https://ekilito.github.io/posts/3929.html"><meta property="og:site_name" content="kilito"><meta property="og:description" content="每天一道面试题。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp"><meta property="article:author" content="kilito"><meta property="article:tag" content="个人博客,kilito,小清"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp"><meta name="description" content="每天一道面试题。"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://ekilito.github.io/posts/3929"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走嘛！","backTitle":"♪(^∇^*)欢迎回来！"},
  LA51: {"enable":true,"ck":"3FXVpXQlU2qrgdld","LingQueMonitorID":"3FXVpXQlU2qrgdld"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.wudl.cn/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"30796eace3084cff910c7e43aa524164","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://puquan.wudl.cn/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: kilito","link":"链接: ","source":"来源: kilito","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'kilito',
  title: '八股文',
  postAI: '',
  pageFillDescription: '前端基础, 1.2 h5新特性, 1.3 伪类和伪元素, 1.5 引入样式时link和@import的区别？, 1.10 元素的alt和title有什么不同？, 1.15 a标签中 如何禁用href 跳转页面 或 定位链接?, 1.19 前端需要注意哪些SEO, CSS, 1.1 标准盒模型和IE盒模型两者的区别是什么？, 1.2 盒子塌陷是什么？, 1.4 行内元素可以设置paddingmargin吗？, 1.6 BFC是什么？, 1.7 块元素居中, 1.8 CSS 优化、提高性能的方法有哪些？, 1.11 浏览器是怎样解析CSS选择器的？, 1.13 display、position和float的相互关系？, 1.14 IFC 是什么？, 1.15 为什么不建议使用通配符初始化 css 样式, 1.16 CSS3 新特新, 1.18 什么是CSS 预处理器？为什么使用？, 1.19 浏览器是怎样解析的？, 1.23 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？, 1.24 displayinline-block 什么时候会显示间隙？, 1.27 before 和after 中双冒号和单冒号有什么区别、作用？, 1.29 未知高度元素垂直居中、垂直居中的实现方式有哪些？, 1.34 移动端适配方案, JavaScript, 1.1 let var const的区别？, 1.2 js数据类型区别, 1.3 Javascript 创建对象的几种方式？, 1.4 x3Dx3D、x3Dx3Dx3D和object.is 区别, 1.5 如何区分数组和对象？, 1.6 作用域和作用域链, 1.7 constructor的理解, 1.10 map 和 forEach 的区别？, 1.11 for of 可以遍历哪些对象？, 1.11 js遍历对象的方法？, 1.13 new操作符具体干了什么呢?, 1.14 作用域, 1.15 javascript中arguments相关的问题, 1.16 instanceOf作用 即原理, 1.17 数组和伪数组的区别?, 1.19 简单说说 js 中有哪几种内存泄露的情况, 1.23 promise和 async await 区别?, 1.24 defer和async区别?, 1.25 同步和异步, 1.27 null 和 undefined 的区别如何让一个属性变为null, 1.29 call appy bind的作用和区别？, 1.30 this指向（普通函数、箭头函数）, 1.32 继承优缺点 及方法有哪些？, 1.32.1原型链继承, 1.32.2 构造函数继承, 1.32.3 组合继承, 1.32.4 原型式继承, 1.32.5 寄生式继承, 1.32.6 寄生组合式继承, 1.32.7 ES6 class extends, 1.33 扩展运算符 …, 1.33.1哪些类型能被扩展操作符?, 1.33.2 场景, 1.34 实现异步的方法, 1.34.1 回调函数, 1.34.2 promise, 1.34.3 生成器generatorx2Fyield, 1.34.3 asyncx2Fawait, 1.36 为什么js是单线程, 1.37 死锁, 1.38 暂时性死区, 浏览器, 1.1 cookie sessionStorage localStorage 区别, 1.2 如何写一个会过期的localStorage说说想法, 1.3 localStorage 能跨域吗, 1.4 memory cache 如何开启, 1.5 localstorage的注意哪些问题, 1.6 浏览器输入URL发生了什么, 1.7 浏览器是如何渲染页面的？, 1.8 重绘、重排, 1.9 事件循环（Event loop）, 1.10 let a x3D 1 挂载在哪里？, 1.11 浏览器垃圾回收机制, 1.12 cookie, 1.13 调试工具, a.谷歌浏览器, b.其他, 网络传输, 1.1 跨域, 1.2 有什么方法可以保持前后端通信, 算法, 1.1 顺序存储结构和链式存储结构, Vue, 1.1 怎样理解 Vue 的单向数据流？, 1.2 谈谈你对 Vue 生命周期的理解？, 1.3 谈谈你对 keep-alive 的了解？, 1.4 组件中 data 为什么是一个函数？, 1.5 你对vue项目哪些优化？, 1.6 vue中的key有什么作用？, 1.7 虚拟dom的优缺点, 1.8 虚拟dom实现原理？, 1.9 Vue 是如何实现数据双向绑定的？, 1.20 Vue-router 有哪几种路由守卫?, 1.21 Vue-router 的钩子函数都有哪些?, 1.22 vue-router 路由模式有几种？, 1.23 说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？, 1.24 vuex 包括几个模块, 1.25 Object.defineProperty 和 Proxy 的区别, 1.26 MVVM 和 MVC 区别是什么？哪些场景适合？, 1.27 vue 中如何重置 data?, 1.28 vue3 新特性有哪些？, 1.29 vue3 组合式API生命周期钩子函数有变化吗?, 1.30 watch 和 watchEffect 的区别？, 1.31 vue中v-if和v-for优先级在vue2和vue3中的区别, 1.32 script setup 是干啥的？, 1.33 vue常用的修饰符, 1.34 vue2.0 和 vue3.0 有什么区别？ 双向绑定更新, 1.35 reactive与ref的区别？, 1.36 $route 和 $router 的区别？, 1.37 v-on可以监听多个方法吗？, 1.38 v-model的使用？, 1.39 vue遇到的坑如何解决的？, 1.40 说说vue中的diff算法？, 1.41 vue中怎么设置全局变量和全局组件？, 1.45 vue中给对象添加新属性时界面不刷新怎么办?, 1.46 vuex中的辅助函数怎么使用？, 1.47 刷新浏览器后Vuex的数据是否存在？如何解决？, x201.48 vue路由跳转传参的方式有哪些？, 1.50 单页面应用和多页面应用区别及优缺点？, 1.51 EventBus注册在全局上时路由切换时会重复触发事件如何解决呢？, 1.52 自定义指令详解, 1.53 slot是什么？有什么作用？原理是什么？, 1.54 $nextTick的使用, React, 1.1 虚拟dom和真实dom, 1.2 react组件间通信, 1.3 redux的原理, 1.4 React组件生命周期的阶段是什么？, 1.5 详细解释React 组件的生命周期方法, 1.6 router, 1.7 React 的 refs 有什么了解？, 1.8 列出一些应该使用 Refs 的情况, 1.9 redux-saga和mobx的比较, 1.10 简述一下 React 的源码实现, 1.11 setState到底是异步还是同步, 1.12  redux异步中间件之间的优劣?, 1.13 state 和 props 区别是啥？, 1.14  当调用setState时React render 是如何工作的？, 1.15 hooks, Hooks简介, Hook函数（9种）, 自定义Hooks, 打包工具, 1.1 前端为什么要进行打包和构建, 1.2 如何提高webpack的构建速度, 1.3 代码分割的本质是什么？, 1.4webpack的基本功能有哪些？, 1.5 文件指纹是什么？, x201.6 为什么说vite比webpack更快？, 1.7 vite工作原理, x201.8 vite核心原理, 1.9 Vite 冷启动为什么快, 1.10 vite生产环境缺点, x201.11 vite和webpack优缺点对比前端基础新特性新增选择器拖拽释放媒体播放的和本地存储和离线应用桌面通知语意化标签增强表单控件地理位置多任务全双工通信协议历史管理跨域资源共享页面可见性改变事件跨窗口通信对象绘画伪类和伪元素伪类用于已有元素处于某种状态时为其添加对应的样式这个状态是根据用户行为而动态变化的伪元素用于创建一些不在树中的元素并为其添加样式例如我们可以通过语义化优点易于用户阅读样式丢失的时候能让页面呈现清晰的结构有利于搜索引擎根据标签来确定上下文和各个关键字的权重方便屏幕阅读器解析如盲人阅读器根据语义渲染网页有利于开发和维护语义化更具可读性代码更好维护与关系更和谐引入样式时和的区别链接样式时只能在页面中引入外部样式导入样式表时既可以在页面中导入外部样式也可以在样式文件中导入外部样式元素的和有什么不同在和同时设置的时候作为图片的替代文字出现是图片的解释文字标签中如何禁用跳转页面或定位链接前端需要注意哪些合理的搜素时对这三项的权重逐个减少强调重点重要关键词不要超过两次而且要靠前不同页面要有所不同高度概括页面内容长度合适不过分堆砌关键词不同页面有所不同列出重要关键词即可语义化的代码符合标准提高网站速度重要代码放前面重要内容不要用输出爬虫不会执行获取内容少用搜索引擎不会抓取中的内容非装饰性图片必须加网站的标准盒模型和盒模型两者的区别是什么概念盒模型本质上是一个盒子封装周围的元素它包括外边距边框内边距实际内容四个属性设置盒子模型标准区别标准的盒模型元素的实际宽度等于设置的宽高默认方式盒模型元素的实际宽度就等于设置的宽高即使定义有和也不会改变元素的实际宽度即盒子塌陷是什么盒子塌陷本应该在父盒子内部的元素跑到了外部为什么会出现盒子塌陷当父元素没设置足够大小的时候而子元素设置了浮动的属性子元素就会跳出父元素的边界脱离文档流尤其是当父元素的高度为时而父元素中又没有其它非浮动的可见元素时父盒子的高度就会直接塌陷为零我们称这是高度塌陷解决塌陷的方法设置宽高设置清楚浮动给父盒子添加给父盒子设置行内元素可以设置吗行内元素的左右有效上下无效行内元素的左右有效但是由于设置上下不占页面空间无法显示效果所以无效是什么文档有几种流定位流绝对定位方案盒从常规流中被移除不影响常规流的布局它的定位相对于它的包含块相关属性如果元素的属性为或它是绝对定位元素对于元素定位将相对于上级元素中最近的一个如果没有则相对于浮动流左浮动元素尽量靠左靠上右浮动同理这导致常规流环绕在它的周边除非设置属性浮动元素不会影响块级元素的布局但浮动元素会影响行内元素的布局让其围绕在自己周围撑大父级元素从而间接影响块级元素布局最高点不会超过当前行的最高点它前面的浮动元素的最高点不超过它的包含块除非元素本身已经比包含块更宽行内元素出现在左浮动元素的右边和右浮动元素的左边左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的普通流在常规流中盒一个接着一个排列在块级格式化上下文里面它们竖着排列在行内格式化上下文里面它们横着排列当为或并且为时会触发常规流对于静态定位盒的位置是常规流布局里的位置对于相对定位盒偏移位置由属性定义即使有偏移仍然保留原有的位置其它常规流不能占用这个位置定义的基本概念就是块级格式化上下文的意思也有译作块级格式化范围通俗的讲就是一个特殊的块内部有自己的布局方式不受外边元素的影响布局规则内部的会在垂直方向一个接一个地放置垂直方向上的距离由决定完整的说法是属于同一个的两个相邻的会发生重叠塌陷与方向无关每个元素的左外边距与包含块的左边界相接触从左向右即使浮动元素也是如此这说明中子元素不会超出他的包含块而为的元素可以超出他的包含块边界的区域不会与的元素区域重叠计算的高度时浮动子元素也参与计算就是页面上的一个隔离的独立容器容器里面的子元素不会影响到外面元素反之亦然哪些元素会创建根元素属性不为为或为不为场景清除元素内部浮动只要把父元素设为就可以清理子元素的浮动了最常见的用法就是在父元素上设置样式对于加上就可以了计算的高度时自然也会检测浮动或者定位的盒子高度解决外边距合并问题嵌套崩塌外边距合并的问题盒子垂直方向的距离由决定属于同一个的两个相邻盒子的会发生重叠属于同一个的两个相邻盒子的会发生重叠那么我们创建不属于同一个就不会发生重叠了制作右侧自适应的盒子问题普通流体元素后为了和浮动元素不产生任何交集顺着浮动边缘形成自己的封闭上下文块元素居中我们可以利用来实现元素的水平居中利用绝对定位设置四个方向的值都为并将设置为由于宽高固定因此对应方向实现平分可以实现水平和垂直方向上的居中利用绝对定位先将元素的左上角通过和定位到页面的中心然后再通过负值来调整元素的中心点到页面的中心利用绝对定位先将元素的左上角通过和定位到页面的中心然后再通过来调整元素的中心点到页面的中心使用布局通过和设置容器的垂直和水平方向上为居中对齐然后它的子元素也可以实现垂直和水平的居中对于宽高不定的元素后面两种方法可以实现元素的垂直和水平的居中优化提高性能的方法有哪些加载性能压缩将写好的进行打包压缩可以减小文件体积单一样式当需要下边距和左边距的时候很多时候会选择使用减少使用建议使用因为后者在页面加载时一起加载前者是等待页面加载完成之后再进行加载选择器性能关键选择器选择器的最后面的部分为关键选择器即用来匹配目标元素的部分选择符是从右到左进行匹配的当使用后代选择器的时候浏览器会遍历所有子元素来确定是否是指定的元素等等如果规则拥有选择器作为其关键选择器则不要为规则增加标签过滤掉无关的规则这样样式系统就不会浪费时间去匹配它们了尽量少的去对标签进行选择而是用尽量少的去使用后代选择器降低选择器的权重值后代选择器的开销是最高的尽量将选择器的深度降到最低最高不要超过三层更多的使用类来关联每一个标签元素了解哪些属性是可以通过继承而来的然后避免对这些属性重复指定规则渲染性能属性值为时不加单位可以省略小数点之前的标准化各种浏览器前缀带浏览器前缀的在前标准属性在后选择器优化嵌套尽量避免层级过深雪碧图同一页面相近部分的小图标方便使用减少页面的请求次数但是同时图片本身会变大使用时优劣考虑清楚再使用不滥用字体对于中文网站来说可能很陌生国外却很流行通常体积庞大而且一些浏览器在下载时会阻塞页面渲染损伤性能可维护性健壮性将具有相同属性的样式抽离出来整合并通过在页面中进行使用提高的可维护性样式与内容分离将代码定义到外部中浏览器是怎样解析选择器的选择器的解析是从右向左解析的原因从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点叶子节点而从左向右的匹配规则的性能都浪费在了失败的查找上面和的相互关系首先我们判断属性是否为如果为则和属性的值不影响元素最后的表现然后判断的值是否为或者如果是则属性失效并且的值应该被设置为或者具体转换需要看初始转换值如果的值不为或者则判断属性的值是否为如果不是则的值则按上面的规则转换注意如果的值为并且属性的值存在则相对于浮动后的最终位置定位如果的值为则判断元素是否为根元素如果是根元素则属性按照上面的规则转换如果不是则保持指定的属性值不变总的来说可以把它看作是一个类似优先级的机制和优先级最高有它存在的时候浮动不起作用的值也需要调整其次元素的特性的值不是的时候或者它是根元素的时候调整的值最后非根元素并且非浮动元素并且非绝对定位的元素特性值同设置值是什么指的是行级格式化上下文它有这样的一些布局规则行级上下文内部的盒子会在水平方向一个接一个地放置当一行不够的时候会自动切换到下一行行级上下文的高度由内部最高的内联盒子的高度决定为什么不建议使用通配符初始化样式采用这样的写法好处是写起来很简单但是是通配符需要把所有的标签都遍历一遍当网站较大时样式比较多这样写就大大的加强了网站运行的负载会使网站加载的时候需要很长一段时间因此一般大型的网站都有分层次的一套初始化样式出于性能的考虑并不是所有标签都会有和因此对常见的具有默认和的元素初始化即可并不需使用通配符来初始化新特新新增各种选择器选择每个非的元素选择每个没有任何子级的元素包括文本节点边框背景规定背景图的绘制区域线性渐变向下向上向左向右对角方向文本效果阴影转换转换是向元素应用或者转换过渡动画多列布局盒模型布局多媒体查询定义两套当浏览器的尺寸变化时会采用不同的属性什么是预处理器为什么使用用来预编译或增强了代码的复用性还有层级变量循环函数等具有很方便的组件模块化开发能力极大的提高工作效率为什么要使用可嵌套性变量混合可重用性高可以注入任何东西允许一个选择器继承另一个选择器函数功能用户使用可以去编写自己的函数引用父元素在编译时将被替换成父选择符计算功能组合连接变量连接字符串循环语句很少用到语句很少用到浏览器是怎样解析的被解析器解析成树被解析器解析成树结合树和树生成一棵渲染树这一过程称为生成布局浏览器在屏幕上画出渲染树中的所有节点将布局绘制在屏幕上显示出整个页面与之间有看不见的空白间隔是什么原因引起的有什么解决办法行框的排列会受到中间空白回车空格等的影响因为空格也属于字符这些空白也会被应用样式占据空间所以会有间隔把字符大小设为就没有空格了解决方法可以将代码全部写在一排浮动中在中用谷歌不支持可以将什么时候会显示间隙有空格时候会有间隙解决除空格正值的时候解决使用负值使用时候解决和中双冒号和单冒号有什么区别作用区别在中伪类一直用表示如等伪元素在中已存在当时语法使用表示如和后来在中修订伪元素用表示如和以此区分伪元素和伪类由于低版本对双冒号不兼容开发者为了兼容性各浏览器继续使使用这种老语法表示伪元素单冒号表示伪类双冒号伪元素未知高度元素垂直居中垂直居中的实现方式有哪些绝对定位的布局布局移动端适配方案适配屏幕的宽度设计稿的宽度为了适配其他屏幕需要动态的设置的值屏幕翻转时再次执行缺点边线问题不同尺寸下边线的粗细是不一样的等比缩放后全部元素都是等比缩放实际显示效果可能不太好适配部分等比缩放开发者拿到设计稿假设设计稿尺寸为设计稿的元素标注是基于此宽度标注开始开发对设计稿的标注进行转换把换成比如页面元素字体标注的大小是换成为对于需要等比缩放的元素使用转换后的单位对于不需要缩放的元素比如边框阴影使用固定单位像素等于多少适配弹性盒适配合理布局的区别变量声明方式在变量未赋值时变量为使用声明变量时也为作用域的作用域为方法作用域只要在方法内定义了整个方法内的定义变量后的代码都可以使用变量声明方式在变量为声明前直接使用会报错作用域为块级作用域通常比范围要小进制重复声明变量否则会报错可以重复声明变量声明为常量声明方式声明变量时必须初始化在后面出现的代码中不能再修改常量的值实际上保证的并不是变量的值不得改动而时变量指向的哪个内存地址不得改动数据类型区别基本数据类型引用数据类型普通对象数组对象正则对象日期对象数学函数对象创建对象的几种方式简单对象的创建使用对象字面量的方式一个使用工厂方式来创建关键字使用创建对象使用现有对象作为原型使用中的类创建对象其实质还是使用构造函数和区别值比较值值和类型都比较和区别如何区分数组和对象通过中的通过来识别通过调用来识别返回返回通过方法来识别作用域和作用域链作用域就是一个独立的地盘让变量不会外泄暴露出去也就是说作用域最大的用处就是隔离变量不同作用域下同名变量不会有冲突之前没有块级作用域只有全局作用域和函数作用域的到来为我们提供了块级作用域可通过新增命令和来体现什么是作用域链当代码在一个环境中执行时会创建变量对象的一个作用域链由子级作用域返回父级作用域中寻找变量就叫做作用域链作用域链中的下一个变量对象来自包含环境也叫外部环境而再下一个变量对象则来自中的最后一个对象作用域链前端始终都是当前执行的代码所在环境的变量对象如果环境是函数则将其活动对象作为变量对象如何延长作用域链执行环境的类型只有两种全局和局部函数但是有些语句可以在作用域链的前端临时增加一个变量对象该变量对象会在代码执行后被移除具体来说就是执行这两个语句时作用域链都会得到加强语句的块会创建一个新的变量对象包含的是被抛出的错误对象的声明语句语句会将指定的对象添加到作用域链中的理解创建的每个函数都有一个原型对象这个属性是一个指针指向一个对象在默认情况下所有原型对象都会自动获得一个属性之后属性是一个指向属性坐在函数的指针当调用构造函数创建一个新实例后该实例的内部将包含一个指针指向构造函数的原型对象注意当将构造函数的设置为等于一个以对象字面量形式创建的新对象时属性不再指向该构造函数和的区别相同点都是循环遍历数组中的每一项每次执行匿名函数都支持三个参数参数分别为当前每一项索引值原数组匿名函数中的都是指向只能遍历数组不同点会分配内存空间存储新数组并返回不会返回数据允许更改原始数组的元素返回新的数组可以遍历哪些对象它是新增的一个遍历方法但只限于迭代器所以普通的对象用遍历是会报错的可迭代的对象包括对象等等遍历对象的方法循环方法方法操作符具体干了什么呢创建空对象设置新对象的属性为构造函数的名称设置新对象的属性指向构造函数的对象扩展了新对象的原型链使用新对象调用函数函数中的被指向新实例对象构造函数返回指针当存在显示的返回时返回后面的内容新建的空对象作废作用域作用域就是一个独立的地盘让变量不会外泄暴露出去也就是说作用域最大的用处就是隔离变量不同作用域下同名变量不会有冲突之前没有块级作用域只有全局作用域和函数作用域的到来为我们提供了块级作用域可通过新增命令和来体现中相关的问题在中我们在调用有参数的函数时当往这个调用的有参函数传参时会把所传的参数全部存到一个叫的对象里面它是一个类数组数据作用有了这个对象之后我们可以不用给函数预先设定形参了可以动态地通过为函数加入参数作用即原理主要作用就是判断一个实例是否属于某种类型取右表达式的值取左表达式的值其实主要的实现原理就是只要右边变量的在左边变量的原型链上即可因此在查找的过程中会遍历左边变量的原型链直到找到右边变量的如果查找失败则会返回告诉我们左边变量并非是右边变量的实例数组和伪数组的区别定义数组是一个特殊对象与常规对象的区别当由新元素添加到列表中时自动更新属性设置属性可以截断数组从中继承了方法属性为类数组是一个拥有属性并且他属性为非负整数的普通对象类数组不能直接调用数组方法区别本质类数组是简单对象它的原型关系与数组不同类数组转换为数组转换方法使用使用使用进行属性遍历并组成新的数组简单说说中有哪几种内存泄露的情况意外的全局变量闭包未被清空的定时器未被销毁的事件监听引用和区别概念是异步编程的一种解决方案比传统的解决方案回调函数和事件更合理和更强大简单地说好比容器里面存放着一些未来才会执行完毕异步的事件的结果而这些结果一旦生成是无法改变的也是异步编程的一种解决方案他遵循的是函数的语法糖他拥有内置执行器不需要额外的调用直接会自动执行并输出结果它返回的是一个对象两者的区别的出现解决了传统函数导致的地域回调问题但它的语法导致了它向纵向发展行成了一个回调链遇到复杂的业务场景这样的语法显然也是不美观的而代码看起来会简洁些使得异步代码看起来像同步代码的本质是可以提供等同于同步效果的等待异步返回能力的语法糖只有这一句代码执行完才会执行下一句与一样是非阻塞的是基于实现的可以说是改良版的它不能用于普通的回调函数和区别要等到整个页面在内存中正常渲染结束结构完全生成以及其他脚本执行完成才会执行多个脚本会按照它们在页面出现的顺序加载渲染完再执行一旦下载完渲染引擎就会中断渲染执行这个脚本以后再继续渲染多个脚本是不能保证加载顺序的下载完就执行同步和异步同步指在主线程上排队执行的任务只有前一个任务执行完毕才能继续执行下一个任务也就是调用一旦开始必须这个调用返回结果划重点才能继续往后执行程序的执行顺序和任务排列顺序是一致的异步异步任务是指不进入主线程而进入任务队列的任务只有任务队列通知主线程某个异步任务可以执行了该任务才会进入主线程每一个任务有一个或多个回调函数前一个任务结束后不是执行后一个任务而是执行回调函数后一个任务则是不等前一个任务结束就执行程序的执行顺序和任务的排列顺序是不一致的异步的我们常用的和函数都是异步操作和的区别如何让一个属性变为声明了一个变量但没有赋值访问对象上不存在的属性函数定义了形参但没有传递实参使用对表达式求值是一个空值有属于自己的类型而不属于类型二进制的前三位为会被判断为对象类型的作用和区别作用都可以改变函数内部的指向区别点和会调用函数并且改变函数内部指向和传递的参数不一样传递参数形式必须数组形式不会调用函数可以改变函数内部指向指向普通函数箭头函数谁调用了函数或者方法那么这个函数或者对象中的就指向谁匿名函数中的匿名函数的执行具有全局性则匿名函数中的指向是而不是调用该匿名函数的对象箭头函数中的箭头函数中的是在函数定义的时候就确定下来的而不是在函数调用的时候确定的箭头函数中的指向父级作用域的执行上下文箭头函数无法使用和方法改变指向因为其值在函数定义的时候就被确定下来继承优缺点及方法有哪些继承的好处提高了代码的复用性提高了代码的维护性让类与类之间产生了关系是多态的前提继承的弊端类的耦合性增强了但是开发的原则高内聚低耦合原型链继承实现方式将子类的原型链指向父类的对象实例坤原理子类实例的指向的原型链而指向类的对象实例该父类对象实例的指向所以可继承的构造函数属性方法和原型链属性方法优点可继承构造函数的属性父类构造函数的属性父类原型的属性缺点无法向父类构造函数传参共享父类实例的属性若父类共有属性为引用类型一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化坤构造函数继承实现方式在子类构造函数中使用或者劫持父类构造函数方法并传入参数坤坤原理使用或者改变子类函数的作用域使执行父类构造函数子类因此可以继承父类共有属性优点可解决原型链继承共享的问题缺点不可继承父类的原型方法构造函数不可以被复用组合继承原理综合使用构造函数继承和原型链继承坤坤坤坤坤坤篮球优点可继承父类原型上的属性且可传参每个新实例引入的构造函数是私有的缺点会执行两次父类的构造函数消耗较大内存子类的构造函数会代替原型上的那个父类构造函数原型式继承原理类似用一个函数包装一个对象然后返回这个函数的调用这个函数就变成了个可以随意增添属性的实例或对象结果是将子对象的指向父对象坤坤缺点共享引用数据类型寄生式继承原理扩展原型式继承优点可添加新的属性和方法寄生组合式继承原理改进组合继承利用寄生式继承的思想继承原型复制一份父类的原型修正构造函数设置子类原型扩展运算符哪些类型能被扩展操作符类型数组对象字符串复杂数据类型都可以当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作基础数据只有可以使用扩展运算符无效场景函数调用往数组里多个元素子异坤坤说唱跳子异坤坤说唱跳替代函数的方法的写法的写法求一个数组的最大数简化的写法的写法等同于扩展运算符后面可以放表达式与解构赋值结合用于生成数组写法写法合并数组数组的克隆乍一看与不共用引用地址不随着变化接着往下看实现异步的方法回调函数处理逻辑处理逻辑处理逻辑优点简单容易理解和实现缺点不利阅读和维护耦合度高不能使用捕获不能直接本意是承诺这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了的三种状态对象实例创建时候的初始状态可以理解为成功的状态可以理解为失败的状态无效代码不会执行当我们在构造的时候构造函数内部的代码是立即执行的的链式调用每次调用返回的都是一个新的实例这就是可用链式调用的原因如果中返回的是一个结果的话会把这个结果传递下一次中的成功回调如果中出现异常会走下一个的失败回调在中使用了那么的值会被包装见例中可以不传递参数如果不传递会透到下一个中见例会捕获到没有捕获的异常包装成存在一个缺点无法取消错误需要通过回调函数捕获生成器特点控制函数的执行函数是一个状态机封装了多个内部状态函数除了状态机还是一个遍历器对象生成函数可暂停函数可暂停方法可启动每次返回的是后的表达式结果表达式本身没有返回值或者说总是返回方法可以带一个参数该参数就会被当作上一个表达式的返回值解决回调地狱特点是基于实现的它不能用于普通的回调函数与一样是非阻塞的类似调用方式模拟一个并发请求这个函数同步执行为什么是单线程用途在创立之初主要是应用于用户与浏览器的交互以及操作这一特性决定了只能是单线程否则会带来复杂的同步问题例如如果被设计了多线程如果有一个线程要修改一个元素另一个线程要删除这个这时候就不能处理避免这个问题浏览器就设计了单线程避免了这个麻烦死锁死锁是指两个或两个以上的进程在执行过程中由于竞争资源而造成阻塞的现象若无外力作用它们都将无法继续执行产生原因竞争资源引起进程死锁可剥夺和非剥夺资源竞争非剥夺资源竞争临时性资源进程推进顺序不当产生条件互斥条件涉及的资源是非共享的涉及的资源是非共享的一段时间内某资源只由一个进程占用如果此时还有其它进程请求资源则请求者只能等待直至占有资源的进程用毕释放不剥夺条件不能强行剥夺进程拥有的资源进程已获得的资源在未使用完之前不能被剥夺只能在使用完时由自己释放请求和保持条件进程在等待一新资源时继续占有已分配的资源指进程已经保持至少一个资源但又提出了新的资源请求而该资源已被其它进程占有此时请求进程阻塞但又对自己已获得的其它资源保持不放环路等待条件存在一种进程的循环链链中的每一个进程已获得的资源同时被链中的下一个进程所请求在发生死锁时必然存在一个进程资源的环形链解决办法只要打破四个必要条件中的一个就能有效防止死锁的发生暂时性死区暂时性死区的本质就是只要一进入当前作用域所要使用的变量就已经存在了但是不可获取只有等到声明变量的那一行代码出现才可以获取和使用该变量具有暂时性死区不具有暂时性死区浏览器区别共同点都是保存在浏览器端且同源的区别数据始终在同源的请求中携带即使不需要即在浏览器和服务器间来回传递而和不会自动把数据发送给服务器仅在本地保存数据还有路径的概念可以限制只属于某个路径下存储大小限制也不同数据不能超过同时因为每次请求都会携带所以只适合保存很小的数据如会话标识和虽然也有存储大小的限制但比大得多可以达到或更大数据有效期不同仅在当前浏览器窗口关闭之前有效始终有效窗口或浏览器关闭也一直保存因此用作持久数只在设置的过期时间之前有效即使窗口关闭或浏览器关闭作用域不同不在不同的浏览器窗口中共享即使是同一个页面在所有同源窗口中都是共享的也是在所有同源窗口中都是共享的支持事件通知机制可以将数据更新的通知发送给监听者的接口使用更方便如何写一个会过期的说说想法惰性删除和定时删除惰性删除惰性删除是指某个键值过期后该键值不会被马上删除而是等到下次被使用的时候才会被检查到过期此时才能得到删除增加一个键值对数据键值过期时间单位为秒读取对应键的值数据键对应键的值定时删除定时删除是指每隔一段时间执行一次删除操作随机测试个设置了过期时间的删除所有发现的已过期的若删除的超过个则重复步骤直至重复次初始化遍历所有中的所有找出可过期缓存的随机测试个设置了过期时间的从中删除被惰性删除的删除所有发现的已过期的若删除的不超过个则跳出循环每隔一秒执行一次定时删除能跨域吗不能解决办法通过来实现跨源通信可以实现一个公共的部署在某个域名中作为共享域将需要实现跨域通信的页面嵌入这个如何开启如何开启是一种比较特殊的缓存他不受等配置的影响即使我们不设置缓存如果当前的内存空间比较充裕的话一些资源还是会被缓存下来但这种缓存是暂时的一旦关闭了浏览器这一部分用于缓存的内存空间就会被释放掉如果真的不想使用缓存可以设置这样即便是内存缓存也不会生效的注意哪些问题兼容性问题在浏览器的隐私模式下面是不可读取的本质上是对字符串的读取如果存储内容多的话会消耗内存空间会导致页面变卡不能被爬虫抓取到浏览器输入发生了什么解析查询连接处理请求接受响应渲染页面浏览器是如何渲染页面的不同浏览器内核渲染机制有所区别被解析器解析成树被解析器解析成树结合树和树生成一棵渲染树这一过程称为生成布局浏览器在屏幕上画出渲染树中的所有节点将布局绘制在屏幕上显示出整个页面重绘重排概念重排当渲染树的一部分必须更新并且节点的尺寸发生了变化浏览器会使渲染树中受到影响的部分失效并重新构造渲染树重绘是在一个元素的外观被改变所触发的浏览器行为浏览器会根据元素的新属性重新绘制使元素呈现新的外观比如改变某个元素的背景色文字颜色边框颜色等等区别重绘不一定需要重排比如颜色的改变重排必然导致重绘比如改变网页位置引发重排添加删除可见的元素的位置改变元素的尺寸改变外边距内边距边框厚度宽高等几何属性页面渲染初始化浏览器窗口尺寸改变获取某些属性当获取一些属性时浏览器为取得正确的值也会触发重排它会导致队列刷新这些属性包括所以在多次使用这些值时应进行缓存优化方案浏览器会维护个队列把所有会引起重排重绘的操作放入这个队列等队列中的操作到一定数量或者到了一定时间间隔浏览器就会队列进行一批处理这样多次重排重绘变成一次重排重绘减少不要一条一条地修改的样式可以先定义好的然后修改的不要把结点的属性值放在一个循环里当成循环里的变量为动画的元件使用或的那么修改他们的是不会的千万不要使用布局因为可能很小的一个小改动会造成整个的重新布局及其内部元素除外它可能需要多次计算才能确定好其在渲染树中节点的属性通常要花倍于同等元素的时间这也是为什么我们要避免使用做布局的一个原因不要在布局信息改变的时候做查询会导致渲染队列强制刷新事件循环主线程从任务队列中读取执行事件这个过程是循环不断的这个机制被称为事件循环的事件分两种宏任务包括整体代码微任务非中具体执行事件的执行顺序先执行宏任务然后执行微任务任务有同步的任务和异步的任务同步的进入主线程异步的进入并注册函数异步事件完成后会将回调函数放在队列中如果还有异步的宏任务那么就会进行循环执行上述的操作主线程会不断从任务队列中按顺序取任务执行每执行完一个任务都会检查队列是否为空执行完一个任务的具体标志是函数执行栈为空如果不为空则会一次性执行完所有然后再进入下一个循环去任务队列中取下一个任务执行详细步骤选择当前要执行的宏任务队列选择一个最先进入任务队列的宏任务如果没有宏任务可以选择则会跳转至的执行步骤将事件循环的当前运行宏任务设置为已选择的宏任务运行宏任务将事件循环的当前运行任务设置为将运行完的宏任务从宏任务队列中移除步骤进入检查点更新界面渲染返回第一步执行进入检查的的具体步骤如下设置进入检查点的标志为当事件循环的微任务队列不为空时选择一个最先进入队列的设置事件循环的当前运行任务为已选择的运行设置事件循环的当前运行任务为将运行结束的从队列中移除对于相应事件循环的每个环境设置对象通知它们哪些为清理的事务设置进入检查点的标志为注意当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件然后再去宏任务队列中取出一个事件同一次事件循环中微任务永远在宏任务之前执行挂载在哪里挂载在下而是挂载在全局函数下面浏览器垃圾回收机制浏览器的具有自动垃圾回收机制执行环境会负责管理代码执行过程中使用的内存原理垃圾收集器会定期周期性找出那些不在继续使用的变量然后释放其内存首先定义了两个分别叫做和当被调用时进入的环境会开辟一块内存存放对象而当调用结束后出了的环境那么该块内存会被引擎中的垃圾回收器自动释放在被调用的过程中返回的对象被全局变量所指向所以该块内存并不会被释放问题到底哪个变量是没有用的解决所以垃圾收集器必须跟踪到底哪个变量没用对于不再有用的变量打上标记以备将来收回其内存用于标记的无用变量的策略可能因实现而有所区别通常情况下有两种实现方式标记清除和引用计数引用计数不太常用标记清除较为常用标记清除被标记进入环境被标记进入环境执行完毕之后又被标离开环境被回收引用计数的引用次数为的引用次数加为的引用次数再加为的引用次数减为方案基础方案引擎基础方案是标记清除即遍历所有可访问的对象回收已不可访问的对象的缺陷和其他语言一样的策略也无法避免一个问题时停止响应其他操作这是为了安全考虑而的在甚至以上对一般的应用还好但对于游戏动画对连贯性要求比较高的应用就麻烦了这就是新引擎需要优化的点避免造成的长时间停止响应优化策略分代回收这个和回收策略思想是一致的也是所主要采用的目的是通过区分临时与持久对象多回收临时对象区少回收持久对象区减少每次需遍历的对象从而减少每次的耗时补充对于对象有额外的开销把它从迁移到另外如果被引用了那引用的指向也需要修改增量这个方案的思想很简单就是每次处理一点下次再处理一点如此类推这种方案虽然耗时短但中断较多带来了上下文切换频繁的问题因为每种方案都其适用场景和缺点因此在实际应用中会根据实际情况选择方案比如低对象比率时中断执行的频率更低些如果大量对象都是长期存活则分代处理优势也不大是什么是存储于访问者计算机中的变量每当一台计算机通过浏览器来访问某个页面时那么就可以通过来创建和读取实际上是存于用户硬盘的一个文件这个文件通常对应于一个域名当浏览器再次访问这个域名时便使这个可用因此可以跨越一个域名下的多个网页但不能跨越多个域名使用不同浏览器对的实现也不一样即保存在一个浏览器中的到另外一个浏览器是不能获取的怎么使用语法注意事项可能被禁用当用户非常注重个人隐私保护时他很可能禁用浏览器的功能是与浏览器相关的这意味着即使访问的是同一个页面不同浏览器之间所保存的也是不能互相访问的可能被删除因为每个都是硬盘上的一个文件因此很有可能被用户删除安全性不够高所有的都是以纯文本的形式记录于文件中因此如果要保存用户名密码等信息时最好事先经过加密处理在保存时只要后面保存的相同那么就会覆盖前面的注意是完全覆盖包括失效时间禁用通过保存在客户端如果将禁用必将对的使用造成一定的影响解决办法重写调试工具谷歌浏览器可查看网页页面代码修改只是当前使用有效也可实时调试修改页面代码样式记录开发者开发过程中的日志信息也可在里面写代码一般页面运行时报错都是可以在这里看到反馈和定位原因及其位置断点调试可以查看程序代码执行的过程断点调试对于每一个程序员来说可是很重要从发起网页页面请求开始分析请求后得到的各个请求资源信息小编有时候就利用这下载一些网站不给下载的在线视频比如教学视频记录并分析网站的生命周期所发生的各类事件分析渲染执行的每一个阶段记录网站加载的各个资源信息判断网页是否安全对当前网页的网络利用及网页性能进行检测并给出一些优化建议其他是调试接口的最佳工具之一使用我们可以调整请求分析响应和调试问题是一个用来帮你找出代码中问题的工具它可做基本的语法检查以及使用一套预设的规则来检查代码中的问题规则是可以扩展的就是来帮我们解决这个问题的它是是一个实时事件日志记录和聚合平台它专门用于监视错误和提取执行适当的事后操作所需的所有信息而无需使用标准用户反馈循环的任何麻烦是一款提供网站浏览器兼容性测试的在线云端测试工具从而开发测试人员不必再准备很多虚拟机或者手机模拟器网络传输跨域跨域是什么跨域指的是在浏览器中当一个请求的源与目标资源的源不一致时即发生跨域访问在默认情况下浏览器的同源策略会阻止这种跨域访问同源策略是为了保护用户的信息安全防止恶意网站对其他网站的资源进行访问和操作同源策略规定几个约束协议相同域名相同端口号相同同源策略限制内容有等节点请求不受同源策略影响当存在跨域请求时浏览器的安全策略也不同等请求浏览器会自动发送一个跨域请求的预检请求到目标资源的服务器如果服务器返回的响应满足一定条件浏览器会继续发送正式的请求否则会跨域等浏览器会先发送一个预检请求到目标资源的服务器服务器返回的响应满足条件后浏览器发送正式请求与简单请求不同的是非简单请求血药确保服务器在响应中设置了跨域请求所允许的响应首部字段解决方案原理利用标签没有跨域限制的漏洞网页可以得到从其他来源动态产生的数据请求一定需要对方的服务器做支持才可以优缺点优点是简单兼容性好可用于解决主流浏览器的跨域数据访问的问题缺点仅支持方法具有局限性不安全可能会遭受攻击实现流程服务器端设置白名单注意不能使用有什么方法可以保持前后端通信实现保持前后端实时通信的方式有以下几种以上才支持以及以上完全支持移动端形势大完全不支持注意是任何版本都不支持和以上支持移动端形势大好轮询用于兼容低版本的浏览器永久帧可用于兼容低版本的浏览器可用于兼容低版本的浏览器优缺点优点是开始提供的一种在单个连接上进行全双工通讯的协议可从升级而来浏览器和服务器只需要一次握手就可以进行持续的双向的数据传输因此能显著节约资源和带宽缺点兼容问题不支持断线重连需要手写心跳连接的逻辑通信机制相对复杂优点只需一次请求便可以的方式多次传送数据节约资源和带宽相对来说简单易用内置断线重连功能缺点是单向的只支持服务端客户端的数据传送客户端到服务端的通信仍然依靠没有一家人整整齐齐的感觉兼容性令人担忧浏览器完全不支持轮询优点兼容性良好对标低版本缺点请求中有大半是无用的请求浪费资源优点兼容低版本浏览器缺点浏览器开启时需要用户确认加载时间长用户体验较差大多数移动端浏览器不支持为重灾区永久帧缺点会产生进度条一直存在的问题用户体验差优点兼容低版本浏览器综上综合兼容性和用户体验的问题我在项目中选用了轮询这三种方式做从上到下的兼容算法顺序存储结构和链式存储结构优缺点顺序存储时相邻数据元素的存放地址也相邻逻辑与物理统一要求内存中可用存储单元的地址必须是连续的优点存储密度大存储空间利用率高缺点插入或删除元素时不方便链式存储时相邻数据元素可随意存放但所占存储空间分两部分一部分存放结点值另一部分存放表示结点间关系的指针优点插入或删除元素时很方便使用灵活缺点存储密度小存储空间利用率低场景顺序表适宜于做查找这样的静态操作链表宜于做插入删除这样的动态操作若线性表的长度变化不大且其主要操作是查找则采用顺序表若线性表的长度变化较大且其主要操作是插入删除操作则采用链表顺序表与链表的比较基于空间的比较存储分配的方式顺序表的存储空间是静态分配的链表的存储空间是动态分配的存储密度结点数据本身所占的存储量结点结构所占的存储总量顺序表的存储密度链表的存储密度基于时间的比较存取方式顺序表可以随机存取也可以顺序存取链表是顺序存取的插入删除时移动元素个数顺序表平均需要移动近一半元素链表不需要移动元素只需要修改指针怎样理解的单向数据流数据从父级组件传递给子组件只能单向绑定子组件内部不能直接修改从父级传递过来的数据所有的都使得其父子之间形成了一个单向下行绑定父级的更新会向下流动到子组件中但是反过来则不行这样会防止从子组件意外改变父级组件的状态从而导致你的应用的数据流向难以理解每次父级组件发生更新时子组件中所有的都将会刷新为最新的值这意味着你不应该在一个子组件内部改变如果你这样做了会在浏览器的控制台中发出警告子组件想修改时只能通过派发一个自定义事件父组件接收到后由父组件修改谈谈你对生命周期的理解生命周期是什么实例有一个完整的生命周期也就是从开始创建初始化数据编译模版挂载渲染更新渲染卸载等一系列过程我们称这是的生命周期各个生命周期的作用组件实例被创建之初组件的属性生效之前组件实例已经完全创建属性也绑定但真实还没有生成还不可用在挂载开始之前被调用相关的函数首次被调用被新创建的替换并挂载到实例上去之后调用该钩子组件数据更新之前调用发生在虚拟打补丁之前组件数据更新之后专属组件被激活时调用专属组件被销毁时调用组件销毁前调用组件销毁后调用谈谈你对的了解是内置的一个组件可以使被包含的组件保留状态避免重新渲染其有以下特性一般结合路由和动态组件一起使用用于缓存组件提供和属性两者都支持字符串或正则表达式表示只有名称匹配的组件会被缓存表示任何名称匹配的组件都不会被缓存其中的优先级比高对应两个钩子函数和当组件被激活时触发钩子函数当组件被移除时触发钩子函数组件中为什么是一个函数因为组件是用来复用的且里对象是引用关系如果组件中是一个对象那么这样作用域没有隔离子组件中的属性值会相互影响如果组件中选项是一个函数那么每个实例可以维护一份被返回对象的独立的拷贝组件实例之间的属性值不会互相影响而的实例是不会被复用的因此不存在引用对象的问题你对项目哪些优化代码层面的优化和区分使用场景和区分使用场景遍历必须为添加且避免同时使用长列表性能优化事件的销毁图片资源懒加载路由懒加载第三方插件的按需引入优化无限列表性能服务端渲染预渲染层面的优化对图片进行压缩减少转为的冗余代码提取公共代码模板预编译提取组件的优化构建结果输出分析项目的编译优化基础的技术的优化开启压缩浏览器缓存的使用使用查找性能瓶颈中的有什么作用是为中的唯一标记通过这个我们的操作可以更准确更快速的过程可以概括为和各有两个头尾的变量和它们会新节点和旧节点会进行两两对比即一共有种比较方式和和和和如果以上种比较都没匹配如果设置了就会用再进行比较在比较的过程中遍历会往中间靠一旦表明和至少有一个已经遍历完了就会结束比较所以中的作用是是为中的唯一标记通过这个我们的操作可以更准确更快速虚拟的优缺点优点保证性能下限框架的虚拟需要适配任何上层可能产生的操作它的一些操作的实现必须是普适的所以它的性能并不是最优的但是比起粗暴的操作性能要好很多因此框架的虚拟至少可以保证在你不需要手动优化的情况下依然可以提供还不错的性能即保证性能的下限无需手动操作我们不再需要手动去操作只需要写好的代码逻辑框架会根据虚拟和数据双向绑定帮我们以可预期的方式更新视图极大提高我们的开发效率跨平台虚拟本质上是对象而与平台强相关相比之下虚拟可以进行更方便地跨平台操作例如服务器渲染开发等等缺点无法进行极致优化虽然虚拟合理的优化足以应对绝大部分应用的性能需求但在一些性能要求极高的应用中虚拟无法进行针对性的极致优化比如动画等等虚拟实现原理虚拟的实现原理主要包括以下部分用对象模拟真实树对真实进行抽象算法比较两棵虚拟树的差异算法将两个虚拟对象的差异应用到真正的树是如何实现数据双向绑定的数据双向绑定主要是指数据变化更新视图输入框内容变化时中的数据同步变化即的变化中的数据变化时文本节点的内容同步变化即的变化主要通过以下个步骤来实现数据双向绑定的实现一个监听器对数据对象进行遍历包括子属性对象的属性利用对属性都加上和这样的话给这个对象的某个值赋值就会触发那么就能监听到了数据变化实现一个解析器解析模板指令将模板中的变量都替换成数据然后初始化渲染页面视图并将每个指令对应的节点绑定更新函数添加监听数据的订阅者一旦数据有变动收到通知调用更新函数进行数据更新实现一个订阅者订阅者是和之间通信的桥梁主要的任务是订阅中的属性值变化的消息当收到属性值变化的消息时触发解析器中对应的更新函实现一个订阅器订阅器采用发布订阅设计模式用来收集订阅者对监听器和订阅者进行统一管理有哪几种路由守卫全局守卫后置守卫全局解析守卫路由独享守卫的钩子函数都有哪些关于中的钩子函数主要分为类全局钩子函数要函数有三个参数分别是即将进入的路由对象当前导航即将离开的路由进行管道中的一个钩子如果执行完了则导航的状态就是确认的否则为终止导航单独路由独享组件组件内钩子路由模式有几种有种路由模式使用值来作路由支持所有浏览器包括不支持的浏览器依赖和服务器配置具体可以查看模式支持所有运行环境如服务器端如果发现没有浏览器的路由会自动强制进入这个模式说下中常用的和路由模式实现原理吗模式的实现原理中值只是客户端的一种状态也就是说当向服务器端发出请求时部分不会被发送值的改变都会在浏览器的访问历史中增加一个记录因此我们能通过浏览器的回退前进按钮控制的切换可以通过标签并设置属性当用户点击这个标签后的值会发生改变或者使用来对进行赋值改变的值我们可以使用事件来监听值的变化从而对页面进行跳转渲染模式的实现原理和两个来操作实现的变化我们可以使用事件来监听的变化从而对页面进行跳转渲染或不会触发事件这时我们需要手动触发页面跳转渲染包括几个模块是一个专为应用程序开发的状态管理模式每一个应用的核心就是仓库基本上就是一个容器它包含着你的应用中大部分的状态的状态存储是响应式的当组件从中读取状态的时候若中的状态发生变化那么相应的组件也会相应地得到高效更新改变中的状态的唯一途径就是显式地提交这样使得我们可以方便地跟踪每一个状态的变化定义了应用状态的数据结构可以在这里设置默认的初始状态允许组件从中获取数据辅助函数仅仅是将中的映射到局部计算属性是唯一更改中状态的方法且必须是同步函数用于提交而不是直接变更状态可以包含任意异步操作允许将单一的拆分为多个且同时保存在单一的状态树中和的区别和的区别如下可以直接监听对象而非属性可以直接监听数组的变化有多达种拦截方法不限于等等是不具备的返回的是一个新对象我们可以只操作新的对象达到目的而只能遍历对象属性直接修改作为新标准将受到浏览器厂商重点持续的性能优化也就是传说中的新标准的性能红利兼容性好支持而的存在浏览器兼容性问题而且无法用磨平因此的作者才声明需要等到下个大版本才能用重写和区别是什么哪些场景适合基本定义即的简写即模型视图视图模型模型指的是后端传递的数据视图指的是所看到的页面视图模型是模式的核心它是连接和的桥梁它有两个方向一是将模型转化成视图即将后端传递的数据转化成所看到的页面实现的方式是数据绑定二是将视图转化成模型即将所看到的页面转化成后端的数据实现的方式是事件监听这两个方向都实现的我们称之为数据的双向绑定基本定义是的简写即模型视图控制器和指的意思和中的和意思一样即指的是页面业务逻辑使用的目的就是将和的代码分离是单向通信也就是跟必须通过来承上启下使用场景主要就是中演变成中的主要解决了中大量的操作使页面渲染性能降低加载速度变慢影响用户体验数据驱动通过数据来显示视图层而不是节点操作场景数据操作比较多的场景需要大量操作元素时采用的开发方式会更加便捷让开发者更多的精力放在数据的变化上解放繁琐的操作元素两者之间的区别和其实区别并不大都是一种设计思想和的区别并不是完全取代了只是在的基础上增加了一层只不过是弱化了的概念存在目的在于抽离中展示的业务逻辑而不是替代其它视图操作业务等还是应该放在中实现也就是说实现的是业务逻辑组件的重用使开发更高效结构更清晰增加代码的复用性中如何重置要初始化中的数据可以使用方法实现重置中的数据以下就是对该方法的详细介绍以及如何使用该方法重置中的数据方法基本定义方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象它将返回目标对象用法第一个参数是目标对象第二个参数是源对象就是将源对象属性复制到目标对象返回目标对象新特性有哪些性能提升响应式性能提升由原来的改为基于的使其速度更快消除警告重写了突破了的性能瓶颈进行模板编译优化更加高效的组件初始化更好的支持有更好的类型推断使得把支持得非常好新增是新增的功能比更强大它可以把各个功能模块独立开来提高代码逻辑的可复用性同时代码压缩性更强新增组件不再限制只有一个根几点传送门允许我们将控制的内容传送到任意的中等待异步组件时渲染一些额外的内容让应用有更好的用户体验支持摇树优化摇树优化后会将不需要的模块修剪掉真正需要的模块打到包内优化后的项目体积只有原来的一半加载速度更快自定义渲染器实现的方式进行编程组合式生命周期钩子函数有变化吗是围绕和生命周期钩子运行的所以不需要显示的定义它们其他的钩子都可以编写到内和的区别和都是监听器是一个副作用函数它们之间的区别有需要传入监听的数据源而可以自动手机数据源作为依赖可以访问倒改变之前和之后的值只能获取改变后的值运行的时候不会立即执行值改变后才会执行而运行后可立即执行这一点可以通过的配置项改变中和优先级在和中的区别实践中不管是或者都不应该把和放在一起使用在中在一个元素上同时使用和时会优先作用在中总是优先于生效中的优先级是高于的放在一起会先执行循环在判断条件并且如果值渲染列表中一小部分元素也得再每次重渲染的时候遍历整个列表比较浪费资源中的优先级是高于的所以执行时它调用相应的变量如果不存在就会导致异常是干啥的是的语法糖简化了组合式的写法并且运行性能更好使用语法糖的特点属性和方法无需返回可以直接使用引入组件的时候会自动注册无需通过手动注册使用接收父组件传递的值获取属性获取插槽获取自定义事件默认不会对外暴露任何属性如果有需要可使用常用的修饰符等同于中的防止事件冒泡等同于中的防止执行预设的行为如果事件可取消则取消该事件而不停止事件的进一步传播作用是阻止默认事件例如标签的跳转与事件冒泡的方向相反事件捕获由外到内只会触发自己范围内的事件不包含子元素只会触发一次修饰符的作用是把绑定的值的首尾空格给去掉在实际开发中我们一般用于搜索框的内容修饰过滤掉用户多输入前后空格导致内容查不出来的情况这三个修饰符是鼠标的左中右按键触发的事件和有什么区别双向绑定更新的双向数据绑定是利的个对数据进劫持结合发布订阅模式的式来实现的中使了的对数据代理通过函数给每个对象都包层通过监听属性的变化从实现对数据的监控这是相于版本使的优势如下只能监听某个属性不能对全对象监听可以省去闭包等内容来提升效率直接绑定整个对象即可监听数组不再去单独的对数组做特异性操作通过可以直接拦截所有对象类型数据的操作完美持对数组的监听获取在代码块可以直接获取通过指令传递不同使的是选项类型使的是合成型建立数据是把数据放入中就需要使用一个新的方法此方法在组件初始化构造得时候触发生命周期不同开始创建组件之前创建的是和组件挂载到节点上之前执行的函数组件挂载完成后执行的函数组件更新之前执行的函数组件更新完成之后执行的函数组件挂载到节点上之前执行的函数组件卸载之前执行的函数组件卸载完成后执行的函数关于和的优先级在一个元素上同时使用和会优先执行总会优先于生效和的算法算法就是进行虚拟节点对比并返回一个对象用来存储两个节点不同的地方最后用记录的消息去局部更新算法会比较每一个而对于一些不参与更新的元素进行比较是有点消耗性能的算法在初始化的时候会给每个虚拟节点添加一个就是优化的标识只会比较发生变化的进行更新视图对于没有变化的元素做静态标记在渲染的时候直接复用与的区别中的和是中用于数据管理的两种不同的响应式用于创建一个包装简单值的响应式引用例如一个数字字符串或对象当创建一个响应式引用时它返回一个对象该对象具有一个属性该属性指向实际值当返回的对象中的属性更改时组件将自动重新渲染用于创建一个响应式对象该对象可以包含多个属性和嵌套属性当使用创建响应式对象时返回的对象是一个代理对象该对象具有与原始对象相同的属性并且任何对代理对象属性的更改都将触发组件的重新渲染和的区别是路由信息对象包括等路由信息参数是路由实例想要导航到不同对象包括了路由的跳转方法钩子函数等可以监听多个方法吗可以一个元素绑定多个事件的两种写法一个事件绑定多个函数的两种写法修饰符的使用在方法里面分别写两个事件点我的使用实现双向绑定的语法糖常用于表单与组件之间的数据双向绑定的原理绑定一个属性指令给当前元素绑定事件可看出绑定在表单上时其实就是绑定和监听事件的结合体组件上的双向绑定原理绑定在组件上的时候做了以下步骤在父组件内给子组件标签添加其实就是给子组件绑定了属性子组件内使用创建创建属性可以拿到父组件传递下来的值名字必须是子组件内部更改的时候必须通过派发一个事件并携最新的值会自动监听事件把接收到的最新的值同步赋值到绑定的变量上遇到的坑如何解决的用打包后访问出现资源加载问题解决开发环境的文件夹是基于根目录的所以直接用中假如你引入某个样式然后这个样式里面有引用到图片如果你的文件中没有这个图片这时候即使你没有引用这个图片对应的类名但是只要你有引入这个文件他找不到相应路径图片也会报错用循环出来的列表在设置列表中的元素的动态属性时需要加属性不然动态属性设置不出来在中的中的中的不可以直接设置为变量在里面直接引路径只能通过的形式引入值得注意的是引用这个方式的时候是变量需要加不然会报错在中使用进行循环时需要注意加不然会出现警告父组件异步更新数据子组件获取不到应用场景当父组件获取数据子组件使用接收数据时执行的时候还没有返回数据而且只执行一次这时中接收的数据为空解决方案在对应组件中判断数据的长度说说中的算法算法当发生改变会根据新的数据生成一个新的虚拟新的虚拟和旧的虚拟进行对比这个对比的过程就是算法是全量当数据发生变化它就会新生成一个树并和之前的树进行比较找到不同的节点然后更新是静态标记非全量在创建虚拟树的时候会根据中的内容会不会发生变化添加一个静态标记之后在与上次虚拟节点进行对比的时候就只会对比这些带有静态标记的节点使用最长递增子序列优化对比流程可以最大程度的减少的移动达到最少的操作中怎么设置全局变量和全局组件在中定义全局变量中给对象添加新属性时界面不刷新怎么办的响应式原理使用的是对象代理去实现的对象代理中有一个和方法当我们访问对象的时候就会触发方法当我们对对象中的值进行修改时会触发方法但是当我们给对象添加一个新的属性时对象代理是检测不到的所以就会出现直接给对象添加属性响应式不生效的问题所以在中可以使用对象名属性名属性值的方法去给对象添加属性或者使用对象名属性名属性值的方法进行添加添加之后的属性就带有响应式了中的辅助函数怎么使用的辅助函数有个函数返回的是一个对象通常我们需要使用一个工具函数将多个对象合并为一个以使我们可以将最终对象传给属性辅助函数仅仅是将中的映射到局部计算属性因此你可以这样来使用他辅助函数将组件中的映射为其原理就是将映射为在组件中使用分发或者使用辅助函数将组件的映射为调用刷新浏览器后的数据是否存在如何解决原因因为里的数据是保存在运行内存中的当页面刷新时页面会重新加载实例里面的数据就会被重新赋值初始化或者就是下载持久化存储插件比如使用的实质也是将中的数据存放到或者中只不过这个存取过程组件会帮我们完成我们只需要用的读取数据方式操作就可以了路由跳转传参的方式有哪些传参显示参数在中会显示出传参的值刷新页面不会失去拿到的参数使用该方式传值的时候需要子路由提前配置好参数传参不显示参数在中不会显示出传参的值但刷新页面会失去拿到的参数使用该方式传值的时候需要子路由提前配置好参数传参传过去的参数会拼接在地址栏中刷新页面数据不会丢失使用和都可以几种路由跳转几种方式的区别跳转到指定路径并想栈中添加一个记录点击后退会返回到上一个页面跳转到指定路径但是栈中不会有记录点击返回会跳转到上上个页面就是直接替换了当前页面向前或者向后跳转个页面可为正整数或负整数单页面应用和多页面应用区别及优缺点单页面顾名思义只有一个页面一般是一个主页和多个路由页面组成优点公共资源不重新加载局部加载服务器压力小切换速度快用户体验好前后端分离缺点不利于可以优化比如路由懒加载等初次加载时耗时多开发难度较大相对多页面多页面有多个页面跳转的时候是从一个页面跳到另一个页面优点利于更容易扩展更易数据分析缺点开发成本高服务器压力大用户体验相对较差注册在全局上时路由切换时会重复触发事件如何解决呢添加来关闭如果想要用来进行页面组件之间的数据传递需要注意亮点组件事件应在声明周期内其次组件内的记得要销毁自定义指令详解为什么需要自定义指令因为是模式只需要关注于数据和业务逻辑不需要关注的操作但是有时候面对一些特殊的业务需求时需要进行的操作这个时候就需要进行自定义指令自定义局部指令在选项中的中设置局部自定义指令是一个对象对象的属性是自定义指令的名称对象中属性的值是自定义指令的钩子函数对象自定义全局指令在的方法参数一自定义指令的名称参数二自定义指令的钩子函数对象是什么有什么作用原理是什么又名插槽是的内容分发机制组件内部的模板引擎使用元素作为承载分发内容的出口插槽是子组件的一个模板标签元素而这一个标签元素是否显示以及怎么显示是由父组件决定的又分三类默认插槽具名插槽和作用域插槽默认插槽又名匿名插槽当没有指定属性值的时候一个默认显示插槽一个组件内只有有一个匿名插槽具名插槽带有具体名字的插槽也就是带有属性的一个组件可以出现多个具名插槽作用域插槽默认插槽具名插槽的一个变体可以是匿名插槽也可以是具名插槽该插槽的不同点是在子组件渲染作用域插槽时可以将子组件内部的数据传递给父组件让父组件根据子组件的传递过来的数据决定如何渲染该插槽实现原理当子组件实例化时获取到父组件传入的标签的内容存放在中默认插槽为具名插槽为为插槽名当组件执行渲染函数时候遇到标签使用中的内容进行替换此时可以为插槽传递数据若存在数据则可称该插槽为作用域插槽的使用用法将回调延迟到下次更新循环之后执行在修改数据之后立即使用它然后等待更新它跟全局方法一样不同的是回调的自动绑定到调用它的实例上的应用场景在的生命周期钩子函数中进行操作一定要放在函数中执行在钩子函数执行的时候其实并未进行任何渲染而此时进行操作无异于徒劳所以此处一定要将操作的代码放进的回调函数中钩子函数因为该钩子函数执行时所有的挂载和渲染都已完成此时在该钩子函数中进行任何操作都不会有问题在数据变化后要执行某个操作而这个操作需要随数据改变而改变结构时这个操作都是需要放置的回调函数中虚拟和真实什么是虚拟虚拟相当于在和真实中间加了一个缓存利用算法避免了没有必要的操作从而提高性能用对象结构表示树的结构用这个树构建一个真正的树插到文档当中当状态变更的时候重新构造一棵新的对象树用新的树和旧的树进行比较记录两棵树差异把所记录的差异应用到步骤所构建的真正的树上视图就更新了虚拟和区别性能差异减少的操作虚拟可以将多次操作合并为一次操作减少操作的次数更新缓慢更新更快可以直接更新无法直接更新如果元素更新则创建新如果元素更新则更新操作代价很高操作非常简单消耗的内存较多很少的内存消耗组件间通信父组件向子组件通讯父组件可以向子组件通过传的方式向子组件进行通讯子组件向父组件通讯回调的方式父组件向子组件传递进行通讯此为作用域为父组件自身的函数子组件调用该函数将子组件想要传递的信息作为参数传递到父组件的作用域中兄弟组件通信找到这两个兄弟节点共同的父节点结合上面两种方式由父节点转发信息进行通信跨层级通信设计目的是为了共享那些对于一个组件树而言是全局的数据例如当前认证的用户主题或首选语言发布订阅模式发布者发布事件订阅者监听事件并做出反应我们可以通过引入模块进行通信全局状态管理工具借助或者等全局状态管理工具进行通信这种工具会维护一个全局状态中心并根据不同的事件产生新的状态的原理是当今最热门的前端开发库之一它是程序的可预测状态容器用于整个应用的状态管理使用开发的应用易于测试可以在不同环境中运行并显示一致的行为数据流首先用户通过发出发出方式就用到了方法然后自动调用并且传入两个参数当前和收到的会返回新的一旦有变化就会调用监听函数来更新遵循的三个原则是什么单一事实来源整个应用的状态存储在单个中的对象状态树里单一状态树可以更容易地跟踪随时间的变化并调试或检查应用程序状态是只读的改变状态的唯一方法是去触发一个动作动作是描述变化的普通对象就像是数据的最小表示一样该操作是对数据更改的最小表示使用纯函数进行更改为了指定状态树如何通过操作进行转换你需要纯函数纯函数是那些返回值仅取决于其参数值的函数单一事实来源怎么理解使用将程序的整个状态存储在同一个地方因此所有组件的状态都存储在中并且它们从本身接收更新单一状态树可以更容易地跟踪随时间的变化并调试或检查程序组件组成这是一个用来描述发生了什么事情的对象这是一个确定状态将如何变化的地方整个程序的状态对象树保存在中只显示提供的数据如何在中定义中的必须具有属性该属性指示正在执行的的类型必须将它们定义为字符串常量并且还可以向其添加更多的属性在中被名为的函数所创建解释的作用是纯函数它规定应用程序的状态怎样因响应而改变通过接受先前的状态和来工作然后它返回一个新的状态它根据操作的类型确定需要执行哪种更新然后返回新的值如果不需要完成任务它会返回原来的状态在中的意义是什么是一个对象它可以保存程序的状态并提供一些方法来访问状态调度操作和注册侦听器应用程序的整个状态对象树保存在单一存储中因此非常简单且是可预测的我们可以将中间件传递到来处理数据并记录改变存储状态的各种操作所有操作都通过返回一个新状态有哪些优点结果的可预测性由于总是存在一个真实来源即因此不存在如何将当前状态与动作和应用的其他部分同步的问题可维护性代码变得更容易维护具有可预测的结果和严格的结构服务器端渲染你只需将服务器上创建的传到客户端即可这对初始渲染非常有用并且可以优化应用性能从而提供更好的用户体验开发人员工具从操作到状态更改开发人员可以实时跟踪应用中发生的所有事情社区和生态系统背后有一个巨大的社区这使得它更加迷人一个由才华横溢的人组成的大型社区为库的改进做出了贡献并开发了各种应用易于测试的代码主要是小巧纯粹和独立的功能这使代码可测试且独立组织准确地说明了代码的组织方式这使得代码在团队使用时更加一致和简单组件生命周期的阶段是什么初始渲染阶段这是组件即将开始其生命之旅并进入的阶段更新阶段一旦组件被添加到它只有在或状态发生变化时才可能更新和重新渲染这些只发生在这个阶段卸载阶段这是组件生命周期的最后阶段组件被销毁并从中删除详细解释组件的生命周期方法挂载阶段构造函数最先被执行我们通常在构造函数里初始化对象或者给自定义方法绑定这是个静态方法当我们接收到新的属性想去修改我们可以使用函数是纯函数只返回需要渲染的东西不应该包含其它的业务逻辑可以返回原生的组件字符串和数字和等内容组件装载之后调用此时我们可以获取到节点并操作比如对的操作服务器请求订阅都可以写在这个里面但是记得在中取消订阅更新阶段此方法在更新个挂载阶段都可能会调用有两个参数和表示新的属性和变化之后的返回一个布尔值表示会触发重新渲染表示不会触发重新渲染默认返回我们通常利用此生命周期来优化程序性能更新阶段也会触发此生命周期这个方法在之后之前调用有两个参数和表示之前的属性和之前的这个函数有一个返回值会作为第三个参数传给如果你不想要返回值可以返回此生命周期必须与搭配使用该方法在方法之后被调用有三个参数表示之前的之前的和第三个参数是返回的如果触发某些回调函数时需要用到元素的状态则将对比或计算的过程迁移至然后在中统一触发回调或更新状态卸载阶段当我们的组件被卸载或者销毁了就会调用我们可以在这个函数里去清除一些定时器取消网络请求清理无效的元素等垃圾清理工作扩展之后有三个生命周期被废弃但并未删除官方计划在版本完全删除这三个函数只保留前缀的三个函数目的是为了向下兼容但是对于开发者而言应该尽量避免使用他们而是使用新增的生命周期函数替代它们什么是路由路由是一个构建在之上的强大的路由库它有助于向应用程序添加新的屏幕和流这使与网页上显示的数据保持同步它负责维护标准化的结构和行为并用于开发单页应用路由有一个简单的为什么需要中的路由用于定义多个路由当用户定义特定的时如果此与内定义的任何路由的路径匹配则用户将重定向到该特定路由所以基本上我们需要在自己的应用中添加一个库允许创建多个路由每个路由都会向我们提供一个独特的视图为什么中使用关键字虽然用于封装中的多个路由当你想要仅显示要在多个定义的路线中呈现的单个路线时可以使用关键字使用时标记会按顺序将已定义的与已定义的路由进行匹配找到第一个匹配项后它将渲染指定的路径从而绕过其它路线列出的优点就像基于组件一样在中是可以将可视化为单个根组件其中我们将特定的子路由包起来无需手动设置历史值在中我们要做的就是将路由包装在组件中包是分开的共有三个包分别用于和这使我们应用更加紧凑基于类似的编码风格很容易进行切换的有什么了解是中引用的简写它是一个有助于存储对特定的元素或组件的引用的属性它将由组件渲染配置函数返回用于对返回的特定元素或组件的引用当需要进行测量或向组件添加方法时它们会派上用场列出一些应该使用的情况并不是将事件绑在该的真实上而是在处监听所有支持的事件当事件发生并冒泡至处时将事件内容封装并交由真正的处理函数运行这样的方式不仅减少了内存消耗还能在组件挂载销毁时统一订阅和移除事件另外冒泡到上的事件也不是原生浏览器事件而是自己实现的合成事件因此我们如果不想要事件冒泡的话调用是无效的而应该调用和的比较状态管理是的一个异步处理的中间件是数据管理库和一样设计思想属于体系函数式编程思想不属于体系面向对象编程和响应式编程主要特点因为是中间件更关注异步处理的通过函数来将异步变为同步使代码可读性高结构清晰也不是而是在函数中通过或者方法直接声明式调用并自带一些方法如等控制多个异步操作让多个异步更简单是更简单更方便更灵活的处理数据是包含了和包装成一个可被观察的对象可以直接修改之后通过将依赖的计算属性更新之后触发响应依赖的变更输出相应的副作用但不生成新的数据可变性强调不可变不能直接操作通过和在原来的的基础上返回一个新的达到改变的目的直接在方法中更改同时所有使用的都发生变化不生成新的写法难易度比在和上要简单一些需要用触发的改变需要订阅在非严格模式下不用和在严格模式下需要在中修改并且自动触发相关依赖的更新使用场景很好的解决了关于异步处理时的复杂度和代码冗余的问题数据流向比较好追踪但是的学习成本比较高代码比较冗余不是特别需要状态管理最好用别的方式代替学习成本低能快速上手代码比较简洁但是可能因为代码编写的原因和数据更新时相对黑盒导致数据流向不利于追踪简述一下的源码实现的实现主要分为和属于实例在创建实例的过程中会在实例中注册和属性还会依次调用内置的生命周期函数中有一个函数函数要求返回一个对象或对象分为原生对象和组件式对象原生组件式对象会被一起解析成虚拟树并且内部使用的和也以的形式注入到这棵虚拟树之中在渲染虚拟树的前后会触发的一些生命周期钩子函数比如和在虚拟树解析完成后将被渲染成真实树调用时会调用更新函数更新的并且触发内部的一个调用生成新的虚拟树利用算法与旧的虚拟树进行比对比对以后利用最优的方案进行节点的更新这也是单向数据流的原理与的不同之处到底是异步还是同步有时表现出异步有时表现出同步只在合成事件和钩子函数中是异步的在原生事件和中都是同步的的异步并不是说内部由异步代码实现其实本身执行的过程和代码都是同步的只是合成事件和钩子函数的调用顺序在更新之前导致在合成事件和钩子函数中没法立马拿到更新后的值形成了所谓的异步当然可以通过第二个参数中的拿到更新后的结果的批量更新优化也是建立在异步合成事件钩子函数之上的在原生事件和中不会批量更新在异步中如果对同一个值进行多次的批量更新策略会对其进行覆盖取最后一次的执行如果是同时多个不同的值在更新时会对其进行合并批量更新异步中间件之间的优劣优点体积小的实现方式很简单只有不到行代码使用简单没有引入像或者额外的范式上手简单缺陷样板代码过多与本身一样通常一个请求需要大量的代码而且很多都是重复性质的耦合严重异步操作与的偶合在一起不方便管理功能孱弱有一些实际开发中常用的功能需要自己进行封装优点异步解耦异步操作被被转移到单独中不再是掺杂在或中摆脱的参数依然是一个纯粹的而不是充满黑魔法异常处理受益于的实现代码异常请求失败都可以直接通过语法直接捕获处理功能强大提供了大量的辅助函数和创建器供开发者使用开发者无须封装或者简单封装即可使用灵活可以将多个可以串行并行组合起来形成一个非常实用的异步易测试提供了各种的测试方案包括分支覆盖等等缺陷额外的学习成本不仅在使用难以理解的而且有数十个学习成本远超最重要的是你的额外学习成本是只服务于这个库的与不同虽然也有额外学习成本但是背后是和一整套思想体积庞大体积略大代码近行版左右功能过剩实际上并发控制等功能很难用到但是我们依然需要引入这些代码支持不友好无法返回类型优点功能最强由于背靠这个强大的响应式编程的库借助的操作符你可以几乎做任何你能想到的异步处理背靠由于有的加持如果你已经学习了的学习成本并不高而且随着的升级也会变得更强大缺陷学习成本奇高如果你不会则需要额外学习两个复杂的库社区一般的下载量只有的社区也不够活跃在复杂异步流中间件这个层面仍处于领导地位和区别是啥和是普通的对象虽然它们都包含影响渲染输出的信息但是它们在组件方面的功能是不同的即是组件自己管理数据控制自己的状态可变是外部传入的数据参数不可变没有的叫做无状态组件有的叫做有状态组件多用少用也就是多写无状态组件当调用时是如何工作的虚拟渲染当方法被调用时它返回一个新的组件的虚拟结构当调用时会被再次调用因为默认情况下总是返回所以默认情况下是没有优化的原生渲染只会在虚拟中修改真实节点而且修改的次数非常少这是很棒的特性它优化了真实的变化使变得更快简介的组件创建方式一种是类组件一种是纯函数组件纯函数组件没有状态纯函数组件没有生命周期纯函数组件没有使用的优点告别难以理解的和生命周期的痛点解决业务逻辑难以拆分的问题使状态逻辑复用变得简单可行函数组件从设计思想上来看更加契合的理念并非万能暂时还不能完全的为函数组件补齐类组件地能力如生命周期的方法暂时还未实现将类组件的复杂变成函数组件的轻量可能使用者并不能很好地消化这种复杂在使用层面有着严格地规则约束函数种状态钩子共享状态钩子副作用钩子钩子可以在函数组件中存储查找组件内的标签或任意其它数据主要用来解决使用产生的无用渲染的性能问题主要是为了性能的优化和相同都是用来执行副作用但是它会在所有的变更之后同步调用和最大的区别就是一个是同步一个是异步可以在使用时自定义暴露给父组件的实例值自定义自定义是一个函数其名称以开头函数内部可以调用其他的自定义可以封装状态能够更好的实现状态共享打包工具前端为什么要进行打包和构建体积更小压缩合并加载更快编译高级语言和语法模块化兼容性和错误检查统一高效的开发环境统一的构建流程和产出标准集成公司构建规范提测上线等如何提高的构建速度优化开启缓存使用中的不去解析属性值代表的库的依赖需要在的节点添加配置使用分割可以使用内置插件插件作用忽略第三方包指定目录让这些指定目录不要被打包进去使用多进程打包需要下载使用多进程压缩默认使用来压缩代码单进程代码分割的本质是什么代码分割的本质就是在源代码直接上线和达成唯一脚本这两种极端方案之间的一种更适合实际场景的中间状态源码直接上线虽然过程可控但是请求多性能开销大打包成唯一脚本服务器压力小但是页面空白期长用户体验不好的基本功能有哪些名称内容代码转换编译成编辑成文件优化压缩压缩合并图片代码分割提取多个页面的公共代码提取首屏不需要执行部分的代码让其异步加载模块合并采用模块化的项目有很多模块和文件需要构建功能把模块分类合并成一个文件自动刷新监听本地源代码的变化自动构建刷新浏览器代码校验在代码被提交到仓库前需要检测代码是否符合规范以及单元测试是否通过自动发布更新完代码后自动构建出线上发布代码并传输给发布系统文件指纹是什么文件指纹是打包之后的文件后缀名和打包的有关不同的会生出不同的后缀名根据文件内容来定义文件内容不变则其不变后缀名和整个项目构建有关只要项目文件有修改整个构建的值就会修改后缀名为什么说比更快会先打包然后启动开发服务器请求服务器时直接给予打包结果是直接启动开发服务器请求哪个模块再对该模块进行实时编译在启动的时候不需要打包意味着不需要分析模块的依赖不需要编译因此启动速度非常快当浏览器请求某个模块时再根据需要对模块内容进行编译这种按需动态编译的方式极大的缩减了编译时间项目越复杂模块越多的优势越明显在方面当改动了一个模块后仅需让浏览器重新请求该模块即可不像那样需要把该模块的相关依赖模块全部编译一次效率更高当需要打包到生产环境时使用传统的进行打包因此的主要优势在开发阶段另外由于利用的是因此在代码中不可以使用工作原理是一种现代化的前端开发工具其工作原理主要分为以下几个步骤基于构建作为一款基于的前端构建工具通过模块提供的动态导入功能来实现快速的开发和构建零配置开发允许开发者在不需要任何配置的情况下启动一个服务器进行开发通过对文件的即时编译和缓存来提高开发效率基于浏览器原生的加载将所有文件视为模块并且在开发时会直接从源代码加载模块而不是打包后的文件从而可以避免打包的过程带来的性能损失按需编译和缓存会按需编译和缓存依赖项只有当需要更新时才会进行重新编译缓存让开发者可以忽略无关的代码变化插件化架构的插件化架构可以方便地扩展其功能例如使用插件来处理处理图片压缩源代码等等核心原理其核心原理是利用浏览器现在已经支持的碰见就会发送一个请求去加载文件整个过程中没有对文件进行打包编译做到了真正的按需加载所以其运行速度比原始的开发编译速度快出许多特点快速的冷启动基于的依赖进行预编译优化打包速度太快了比类似的工具快倍增加缓存策略源码模块使用协商缓存依赖模块使用强缓因此一旦被缓存它们将不需要再次请求热更新当修改代码时能够在不刷新页面的情况下把页面中发生变化的模块替换成新的模块同时不影响其他模块的正常运作基于打包生产环境下由于对和代码分割并使用进行打包高效的热更新基于实现同时利用头来加速整个页面的重新加载冷启动为什么快运行命令后只做了两件事情启动本地服务器并注册了一些中间件使用预构建模块生产环境缺点在是直接把转化后的的扔给浏览器让浏览器根据依赖关系自己去加载依赖那有人就会说了那放到生产环境时是不是可以不打包直接在开个服务就行反正浏览器会自己去根据依赖关系去自己加载依赖答案是不行的为啥呢你代码是放在服务器的过多的浏览器加载依赖肯定会引起更多的网络请求为了在生产环境中获得最佳的加载性能最好还是将代码进行懒加载和分割处理这些优化操作目前还不怎么完善和优缺点对比更快的启动时间和更新速度更好的开发体验自动打开浏览器自动刷新页面配置简单不需要过多的配置就可以搭建基本的开发环境更少的依赖借助原生的模块避免了过多的额外依赖缺点的构建技术主要用于中小型项目对于大型项目的支持不如主要是针对的单页面应用对于多页面应用应用自定义流程应用不如开发环境首屏加载慢懒加载慢由于基于原生模块不支持关注兼容性关注浏览器端的开发体验的生态还不如',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-13 15:23:40',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/cursur.css"><link rel="stylesheet" href="/css/fenleiye.css"><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://wudl.cn" title="主页"><img class="back-menu-item-icon" src="/img/48.png" alt="主页"/><span class="back-menu-item-text">主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.wudl.cn" title="博客"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://ccv-engineer.gitee.io/" title="旧站"><img class="back-menu-item-icon" src="/img/32.png" alt="旧站"/><span class="back-menu-item-text">旧站</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://7bu.top/" title="图床"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">kilito</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tag faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://chatgpt.wudl.cn"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> ChatGPT</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://gpt.zhizhubao.com/chat"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 私人助理</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=891137324&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/kongtiao/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zaobao/"><span> 早报</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Generato/" style="font-size: 1.05rem;">Generato<sup>1</sup></a><a href="/tags/fetch/" style="font-size: 1.05rem;">fetch<sup>1</sup></a><a href="/tags/koa/" style="font-size: 1.05rem;">koa<sup>1</sup></a><a href="/tags/this/" style="font-size: 1.05rem;">this<sup>1</sup></a><a href="/tags/vue%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">vue原理<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99/" style="font-size: 1.05rem;">手写<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99Promise/" style="font-size: 1.05rem;">手写Promise<sup>1</sup></a><a href="/tags/%E6%99%BA%E6%85%A7%E5%9B%AD%E5%8C%BA/" style="font-size: 1.05rem;">智慧园区<sup>1</sup></a><a href="/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/" style="font-size: 1.05rem;">柯里化<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>1</sup></a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 1.05rem;">继承<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url">面试</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-02T05:10:47.779Z" title="发表于 2023-10-02 13:10:47">2023-10-02</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-13T07:23:40.705Z" title="更新于 2023-10-13 15:23:40">2023-10-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">33.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为安徽"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>安徽</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://ekilito.github.io/posts/3929.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url">面试</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">八股文</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">kilito</span><time itemprop="dateCreated datePublished" datetime="2023-10-02T05:10:47.779Z" title="发表于 2023-10-02 13:10:47">2023-10-02</time><time itemprop="dateCreated datePublished" datetime="2023-10-13T07:23:40.705Z" title="更新于 2023-10-13 15:23:40">2023-10-13</time></header><h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="1-2-h5新特性"><a href="#1-2-h5新特性" class="headerlink" title="1.2 h5新特性"></a>1.2 h5新特性</h2><ul>
<li>新增选择器 document.querySelector、document.querySelectorAll</li>
<li>拖拽释放(Drag and drop) API</li>
<li>媒体播放的 video 和 audio</li>
<li>本地存储 localStorage 和 sessionStorage</li>
<li>离线应用 manifest</li>
<li>桌面通知 Notififications</li>
<li>语意化标签 article、footer、header、nav、section</li>
<li>增强表单控件 calendar、date、time、email、url、search</li>
<li>地理位置 Geolocation</li>
<li>多任务 webworker</li>
<li>全双工通信协议 websocket</li>
<li>历史管理 history</li>
<li>跨域资源共享(CORS) Access-Control-Allow-Origin</li>
<li>页面可见性改变事件 visibilitychange</li>
<li>跨窗口通信 PostMessage</li>
<li>Form Data 对象</li>
<li>绘画 canvas</li>
</ul>
<h2 id="1-3-伪类和伪元素"><a href="#1-3-伪类和伪元素" class="headerlink" title="1.3 伪类和伪元素"></a>1.3 伪类和伪元素</h2><p>伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的;	:hover</p>
<p>伪元素：用于创建一些不在DOM树中的元素，并为其添加样式 ;	例如，我们可以通过  :before  :after</p>
<p><strong>语义化优点</strong></p>
<ul>
<li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构</li>
<li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重</li>
<li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页</li>
<li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐</li>
</ul>
<h2 id="1-5-引入样式时，link和-import的区别？"><a href="#1-5-引入样式时，link和-import的区别？" class="headerlink" title="1.5 引入样式时，link和@import的区别？"></a>1.5 引入样式时，link和@import的区别？</h2><ul>
<li>链接样式时，link只能在HTML页面中引入外部样式</li>
<li>导入样式表时，@import 既可以在HTML页面中导入外部样式，也可以在css样式文件中导入外部css样式</li>
</ul>
<h2 id="1-10-元素的alt和title有什么不同？"><a href="#1-10-元素的alt和title有什么不同？" class="headerlink" title="1.10 元素的alt和title有什么不同？"></a>1.10 元素的alt和title有什么不同？</h2><ul>
<li>在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字</li>
</ul>
<h2 id="1-15-a标签中-如何禁用href-跳转页面-或-定位链接"><a href="#1-15-a标签中-如何禁用href-跳转页面-或-定位链接" class="headerlink" title="1.15 a标签中 如何禁用href 跳转页面 或 定位链接?"></a>1.15 a标签中 如何禁用href 跳转页面 或 定位链接?</h2><p>e.preventDefault();</p>
<p>href&#x3D;”javascript:void(0);</p>
<h2 id="1-19-前端需要注意哪些SEO"><a href="#1-19-前端需要注意哪些SEO" class="headerlink" title="1.19 前端需要注意哪些SEO"></a>1.19 前端需要注意哪些SEO</h2><p>1、合理的title、description、keywords：搜素时对这三项的权重逐个减少，title强调重点，重要关键词不要超过两次，而且要靠前，不同页面title要有所不同，description高度概括页面内容，长度合适，不过分堆砌关键词，不同页面description有所不同，keywords列出重要关键词即可</p>
<p>2、语义化的html代码，符合W3C标准</p>
<p>3、提高网站速度</p>
<p>4、重要HTML代码放前面</p>
<p>5、重要内容不要用js输出：爬虫不会执行js获取内容</p>
<p>6、少用 iframe：搜索引擎不会抓取 iframe 中的内容</p>
<p>7、非装饰性图片必须加 alt  (网站的logo)</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-1-标准盒模型和IE盒模型两者的区别是什么？"><a href="#1-1-标准盒模型和IE盒模型两者的区别是什么？" class="headerlink" title="1.1 标准盒模型和IE盒模型两者的区别是什么？"></a>1.1 标准盒模型和IE盒模型两者的区别是什么？</h2><p><strong>概念</strong></p>
<p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括： 外边距<code>（margin）</code> 、 边框</p>
<p><code>（border）</code> 、 <code>内边距（padding）</code> 、<code> 实际内容（content）</code> 四个属性</p>
<p><strong>设置盒子模型</strong></p>
<ul>
<li>box-sizing:content-box;(标准)</li>
<li>box-sizing:border-box;(IE)</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>标准的(W3C)盒模型：元素的实际宽度等于设置的宽高 + border + padding (默认方式)</li>
<li>IE盒模型： 元素的实际宽度就等于设置的宽高，即使定义有 border 和 padding 也不会改变元素的实际宽度，即 ( Element width &#x3D; width )</li>
</ul>
<h2 id="1-2-盒子塌陷是什么？"><a href="#1-2-盒子塌陷是什么？" class="headerlink" title="1.2 盒子塌陷是什么？"></a>1.2 盒子塌陷是什么？</h2><p><strong>盒子塌陷</strong></p>
<p>本应该在父盒子内部的元素跑到了外部。</p>
<p><strong>为什么会出现盒子塌陷？</strong></p>
<p>当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文</p>
<p>档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度</p>
<p>就会直接塌陷为零， 我们称这是<strong>CSS</strong>高度塌陷</p>
<p><strong>解决塌陷的方法</strong></p>
<ol>
<li>设置宽高</li>
<li>设置BFC</li>
<li>清楚浮动</li>
<li>给父盒子添加border</li>
<li>给父盒子设置padding-top</li>
</ol>
<h2 id="1-4-行内元素可以设置padding，margin吗？"><a href="#1-4-行内元素可以设置padding，margin吗？" class="headerlink" title="1.4 行内元素可以设置padding，margin吗？"></a>1.4 行内元素可以设置padding，margin吗？</h2><ul>
<li>行内元素的margin左右有效，上下无效</li>
<li>行内元素的padding左右有效 ，但是由于设置padding上下不占页面空间，无法显示效果，所以无效</li>
</ul>
<h2 id="1-6-BFC是什么？"><a href="#1-6-BFC是什么？" class="headerlink" title="1.6 BFC是什么？"></a>1.6 BFC是什么？</h2><p><strong>文档有几种流</strong></p>
<ol>
<li>定位流<ul>
<li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li>
<li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li>
<li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li>
<li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、</li>
<li>absolute，如果没有则相对于body；</li>
</ul>
</li>
<li>浮动流<ul>
<li>左浮动元素尽量靠左、靠上，右浮动同理</li>
<li>这导致常规流环绕在它的周边，除非设置 clear 属性</li>
<li>浮动元素不会影响块级元素的布局</li>
<li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li>
<li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li>
<li>不超过它的包含块，除非元素本身已经比包含块更宽</li>
<li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的</li>
<li>右边是不会摆放浮动元素的</li>
</ul>
</li>
<li>普通流<ul>
<li>在常规流中，盒一个接着一个排列;</li>
<li>在块级格式化上下文里面， 它们竖着排列；</li>
<li>在行内格式化上下文里面， 它们横着排列;</li>
<li>当position为static或relative，并且float为none时会触发常规流；</li>
<li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li>
<li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、</li>
<li>left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li>
</ul>
</li>
</ol>
<p><strong>定义</strong></p>
<p>BFC的基本概念–BFC就是“<strong>块级格式化上下文</strong>”的意思，也有译作“块级格式化范围”。</p>
<p>通俗的讲，就是一个特殊的块，内部有自己的布局方式，不受外边元素的影响。</p>
<p><strong>布局规则</strong></p>
<ol>
<li>内部的 Box 会在垂直方向，一个接一个地放置</li>
<li>垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）</li>
<li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li>
<li>BFC的区域不会与float的元素区域重叠</li>
<li>计算BFC的高度时，浮动子元素也参与计算</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li>
</ol>
<p><strong>哪些元素会创建 BFC</strong></p>
<ol>
<li>根元素</li>
<li>float 属性不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 为 inline-block， table-cell， table-caption， flex， inline-flex</li>
<li>overflow 不为 visible</li>
</ol>
<p><strong>场景</strong></p>
<ol>
<li><p><strong>清除元素内部浮动</strong></p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。</p>
<p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p>
</li>
<li><p><strong>解决外边距合并问题(嵌套崩塌)</strong></p>
<p>外边距合并的问题。</p>
<p>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p>
</li>
<li><p><strong>制作右侧自适应的盒子问题</strong></p>
<p>普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</p>
</li>
</ol>
<h2 id="1-7-块元素居中"><a href="#1-7-块元素居中" class="headerlink" title="1.7 块元素居中"></a>1.7 块元素居中</h2><ul>
<li><p>我们可以利用<strong>margin:0 auto</strong>来实现元素的水平居中。</p>
</li>
<li><p>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</p>
</li>
<li><p>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。</p>
</li>
<li><p>!!!利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。</p>
</li>
<li><p>!!!使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p>
</li>
</ul>
<p>对于宽高不定的元素，后面两种方法，可以实现元素的垂直和水平的居中。</p>
<h2 id="1-8-CSS-优化、提高性能的方法有哪些？"><a href="#1-8-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="1.8 CSS 优化、提高性能的方法有哪些？"></a>1.8 CSS 优化、提高性能的方法有哪些？</h2><p><strong>加载性能：</strong></p>
<ul>
<li>css压缩：将写好的css进行打包压缩，可以减小文件体积</li>
<li>css单一样式：当需要下边距和左边距的时候，很多时候会选择使用margin-left:20px;margin-bottom:30px</li>
<li>减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载</li>
</ul>
<p><strong>选择器性能：</strong></p>
<ul>
<li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。</li>
<li>当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等</li>
<li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。</li>
<li>过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li>
<li>尽量少的去对标签进行选择，而是用class。</li>
<li>尽量少的去使用后代选择器，降低选择器的权重值。后</li>
<li>代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li>
</ul>
<p><strong>渲染性能：</strong></p>
<ul>
<li>属性值为0时，不加单位。</li>
<li>可以省略小数点之前的0。</li>
<li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li>
<li>选择器优化嵌套，尽量避免层级过深。</li>
<li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li>
<li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li>
</ul>
<p><strong>可维护性、健壮性：</strong></p>
<ul>
<li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li>
<li>样式与内容分离：将css代码定义到外部css中</li>
</ul>
<h2 id="1-11-浏览器是怎样解析CSS选择器的？"><a href="#1-11-浏览器是怎样解析CSS选择器的？" class="headerlink" title="1.11 浏览器是怎样解析CSS选择器的？"></a>1.11 浏览器是怎样解析CSS选择器的？</h2><p>CSS选择器的解析是从右向左解析的</p>
<p><strong>原因：</strong></p>
<p>从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点(叶子节点)，而从左向右的匹配规则的性能都浪</p>
<p>费在了失败的查找上面</p>
<h2 id="1-13-display、position和float的相互关系？"><a href="#1-13-display、position和float的相互关系？" class="headerlink" title="1.13 display、position和float的相互关系？"></a>1.13 display、position和float的相互关系？</h2><ul>
<li>首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现</li>
<li>然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被 设置为table或者block，具体转换需要看初始转换值</li>
<li>如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display 的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对 于浮动后的最终位置定位</li>
<li>如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是， 则保持指定的display属性值不变</li>
</ul>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在 的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素 的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h2 id="1-14-IFC-是什么？"><a href="#1-14-IFC-是什么？" class="headerlink" title="1.14 IFC 是什么？"></a>1.14 IFC 是什么？</h2><p>IFC指的是<strong>行级格式化上下文</strong>，它有这样的一些布局规则：</p>
<ul>
<li>行级上下文内部的盒子会在水平方向，一个接一个地放置。</li>
<li>当一行不够的时候会自动切换到下一行。&#x20;</li>
<li>行级上下文的高度由内部最高的内联盒子的高度决定</li>
</ul>
<h2 id="1-15-为什么不建议使用通配符初始化-css-样式"><a href="#1-15-为什么不建议使用通配符初始化-css-样式" class="headerlink" title="1.15 为什么不建议使用通配符初始化 css 样式"></a>1.15 为什么不建议使用通配符初始化 css 样式</h2><ul>
<li>采用*{pading:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时， 样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一 套初始化样式</li>
<li>出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即 可，并不需使用通配符*来初始化</li>
</ul>
<h2 id="1-16-CSS3-新特新"><a href="#1-16-CSS3-新特新" class="headerlink" title="1.16 CSS3 新特新"></a>1.16 CSS3 新特新</h2><ol>
<li>新增各种 CSS 选择器 <code> :not(p) </code> 选择每个非p的元素； <code>p:empty</code> 选择每个没有任何子级的p元素（包括文本节点）</li>
<li>边框（Borders）</li>
<li>背景 background-clip（规定背景图的绘制区域），background-origin，background-size</li>
<li>线性渐变 （Linear Gradients） 向下&#x2F;向上&#x2F;向左&#x2F;向右&#x2F;对角方向</li>
<li>文本效果 阴影text-shadow，textwrap，word-break，word-wrap</li>
<li>2D 转换 transform:scale(0.85,0.90) | translate(0px,-30px) | skew(-9deg,0deg) |rotate()  <strong>3D转换</strong> perspective()；transform是向元素应用 2D 或者 3D 转换</li>
<li>过渡 transition</li>
<li>动画</li>
<li>多列布局 （multi-column layout）</li>
<li>盒模型</li>
<li>flex 布局</li>
<li>多媒体查询 **定义两套css，当浏览器的尺寸变化时会采用不同的属性</li>
</ol>
<h2 id="1-18-什么是CSS-预处理器？为什么使用？"><a href="#1-18-什么是CSS-预处理器？为什么使用？" class="headerlink" title="1.18 什么是CSS 预处理器？为什么使用？"></a>1.18 什么是CSS 预处理器？为什么使用？</h2><ul>
<li>Less、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率</li>
</ul>
<p><strong>为什么要使用？</strong></p>
<ul>
<li>可嵌套性</li>
<li>变量</li>
<li>Mixins(混合@mixin)：可重用性高，可以注入任何东西</li>
<li>@extend：允许一个选择器继承另一个选择器</li>
<li>@function:函数功能，用户使用@function 可以去编写自己的函数</li>
<li>引用父元素&amp;：在编译时，&amp;将被替换成父选择符</li>
<li>计算功能</li>
<li>组合连接： #{} :变量连接字符串</li>
<li>循环语句：（很少用到）</li>
<li>if 语句：（很少用到）</li>
</ul>
<h2 id="1-19-浏览器是怎样解析的？"><a href="#1-19-浏览器是怎样解析的？" class="headerlink" title="1.19 浏览器是怎样解析的？"></a>1.19 浏览器是怎样解析的？</h2><ol>
<li>HTML 被 HTML 解析器解析成 DOM 树；2. CSS 被 CSS 解析器解析成 CSSOM 树；</li>
<li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li>
<li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li>
<li>将布局绘制(paint)在屏幕上，显示出整个页面。</li>
</ol>
<h2 id="1-23-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#1-23-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="1.23 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>1.23 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><p>行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>可以将代码全部写在一排</li>
<li>浮动li中float：left</li>
<li><strong>在ul中用font-size：0（谷歌不支持</strong>）；</li>
<li>可以将 ul{letter-spacing: -4px;};li{letter-spacing: normal;}</li>
</ol>
<h2 id="1-24-display-inline-block-什么时候会显示间隙？"><a href="#1-24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="1.24 display:inline-block 什么时候会显示间隙？"></a>1.24 display:inline-block 什么时候会显示间隙？</h2><ol>
<li>有空格时候会有间隙 解决：s除空格</li>
<li>margin正值的时候 解决：margin使用负值</li>
<li>使用font-size时候 解决：font-size:0、letter-spacing、word-spacing</li>
</ol>
<h2 id="1-27-before-和-after-中双冒号和单冒号有什么区别、作用？"><a href="#1-27-before-和-after-中双冒号和单冒号有什么区别、作用？" class="headerlink" title="1.27 ::before 和::after 中双冒号和单冒号有什么区别、作用？"></a>1.27 ::before 和::after 中双冒号和单冒号有什么区别、作用？</h2><p><strong>区别</strong></p>
<p>在css中伪类一直用:表示，如 <code>:hover</code>，<code>:active</code>等</p>
<p>伪元素在CSS1中已存在，当时语法使用 : 表示 ，如：<code>:before</code>和<code>:after</code></p>
<p>后来在CSS3中修订，伪元素用 ::表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类</p>
<p>由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</p>
<p>单冒号<code>:</code> CSS3表示伪类；双冒号<code>::</code>CSS3伪元素</p>
<h2 id="1-29-未知高度元素垂直居中、垂直居中的实现方式有哪些？"><a href="#1-29-未知高度元素垂直居中、垂直居中的实现方式有哪些？" class="headerlink" title="1.29 未知高度元素垂直居中、垂直居中的实现方式有哪些？"></a>1.29 未知高度元素垂直居中、垂直居中的实现方式有哪些？</h2><ol>
<li>绝对定位+css3 transform:translate(-50%，-50%)</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">	-webkit-<span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>css3</strong> 的flex布局</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:flex;</span><br><span class="line">	<span class="attribute">justify-content</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">	<span class="attribute">align-self</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>table布局</li>
</ol>
<h2 id="1-34-移动端适配方案"><a href="#1-34-移动端适配方案" class="headerlink" title="1.34 移动端适配方案"></a>1.34 移动端适配方案</h2><ol>
<li><strong>viewport</strong> <strong>适配</strong></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=750,initial-scale=0.5&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">initial-scale = 屏幕的宽度 / 设计稿的宽度</span></span><br><span class="line"><span class="comment">为了适配其他屏幕，需要动态的设置 initial-scale 的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = <span class="number">750</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">mobileAdapter</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> scale = screen.<span class="property">width</span> / <span class="variable constant_">WIDTH</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> content = <span class="string">`width=<span class="subst">$&#123;WIDTH&#125;</span>, initial-scale=<span class="subst">$&#123;scale&#125;</span>, maximumscale=<span class="subst">$&#123;scale&#125;</span>, minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> meta = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=viewport]&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (!meta) &#123;</span></span><br><span class="line"><span class="language-javascript">meta = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;meta&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">meta.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(meta)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">meta.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>,content)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">mobileAdapter</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onorientationchange</span> = mobileAdapter <span class="comment">//屏幕翻转时再次执行</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好</p>
<ol start="2">
<li><p><strong>vw</strong> <strong>适配（部分等比缩放）</strong></p>
<ul>
<li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li>
<li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100&#x2F;750)*32 vw</li>
<li>对于需要等比缩放的元素，CSS使用转换后的单位</li>
<li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximumscale=1, minimum-scale=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = <span class="number">750</span></span></span><br><span class="line"><span class="language-javascript">	<span class="comment">//:root &#123; --width: 0.133333 &#125; 1像素等于多少 vw</span></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--width&#x27;</span>, (<span class="number">100</span> / <span class="variable constant_">WIDTH</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rem适配</strong></p>
</li>
<li><p><strong>弹性盒适配（合理布局）</strong></p>
</li>
</ol>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-1-let-var-const的区别？"><a href="#1-1-let-var-const的区别？" class="headerlink" title="1.1 let var const的区别？"></a>1.1 let var const的区别？</h2><p><strong>var ES5变量声明方式</strong></p>
<ol>
<li>在变量未赋值时，变量undefined（为使用声明变量时也为undefined）</li>
<li>作用域 var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</li>
</ol>
<p><strong>let ES6变量声明方式</strong></p>
<ol>
<li>在变量为声明前直接使用会报错</li>
<li>作用域   let为块级作用域   通常let比var范围要小</li>
<li>let进制重复声明变量，否则会报错；var可以重复声明</li>
</ol>
<p><strong>const ES6变量声明</strong></p>
<ol>
<li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值</li>
<li>const实际上保证的，并不是变量的值不得改动，而时变量指向的哪个内存地址不得改动</li>
</ol>
<h2 id="1-2-js数据类型，区别"><a href="#1-2-js数据类型，区别" class="headerlink" title="1.2 js数据类型，区别"></a>1.2 js数据类型，区别</h2><p><strong>基本数据类型：</strong></p>
<p>number，string，boolean，null，undefined，symbol，bigint</p>
<p><strong>引用数据类型：</strong></p>
<p>object，function</p>
<p>object：普通对象，数组对象，正则对象，日期对象，math数学函数对象。</p>
<h2 id="1-3-Javascript-创建对象的几种方式？"><a href="#1-3-Javascript-创建对象的几种方式？" class="headerlink" title="1.3 Javascript 创建对象的几种方式？"></a>1.3 <strong>Javascript 创建对象的几种方式？</strong></h2><ol>
<li>简单对象的创建 使用对象字面量的方式{}</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Cat</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>new 一个function</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personOne=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用工厂方式来创建（Object 关键字）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wcDog =<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 Object.create() 创建对象（使用现有对象作为原型）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(anotherPerson);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-4-、-和object-is-区别"><a href="#1-4-、-和object-is-区别" class="headerlink" title="1.4 &#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和object.is 区别"></a>1.4 &#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和object.is 区别</h2><ol>
<li>&#x3D;&#x3D; 值比较值</li>
<li>&#x3D;&#x3D;&#x3D;值和类型都比较</li>
<li>object.is 和 &#x3D;&#x3D;&#x3D; 区别  +-0 false   NaN true</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === -<span class="number">0</span>);       <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>);     <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>,-<span class="number">0</span>)              <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>,<span class="title class_">NaN</span>)            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="1-5-如何区分数组和对象？"><a href="#1-5-如何区分数组和对象？" class="headerlink" title="1.5 如何区分数组和对象？"></a>1.5 如何区分数组和对象？</h2><ol>
<li>通过 ES6 中的 Array.isArray</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 instanceof 来识别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过调用 constructor 来识别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.<span class="property">constructor</span> <span class="comment">//返回 object</span></span><br><span class="line">[].<span class="property">constructor</span> <span class="comment">//返回 Array</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 Object.prototype.toString.call 方法来识别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">//[&quot;object Array&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">//[&quot;object Object&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-作用域和作用域链"><a href="#1-6-作用域和作用域链" class="headerlink" title="1.6 作用域和作用域链"></a>1.6 作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离<br>变量，不同作用域下同名变量不会有冲突</p>
<ol>
<li>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。</li>
<li>ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现</li>
</ol>
<p><strong>什么是作用域链？</strong></p>
<ul>
<li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链</p>
</li>
<li><p>由子级作用域返回父级作用域中寻找变量，就叫做作用域链</p>
</li>
<li><p>作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自中的最后一个对象</p>
</li>
<li><p>作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象</p>
</li>
</ul>
<p><strong>如何延长作用域链？</strong></p>
<p>执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除具体来说就是执行这两个语句时，作用域链都会得到加强</p>
<ol>
<li><p>try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明</p>
</li>
<li><p>with 语句。with 语句会将指定的对象添加到作用域链中</p>
</li>
</ol>
<h2 id="1-7-constructor的理解"><a href="#1-7-constructor的理解" class="headerlink" title="1.7 constructor的理解"></a>1.7 constructor的理解</h2><p>创建的每个函数都有一个prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，之后属性是一个指向prototype属性坐在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。注意当将构造函数的prototype设置为等于一个以对象字面量形式创建的新对象时，constructor属性不再指向该构造函数</p>
<h2 id="1-10-map-和-forEach-的区别？"><a href="#1-10-map-和-forEach-的区别？" class="headerlink" title="1.10 map 和 forEach 的区别？"></a>1.10 map 和 forEach 的区别？</h2><p><strong>相同点：</strong></p>
<ol>
<li>都是循环遍历数组中的每一项</li>
<li>每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），<br>arr（原数组）</li>
<li>匿名函数中的this都是指向window</li>
<li>只能遍历数组</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</li>
<li>forEach()允许callback更改原始数组的元素。map()返回新的数组。</li>
</ol>
<h2 id="1-11-for-of-可以遍历哪些对象？"><a href="#1-11-for-of-可以遍历哪些对象？" class="headerlink" title="1.11 for of 可以遍历哪些对象？"></a>1.11 for of 可以遍历哪些对象？</h2><p>for..of..: 它是es6新增的一个遍历方法，但只限于迭代器(iterator), 所以普通的对象用for..of遍历<br>是会报错的。<br>可迭代的对象：包括Array, Map, Set, String, TypedArray, arguments对象等等</p>
<h2 id="1-11-js遍历对象的方法？"><a href="#1-11-js遍历对象的方法？" class="headerlink" title="1.11 js遍历对象的方法？"></a>1.11 js遍历对象的方法？</h2><ol>
<li><code>for...in</code> 循环</li>
<li><code>Object.keys()</code> 方法</li>
<li><code>Object.entries()</code> 方法</li>
</ol>
<h2 id="1-13-new操作符具体干了什么呢"><a href="#1-13-new操作符具体干了什么呢" class="headerlink" title="1.13 new操作符具体干了什么呢?"></a>1.13 new操作符具体干了什么呢?</h2><ol>
<li>创建空对象；<br>var obj &#x3D; {};</li>
<li>设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的<br>prototype对象；<br>obj.proto &#x3D; ClassA.prototype;<br>扩展了新对象的原型链。</li>
<li>使用新对象调用函数，函数中的this被指向新实例对象：<br>ClassA.call(obj); &#x2F;&#x2F;{}.构造函数();</li>
<li>返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。</li>
</ol>
<h2 id="1-14-作用域"><a href="#1-14-作用域" class="headerlink" title="1.14 作用域"></a>1.14 作用域</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离<br>变量，不同作用域下同名变量不会有冲突</p>
<ol>
<li>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。</li>
<li>ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现</li>
</ol>
<h2 id="1-15-javascript中arguments相关的问题"><a href="#1-15-javascript中arguments相关的问题" class="headerlink" title="1.15 javascript中arguments相关的问题"></a>1.15 javascript中arguments相关的问题</h2><p><strong>arguments</strong><br>在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一<br>个叫arguments的对象里面。它是一个类数组数据<br><strong>作用</strong><br>有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函<br>数加入参数</p>
<h2 id="1-16-instanceOf作用-即原理"><a href="#1-16-instanceOf作用-即原理" class="headerlink" title="1.16 instanceOf作用 即原理"></a>1.16 instanceOf作用 即原理</h2><p>instanceof主要作用就是判断一个实例是否属于某种类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rightProto = rightVaule.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">    leftVaule = leftVaule.<span class="property">__proto__</span>; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftVaule === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leftVaule = leftVaule.<span class="property">__proto__</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p>
<h2 id="1-17-数组和伪数组的区别"><a href="#1-17-数组和伪数组的区别" class="headerlink" title="1.17 数组和伪数组的区别?"></a>1.17 数组和伪数组的区别?</h2><ol>
<li>定义</li>
</ol>
<ul>
<li>数组是一个特殊对象,与常规对象的区别：<ul>
<li>当由新元素添加到列表中时，自动更新length属性</li>
<li>设置length属性，可以截断数组</li>
<li>从Array.protoype中继承了方法</li>
<li>属性为’Array’</li>
</ul>
</li>
<li>类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。</li>
</ul>
<ol start="2">
<li>区别<br>本质：类数组是简单对象，它的原型关系与数组不同</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike.<span class="title function_">toString</span>()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike.<span class="title function_">valueOf</span>()); <span class="comment">// &#123;length: 10&#125;</span></span><br><span class="line"><span class="keyword">let</span> array = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">toString</span>()); <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">valueOf</span>()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>类数组转换为数组</li>
</ol>
<ul>
<li><p>转换方法</p>
<ul>
<li>使用 Array.from()</li>
<li>使用 Array.prototype.slice.call()</li>
<li>使用 Array.prototype.forEach() 进行属性遍历并组成新的数组</li>
</ul>
</li>
</ul>
<h2 id="1-19-简单说说-js-中有哪几种内存泄露的情况"><a href="#1-19-简单说说-js-中有哪几种内存泄露的情况" class="headerlink" title="1.19 简单说说 js 中有哪几种内存泄露的情况"></a>1.19 简单说说 js 中有哪几种内存泄露的情况</h2><ol>
<li>意外的全局变量；</li>
<li>闭包；</li>
<li>未被清空的定时器；</li>
<li>未被销毁的事件监听；</li>
<li>DOM 引用；</li>
</ol>
<h2 id="1-23-promise和-async-await-区别"><a href="#1-23-promise和-async-await-区别" class="headerlink" title="1.23 promise和 async await 区别?"></a>1.23 promise和 async await 区别?</h2><p><strong>概念</strong><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强<br>大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而<br>这些结果一旦生成是无法改变的<br>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执<br>行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象<br><strong>两者的区别</strong></p>
<ol>
<li>Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向<br>发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async<br>await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同<br>于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li>
<li>async await与Promise一样，是非阻塞的。</li>
<li>async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函<br>数。</li>
</ol>
<h2 id="1-24-defer和async区别"><a href="#1-24-defer和async区别" class="headerlink" title="1.24 defer和async区别?"></a>1.24 defer和async区别?</h2><ul>
<li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。多个defer脚本会按照它们在页面出现的顺序加载。&#x3D;&#x3D;“渲染完再执行”&#x3D;&#x3D;</li>
<li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本是不能保证加载顺序的。&#x3D;&#x3D;“下载完就执行”&#x3D;&#x3D;</li>
</ul>
<h2 id="1-25-同步和异步"><a href="#1-25-同步和异步" class="headerlink" title="1.25 同步和异步"></a>1.25 同步和异步</h2><p><strong>同步</strong></p>
<ul>
<li>指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。</li>
<li>也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序<br>和任务排列顺序是一致的。</li>
</ul>
<p><strong>异步</strong></p>
<ul>
<li>异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</li>
<li>每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。</li>
<li>程序的执行顺序和任务的排列顺序是不一致的，异步的。</li>
<li>我们常用的setTimeout和setInterval函数，Ajax都是异步操作。</li>
</ul>
<h2 id="1-27-null-和-undefined-的区别，如何让一个属性变为null"><a href="#1-27-null-和-undefined-的区别，如何让一个属性变为null" class="headerlink" title="1.27 null 和 undefined 的区别，如何让一个属性变为null"></a>1.27 null 和 undefined 的区别，如何让一个属性变为null</h2><p><strong>undefined</strong></p>
<ol>
<li>声明了一个变量，但没有赋值</li>
<li>访问对象上不存在的属性</li>
<li>函数定义了形参，但没有传递实参</li>
<li>使用 void 对表达式求值</li>
</ol>
<p><strong>null</strong></p>
<ol>
<li>null是一个空值</li>
<li>null 有属于自己的类型 Null，而不属于Object类型</li>
<li>二进制的前三位为 0 会被 typeof 判断为对象类型</li>
</ol>
<h2 id="1-29-call-appy-bind的作用和区别？"><a href="#1-29-call-appy-bind的作用和区别？" class="headerlink" title="1.29 call appy bind的作用和区别？"></a>1.29 call appy bind的作用和区别？</h2><p><strong>作用：</strong></p>
<p>都可以改变函数内部的this指向</p>
<p><strong>区别点：</strong></p>
<ol>
<li>call 和 apply 会调用函数，并且改变函数内部this指向。</li>
<li>call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg]</li>
<li>bind 不会调用函数，可以改变函数内部this指向</li>
</ol>
<h2 id="1-30-this指向（普通函数、箭头函数）"><a href="#1-30-this指向（普通函数、箭头函数）" class="headerlink" title="1.30 this指向（普通函数、箭头函数）"></a>1.30 this指向（普通函数、箭头函数）</h2><ol>
<li>谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁</li>
<li>匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象</li>
</ol>
<p><strong>箭头函数中的this</strong></p>
<ul>
<li>箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的</li>
<li>箭头函数中的this指向父级作用域的执行上下文；</li>
<li>箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来</li>
</ul>
<h2 id="1-32-继承，优缺点-及方法有哪些？"><a href="#1-32-继承，优缺点-及方法有哪些？" class="headerlink" title="1.32 继承，优缺点 及方法有哪些？"></a>1.32 继承，优缺点 及方法有哪些？</h2><p><strong>继承的好处</strong></p>
<p>a：提高了代码的复用性</p>
<p>b：提高了代码的维护性</p>
<p>c：让类与类之间产生了关系，是多态的前提</p>
<p><strong>继承的弊端</strong></p>
<p>类的耦合性增强了,但是开发的原则：高内聚，低耦合</p>
<h3 id="1-32-1原型链继承"><a href="#1-32-1原型链继承" class="headerlink" title="1.32.1原型链继承"></a>1.32.1原型链继承</h3><p>实现方式：将子类的原型链指向父类的对象实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">list</span> = [<span class="string">&#x27;坤&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>);	</span><br><span class="line">child.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p><strong>原理：</strong>子类实例child的<code>__proto__</code> 指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的 <code>__proto__</code> 指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法</p>
<p><strong>优点：</strong>可继承构造函数的属性，父类构造函数的属性，父类原型的属性</p>
<p><strong>缺点：</strong></p>
<ol>
<li>无法向父类构造函数传参；</li>
<li>共享父类实例的属性（若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">a.<span class="property">list</span>.<span class="title function_">push</span>(<span class="string">&#x27;rap&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">list</span>); <span class="comment">// [&#x27;坤&#x27;,&#x27;rap&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="1-32-2-构造函数继承"><a href="#1-32-2-构造函数继承" class="headerlink" title="1.32.2 构造函数继承"></a>1.32.2 构造函数继承</h3><p>实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, id) <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;坤&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">child.<span class="title function_">printName</span>() 	<span class="comment">// 坤</span></span><br><span class="line">child.<span class="title function_">sayName</span>() 	<span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><strong>原理：</strong>使用call或者apply改变子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性</p>
<p>优点：可解决原型链继承 <strong>共享</strong> 的问题</p>
<p>缺点： 不可继承父类的原型方法，构造函数不可以被复用</p>
<h3 id="1-32-3-组合继承"><a href="#1-32-3-组合继承" class="headerlink" title="1.32.3 组合继承"></a>1.32.3 组合继承</h3><p><strong>原理：</strong>综合使用构造函数继承和原型链继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="string">&#x27;rap&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, id);	<span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;坤坤&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">child.<span class="title function_">printName</span>(); 	<span class="comment">// 坤坤</span></span><br><span class="line">child.<span class="title function_">sayName</span>() 	<span class="comment">// 坤坤</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">a.<span class="property">list</span>.<span class="title function_">push</span>(<span class="string">&#x27;篮球&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">list</span>); <span class="comment">// [&#x27;rap&#x27;]    </span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的</p>
<p><strong>缺点：</strong>会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数</p>
<h3 id="1-32-4-原型式继承"><a href="#1-32-4-原型式继承" class="headerlink" title="1.32.4 原型式继承"></a>1.32.4 原型式继承</h3><p><strong>原理：</strong>类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的 	<code>__proto__</code> 指向父对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">	<span class="attr">name</span>: [<span class="string">&#x27;坤坤&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">	fn.<span class="property"><span class="keyword">prototype</span></span> = object</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">copy</span>(parent)</span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong> 共享引用数据类型</p>
<h3 id="1-32-5-寄生式继承"><a href="#1-32-5-寄生式继承" class="headerlink" title="1.32.5 寄生式继承"></a>1.32.5 寄生式继承</h3><p><strong>原理：</strong>扩展原型式继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">	fn.<span class="property"><span class="keyword">prototype</span></span> = object</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> obj = <span class="title function_">copy</span>(obj);</span><br><span class="line">	obj.<span class="property">getNames</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">names</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">names</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>可添加新的属性和方法</p>
<h3 id="1-32-6-寄生组合式继承"><a href="#1-32-6-寄生组合式继承" class="headerlink" title="1.32.6 寄生组合式继承"></a>1.32.6 寄生组合式继承</h3><p><strong>原理：</strong>改进组合继承，利用寄生式继承的思想继承原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subClass, superClass</span>) &#123;</span><br><span class="line">	<span class="comment">// 复制一份父类的原型</span></span><br><span class="line">	<span class="keyword">let</span> p = <span class="title function_">copy</span>(superClass.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">	<span class="comment">// 修正构造函数</span></span><br><span class="line">	p.<span class="property">constructor</span> = subClass;</span><br><span class="line">	<span class="comment">// 设置子类原型</span></span><br><span class="line">	subClass.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, id);</span><br><span class="line"><span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-32-7-ES6-class-extends"><a href="#1-32-7-ES6-class-extends" class="headerlink" title="1.32.7 ES6 class extends"></a>1.32.7 ES6 class extends</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">super</span>();</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">b</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<h2 id="1-33-扩展运算符-…"><a href="#1-33-扩展运算符-…" class="headerlink" title="1.33 扩展运算符 …"></a>1.33 扩展运算符 …</h2><h3 id="1-33-1哪些类型能被扩展操作符"><a href="#1-33-1哪些类型能被扩展操作符" class="headerlink" title="1.33.1哪些类型能被扩展操作符?"></a>1.33.1哪些类型能被扩展操作符?</h3><p><strong>类型：</strong>数组、对象、字符串</p>
<ul>
<li><p>复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作。</p>
</li>
<li><p>基础数据只有string可以使用扩展运算符，number,boolean,null,undefined无效</p>
</li>
</ul>
<h3 id="1-33-2-场景"><a href="#1-33-2-场景" class="headerlink" title="1.33.2 场景"></a>1.33.2 场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、函数调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(...[<span class="number">4</span>, <span class="number">38</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, c, d, e</span>) &#123; &#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, ...[<span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>, ...[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.往数组里push多个元素</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;子异&#x27;</span>, <span class="string">&#x27;坤坤&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;说&#x27;</span>, <span class="string">&#x27;唱&#x27;</span>, <span class="string">&#x27;跳&#x27;</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[&#x27;子异&#x27;, &#x27;坤坤&#x27;,&#x27;说&#x27;, &#x27;唱&#x27;, &#x27;跳&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.替代函数的apply方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args); 	<span class="comment">//ES5 的写法</span></span><br><span class="line"><span class="title function_">f</span>(...args); 			<span class="comment">//ES6的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.求一个数组的最大数简化</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]) <span class="comment">//ES5 的写法</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]) <span class="comment">//ES6 的写法，等同于Math.max(14, 3, 77)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.扩展运算符后面可以放表达式</span></span><br><span class="line"><span class="keyword">const</span> arr = [...(<span class="number">5</span> &gt; <span class="number">0</span> ? [<span class="string">&#x27;a&#x27;</span>] : []),<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.与解构赋值结合，用于生成数组</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1]; <span class="comment">//写法1</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1; <span class="comment">//写法2</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">//1</span></span><br><span class="line">rest <span class="comment">//[2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">//undefined</span></span><br><span class="line">rest <span class="comment">//[]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first <span class="comment">//&quot;foo&quot;</span></span><br><span class="line">rest <span class="comment">//[]</span></span><br><span class="line"><span class="comment">//1234567891011121314151617</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3] <span class="comment">//[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">//8.数组的克隆</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[0, 1, 2]</span></span><br><span class="line"><span class="comment">/* 乍一看，arr2与arr1不共用引用地址，arr2不随着arr1变化，接着往下看 */</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, [<span class="number">1</span>,<span class="number">11</span>,<span class="number">111</span>], <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[0, [100,11,111], 2]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-34-实现异步的方法"><a href="#1-34-实现异步的方法" class="headerlink" title="1.34 实现异步的方法"></a>1.34 实现异步的方法</h2><h3 id="1-34-1-回调函数"><a href="#1-34-1-回调函数" class="headerlink" title="1.34.1 回调函数"></a>1.34.1 回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 处理逻辑</span></span><br><span class="line">    <span class="title function_">ajax</span>(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="title function_">ajax</span>(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>简单、容易理解和实现</p>
<p><strong>缺点：</strong>不利阅读和维护，耦合度高，不能使用try…catch捕获，不能直接 return</p>
<h3 id="1-34-2-promise"><a href="#1-34-2-promise" class="headerlink" title="1.34.2 promise"></a>1.34.2 promise</h3><p>本意是承诺，<strong>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了</strong></p>
<p><strong>Promise的三种状态</strong></p>
<ul>
<li><p>Pending—-Promise对象实例创建时候的初始状态</p>
</li>
<li><p>Fulfilled—-可以理解为成功的状态</p>
</li>
<li><p>Rejected—-可以理解为失败的状态</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)<span class="comment">//无效代码不会执行</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(reason)<span class="comment">//reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>promise的链式调用</p>
<ul>
<li><p>每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)</p>
</li>
<li><p>如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调</p>
</li>
<li><p>如果then中出现异常,会走下一个then的失败回调</p>
</li>
<li><p>在 then中使用了return，那么 return 的值会被Promise.resolve() 包装(见例1，2)</p>
</li>
<li><p>then中可以不传递参数，如果不传递会透到下一个then中(见例3)</p>
</li>
<li><p>catch 会捕获到没有捕获的异常</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">//包装成 Promise.resolve(2)</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="number">3</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="title function_">ajax</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">ajax</span>(url1)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">ajax</span>(url2)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>

<p>存在一个缺点：无法取消promise，错误需要通过回调函数捕获</p>
<h3 id="1-34-3-生成器generator-yield"><a href="#1-34-3-生成器generator-yield" class="headerlink" title="1.34.3 生成器generator&#x2F;yield"></a>1.34.3 生成器generator&#x2F;yield</h3><p><strong>特点：</strong>控制函数的执行</p>
<ul>
<li>Generator 函数是一个状态机，封装了多个内部状态</li>
<li>Generator 函数除了状态机，还是一个遍历器对象生成函数</li>
<li>可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果</li>
<li>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))      </span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">5</span>)           </span><br><span class="line">    <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) 		<span class="comment">// =&gt; &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">20</span>))	<span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">30</span>)) 	<span class="comment">// =&gt; &#123;value: 72, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决回调地狱</span></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="title function_">ajax</span>(url, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">	<span class="keyword">yield</span> <span class="title function_">ajax</span>(url1, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">	<span class="keyword">yield</span> <span class="title function_">ajax</span>(url2, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">fetch</span>()</span><br><span class="line"><span class="keyword">let</span> result1 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result2 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result3 = it.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure>

<h3 id="1-34-3-async-await"><a href="#1-34-3-async-await" class="headerlink" title="1.34.3 async&#x2F;await"></a>1.34.3 async&#x2F;await</h3><p><strong>特点：</strong></p>
<ul>
<li>async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数</li>
<li>async&#x2F;await与Promise一样，是非阻塞的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;async&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()) <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: &quot;async&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>类似generator调用方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">ff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">ajax</span>(url1, <span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">ajax</span>(url2,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">ajax</span>(url3,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">ff</span>()</span><br></pre></td></tr></table></figure>

<p>模拟一个并发请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">read1</span>()</span><br><span class="line">	<span class="title function_">read2</span>()<span class="comment">//这个函数同步执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">read1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">await</span> <span class="title function_">ajax</span>(url1,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">read2</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> r = <span class="keyword">await</span> <span class="title function_">ajax</span>(url2,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">readAll</span>()</span><br></pre></td></tr></table></figure>

<h2 id="1-36-为什么js是单线程"><a href="#1-36-为什么js是单线程" class="headerlink" title="1.36 为什么js是单线程"></a>1.36 为什么js是单线程</h2><p><strong>用途：</strong>js在创立之初主要是应用于用户与浏览器的交互，以及操作dom，这一特性决定了，只能是单线程，否则会带来复杂的同步问题。</p>
<p>​		例如： 如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom，这时候就不能处理。避免这个问题，浏览器就设计了单线程，避免了这个麻烦</p>
<h2 id="1-37-死锁"><a href="#1-37-死锁" class="headerlink" title="1.37 死锁"></a>1.37 死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</p>
<p><strong>产生原因：</strong></p>
<ul>
<li>竞争资源引起进程死锁</li>
<li>可剥夺和非剥夺资源</li>
<li>竞争非剥夺资源</li>
<li>竞争临时性资源</li>
<li>进程推进顺序不当</li>
</ul>
<p><strong>产生条件：</strong></p>
<ol>
<li><p>互斥条件：涉及的资源是非共享的</p>
<ul>
<li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li>
</ul>
</li>
<li><p>不剥夺条件：不能强行剥夺进程拥有的资源</p>
<ul>
<li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li>
</ul>
</li>
<li><p>请求和保持条件：进程在等待一新资源时继续占有已分配的资源</p>
<ul>
<li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li>
</ul>
</li>
</ol>
<p>解决办法</p>
<p>只要打破四个必要条件中的一个就能有效防止死锁的发生</p>
<h2 id="1-38-暂时性死区"><a href="#1-38-暂时性死区" class="headerlink" title="1.38 暂时性死区"></a>1.38 暂时性死区</h2><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<p>let 、const具有暂时性死区</p>
<p>var 不具有暂时性死区</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="1-1-cookie-sessionStorage-localStorage-区别"><a href="#1-1-cookie-sessionStorage-localStorage-区别" class="headerlink" title="1.1 cookie sessionStorage localStorage 区别"></a><strong>1.1 cookie sessionStorage localStorage</strong> <strong>区别</strong></h2><p><strong>共同点：</strong></p>
<p>都是保存在浏览器端、且同源的</p>
<p><strong>区别：</strong></p>
<ol>
<li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p>
</li>
<li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 </p>
</li>
<li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 </p>
</li>
<li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </p>
</li>
<li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p>
</li>
<li><p>Storage的api接口使用更方便</p>
</li>
</ol>
<h2 id="1-2-如何写一个会过期的localStorage，说说想法"><a href="#1-2-如何写一个会过期的localStorage，说说想法" class="headerlink" title="1.2 如何写一个会过期的localStorage，说说想法"></a>1.2 如何写一个会过期的localStorage，说说想法</h2><p><strong>惰性删除 和 定时删除</strong></p>
<p><strong>惰性删除</strong></p>
<p>惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lsc = (<span class="keyword">function</span> (<span class="params">self</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> prefix = <span class="string">&#x27;lsc_&#x27;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 增加一个键值对数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expires 过期时间，单位为秒</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    self.<span class="property">set</span> = <span class="keyword">function</span>(<span class="params">key, val, expires</span>) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        val = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&#x27;val&#x27;</span>: val, <span class="string">&#x27;expires&#x27;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + expires * <span class="number">1000</span>&#125;);</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, val);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取对应键的值数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns</span> &#123;<span class="type">null|*</span>&#125; 对应键的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    self.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        <span class="keyword">var</span> val = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	val = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val.<span class="property">expires</span> &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()) &#123;</span><br><span class="line">            <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> val.<span class="property">val</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p><strong>定时删除</strong></p>
<p>定时删除是指，每隔一段时间执行一次删除操作</p>
<ol>
<li>随机测试20个设置了过期时间的key。</li>
<li>删除所有发现的已过期的key。</li>
<li>若删除的key超过5个则重复<strong>步骤****1</strong>，直至重复500次。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lsc = (<span class="keyword">function</span> (<span class="params">self</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> prefix = <span class="string">&#x27;lsc_&#x27;</span></span><br><span class="line">	<span class="keyword">var</span> list = [];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    self.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">localStorage</span>);</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^&#x27;</span> + prefix);</span><br><span class="line">        <span class="keyword">var</span> temp = [];</span><br><span class="line">        <span class="comment">//遍历所有localStorage中的所有key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//找出可过期缓存的key</span></span><br><span class="line">            <span class="keyword">if</span> (reg.<span class="title function_">test</span>(keys[i])) &#123;</span><br><span class="line">                temp.<span class="title function_">push</span>(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">	&#125;;</span><br><span class="line">	self.<span class="title function_">init</span>();</span><br><span class="line">	self.<span class="property">check</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list || list.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">var</span> checkCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (checkCount &lt; <span class="number">500</span>) &#123;</span><br><span class="line">    	<span class="keyword">var</span> expireCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 随机测试20个设置了过期时间的key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * list.<span class="property">length</span>);</span><br><span class="line">            <span class="keyword">var</span> key = list[index];</span><br><span class="line">            <span class="keyword">var</span> val = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(list[index]);</span><br><span class="line">            <span class="comment">// 从list中删除被惰性删除的key</span></span><br><span class="line">            <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">                list.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">                expireCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(val);</span><br><span class="line">            <span class="comment">// 删除所有发现的已过期的key</span></span><br><span class="line">            <span class="keyword">if</span> (val.<span class="property">expires</span> &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()) &#123;</span><br><span class="line">                list.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">                <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key);</span><br><span class="line">                expireCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若删除的key不超过5个则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (expireCount &lt;= <span class="number">5</span> || list.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		checkCount++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//每隔一秒执行一次定时删除</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(self.<span class="property">check</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="1-3-localStorage-能跨域吗"><a href="#1-3-localStorage-能跨域吗" class="headerlink" title="1.3 localStorage 能跨域吗"></a>1.3 <strong>localStorage</strong> <strong>能跨域吗</strong></h2><p>不能</p>
<p><strong>解决办法</strong></p>
<ul>
<li>通过postMessage来实现跨源通信</li>
<li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li>
<li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li>
</ul>
<h2 id="1-4-memory-cache-如何开启"><a href="#1-4-memory-cache-如何开启" class="headerlink" title="1.4 memory cache 如何开启"></a><strong>1.4 memory cache</strong> <strong>如何开启</strong></h2><p>memory cache 如何开启是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，也不会生效</p>
<h2 id="1-5-localstorage的注意哪些问题"><a href="#1-5-localstorage的注意哪些问题" class="headerlink" title="1.5 localstorage的注意哪些问题"></a>1.5 localstorage的注意哪些问题</h2><ol>
<li>兼容性问题</li>
<li>localStorage在浏览器的隐私模式下面是不可读取的</li>
<li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>
<li>localStorage不能被爬虫抓取到</li>
</ol>
<h2 id="1-6-浏览器输入URL发生了什么"><a href="#1-6-浏览器输入URL发生了什么" class="headerlink" title="1.6 浏览器输入URL发生了什么"></a>1.6 浏览器输入URL发生了什么</h2><ol>
<li>URL 解析</li>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面</li>
</ol>
<h2 id="1-7-浏览器是如何渲染页面的？"><a href="#1-7-浏览器是如何渲染页面的？" class="headerlink" title="1.7 浏览器是如何渲染页面的？"></a>1.7 浏览器是如何渲染页面的？</h2><p>不同浏览器内核渲染机制有所区别</p>
<ol>
<li>HTML 被 HTML 解析器解析成 DOM 树；</li>
<li>CSS 被 CSS 解析器解析成 CSSOM 树；</li>
<li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li>
<li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li>
<li>将布局绘制(paint)在屏幕上，显示出整个页面。</li>
</ol>
<p>webkit</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810145750627.png" alt="image-20230810145750627"></p>
<p>Gecko</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810145831120.png" alt="image-20230810145831120"></p>
<h2 id="1-8-重绘、重排"><a href="#1-8-重绘、重排" class="headerlink" title="1.8 重绘、重排"></a>1.8 重绘、重排</h2><p><strong>概念</strong></p>
<ol>
<li>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树</li>
<li>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</li>
</ol>
<p><strong>区别：</strong></p>
<p>重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p>
<p><strong>引发重排</strong></p>
<ol>
<li>添加、删除可见的dom</li>
<li>元素的位置改变</li>
<li>元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</li>
<li>页面渲染初始化</li>
<li>浏览器窗口尺寸改变</li>
<li>获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存</li>
</ol>
<p><strong>优化方案</strong></p>
<p>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p>
<p>减少 reflow&#x2F;repaint：</p>
<ol>
<li><p>不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的className。</p>
</li>
<li><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。</p>
</li>
<li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会reflow 的。</p>
</li>
<li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)</p>
</li>
<li><p>不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</p>
</li>
</ol>
<h2 id="1-9-事件循环（Event-loop）"><a href="#1-9-事件循环（Event-loop）" class="headerlink" title="1.9 事件循环（Event loop）"></a>1.9 事件循环（Event loop）</h2><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环</p>
<p><strong>JavaScript 的事件分两种</strong></p>
<ol>
<li>宏任务：包括整体代码 script，setTimeout，setInterval</li>
<li>微任务：Promise.then(非 new Promise)，process.nextTick(node 中)</li>
</ol>
<p><strong>具体执行：</strong></p>
<p>事件的执行顺序——先执行宏任务，然后执行微任务，任务有同步的任务和异步的任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放在队列中，如果还有异步的宏任务，那么就会进行循环执行上述的操作</p>
<p>主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行</p>
<p><strong>详细步骤</strong>：</p>
<ol>
<li><p>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</p>
</li>
<li><p>将事件循环的当前运行宏任务设置为已选择的宏任务。</p>
</li>
<li><p>运行宏任务。</p>
</li>
<li><p>将事件循环的当前运行任务设置为null。</p>
</li>
<li><p>将运行完的宏任务从宏任务队列中移除。</p>
</li>
<li><p>microtasks步骤：进入microtask检查点。</p>
</li>
<li><p>更新界面渲染。</p>
</li>
<li><p>返回第一步。</p>
</li>
</ol>
<p><strong>执行进入microtask检查的的具体步骤如下:</strong></p>
<ol>
<li>设置进入microtask检查点的标志为true。</li>
<li>当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事</li>
</ol>
<p>件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务</p>
<p>为null；将运行结束 的microtask从microtask队列中移除。</p>
<ol start="3">
<li>对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些</li>
</ol>
<p>promise为 rejected。</p>
<ol start="4">
<li>清理indexedDB的事务。</li>
<li>设置进入microtask检查点的标志为false。</li>
</ol>
<p><strong>注意</strong></p>
<p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件,然后再去宏任务队列中取出一个事件。同一次事件循环中,微任务永远在宏任务之前执行</p>
<h2 id="1-10-let-a-1-挂载在哪里？"><a href="#1-10-let-a-1-挂载在哪里？" class="headerlink" title="1.10 let a &#x3D; 1 挂载在哪里？"></a>1.10 let a &#x3D; 1 挂载在哪里？</h2><p>var a 挂载在window下。而let是挂载在 全局函数下面</p>
<h2 id="1-11-浏览器垃圾回收机制"><a href="#1-11-浏览器垃圾回收机制" class="headerlink" title="1.11 浏览器垃圾回收机制"></a>1.11 浏览器垃圾回收机制</h2><p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation),执行环境会负责管理代码执行过程中使用的内存</p>
<p><strong>原理：</strong></p>
<p>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;hanzichi&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;hanzichi&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">fn2</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	首先定义了两个function，分别叫做fn1和fn2,当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象&#123;name: &#x27;hanzichi&#x27;, age: 10&#125;，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong></p>
<p>到底哪个变量是没有用的？</p>
<p><strong>解决</strong></p>
<p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常</p>
<p>情况下有两种实现方式：<strong>标记清除</strong>和<strong>引用计数</strong>。引用计数不太常用，标记清除较为常用。</p>
<p><strong>标记清除</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span> ; <span class="comment">//被标记 ，进入环境</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">20</span> ; <span class="comment">//被标记 ，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">//执行完毕 之后 a、b又被标离开环境，被回收。</span></span><br></pre></td></tr></table></figure>

<p><strong>引用计数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125; ; <span class="comment">//a的引用次数为0</span></span><br><span class="line"><span class="keyword">var</span> b = a ; <span class="comment">//a的引用次数加1，为1</span></span><br><span class="line"><span class="keyword">var</span> c =a; <span class="comment">//a的引用次数再加1，为2</span></span><br><span class="line"><span class="keyword">var</span> b =&#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); </span><br></pre></td></tr></table></figure>

<p><strong>GC****方案</strong></p>
<p>​	<strong>1.</strong> <strong>基础方案</strong></p>
<p>​	Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：</p>
<ol>
<li>遍历所有可访问的对象。</li>
<li>回收已不可访问的对象。</li>
</ol>
<p>​	<strong>2. GC的缺陷</strong></p>
<p>​	和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。</p>
<p>​	<strong>3. GC优化策略</strong></p>
<ol>
<li><strong>分代回收</strong>（Generation GC） 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810163252320.png" alt="image-20230810163252320"></p>
<p>补充：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。</p>
<ol start="2">
<li><strong>增量GC</strong> 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810163307127.png" alt="image-20230810163307127"></p>
<p>​		这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。</p>
<p>​		因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。</p>
<p>​		比如：低 (对象&#x2F;s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。</p>
<h2 id="1-12-cookie"><a href="#1-12-cookie" class="headerlink" title="1.12 cookie"></a>1.12 cookie</h2><ol>
<li><strong>cookie是什么？</strong></li>
</ol>
<ul>
<li><p>cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。</p>
</li>
<li><p>实际上 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。</p>
</li>
<li><p>不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。</p>
</li>
</ul>
<ol start="2">
<li>怎么使用 cookie？</li>
</ol>
<p>语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=value;expires=evalue; path=pvalue; domain=dvalue;secure;”</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>注意事项</strong></li>
</ol>
<ul>
<li>cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能</li>
<li>cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的</li>
<li>cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除</li>
<li>cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理</li>
<li>cookie 在保存时，只要后面保存的 name 相同，那么就会覆盖前面的 cookie，注意是完全覆盖，包括失效时间，pat</li>
</ul>
<ol start="4">
<li><strong>cookie禁用</strong></li>
</ol>
<p>sessionID通过cookie保存在客户端，如果将cookie禁用，必将对session的使用造成一定的影响</p>
<p>解决办法：url重写</p>
<h2 id="1-13-调试工具"><a href="#1-13-调试工具" class="headerlink" title="1.13 调试工具"></a>1.13 调试工具</h2><h3 id="a-谷歌浏览器"><a href="#a-谷歌浏览器" class="headerlink" title="a.谷歌浏览器"></a>a.谷歌浏览器</h3><ol>
<li><p>Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。</p>
</li>
<li><p>console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。</p>
</li>
<li><p>Sources：断点调试JS，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。</p>
</li>
<li><p>Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“小编有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。</p>
</li>
<li><p>Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。</p>
</li>
<li><p>Application：记录网站加载的各个资源信息。</p>
</li>
<li><p>Security：判断网页是否安全。</p>
</li>
<li><p>Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。</p>
</li>
</ol>
<h3 id="b-其他"><a href="#b-其他" class="headerlink" title="b.其他"></a>b.其他</h3><p><strong>postman</strong></p>
<p>Postman 是调试接口的最佳工具之一，使用 Postman，我们可以调整请求，分析响应和调试问题</p>
<p><strong>CSSLint</strong></p>
<p>CSSLint 是一个用来帮你找出 CSS 代码中问题的工具，它可做基本的语法检查以及使用一套预设的规则 来检查代码中的问题，规则是可以扩展的</p>
<p><strong>Sentry</strong></p>
<p>Sentry就是来帮我们解决这个问题的，它是是一个实时事件日志记录和聚合平台。它专门用于监视错误 和提取执行适当的事后操作所需的所有信息, 而无需使用标准用户反馈循环的任何麻烦</p>
<p><strong>BrowserStack</strong></p>
<p>BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备 很多虚拟机或者手机模拟器</p>
<h1 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h1><h2 id="1-1-跨域"><a href="#1-1-跨域" class="headerlink" title="1.1 跨域"></a>1.1 跨域</h2><p><strong>跨域是什么？</strong></p>
<p>跨域（Cross-Origin）指的是在浏览器中，当一个请求的源（Origin）与目标资源的源不一致时，即发生跨域访问。在默认情况下，浏览器的同源策略（Same-Origin Policy）会阻止这种跨域访问。同源策略是为了保护用户的信息安全，防止恶意网站对其他网站的资源进行访问和操作。</p>
<p><strong>同源策略规定几个约束</strong></p>
<ol>
<li>协议相同</li>
<li>域名相同</li>
<li>端口号相同</li>
</ol>
<p><strong>同源策略限制内容有</strong></p>
<ul>
<li>cookie、localstorage、indexedDB 等</li>
<li>dom节点</li>
<li>ajax 请求</li>
</ul>
<p><strong>不受同源策略影响</strong></p>
<p>当存在跨域请求时，浏览器的安全策略也不同</p>
<ul>
<li><p>post、get、heade等请求，浏览器会自动发送一个跨域请求的预检请求（options）到目标资源的服务器，如果服务器返回的响应满足一定条件，浏览器会继续发送正式的请求，否则会跨域</p>
</li>
<li><p>put、delete、等，浏览器会先发送一个预检请求到目标资源的服务器服务器返回的响应满足条件后，浏览器发送正式请求。与简单请求不同的是，非简单请求血药确保服务器在响应中设置了跨域请求所允许的响应首部字段</p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>jsonp</li>
</ul>
<p><strong>原理：</strong>利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定 需要对方的服务器做支持才可以</p>
<p><strong>优缺点：</strong>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题</p>
<p><strong>缺点：</strong>仅支持get方法 具有局限性, 不安全可能会遭受XSS攻击</p>
<p>实现流程</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;http://www.baidu.com?callback=fn&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">r</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>cors</li>
</ul>
<p>服务器端设置 Access-Control-Allow-Origin: 白名单&#x2F;* </p>
<p>注意：<code>*</code>不能使用cookie</p>
<ul>
<li>postMessage</li>
<li>iframe</li>
</ul>
<h2 id="1-2-有什么方法可以保持前后端通信"><a href="#1-2-有什么方法可以保持前后端通信" class="headerlink" title="1.2 有什么方法可以保持前后端通信"></a>1.2 有什么方法可以保持前后端通信</h2><p>实现保持前后端实时通信的方式有以下几种</p>
<ul>
<li><p>WebSocket： IE10以上才支持，Chrome16, FireFox11,Safari7以及Opera12以上完全支持，移动端形势大</p>
</li>
<li><p>event-source: IE完全不支持（注意是任何版本都不支持），Edge76，Chrome6,Firefox6,Safari5和Opera以上支持， 移动端形势大好</p>
</li>
<li><p>AJAX轮询： 用于兼容低版本的浏览器</p>
</li>
<li><p>永久帧（ forever iframe）可用于兼容低版本的浏览器</p>
</li>
<li><p>flash socket 可用于兼容低版本的浏览器</p>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>websocket</strong></li>
</ul>
<p><strong>优点：</strong>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，可从HTTP升级而来，浏览器和服务器只需要一次握手，就可以进行持续的，双向的数据传输，因此能显著节约资源和带宽</p>
<p><strong>缺点：</strong></p>
<ol>
<li>兼容问题、</li>
<li>不支持断线重连，需要手写心跳连接的逻辑</li>
<li>通信机制相对复杂</li>
</ol>
<ul>
<li><strong>event-source</strong></li>
</ul>
<p><strong>优点：</strong></p>
<ol>
<li>只需一次请求，便可以stream的方式多次传送数据，节约资源和带宽 </li>
<li>相对WebSocket来说简单易用</li>
<li>内置断线重连功能(retry)</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>是单向的，只支持服务端-&gt;客户端的数据传送，客户端到服务端的通信仍然依靠AJAX，没有”一家人整整齐齐“的感觉</li>
<li>兼容性令人担忧，IE浏览器完全不支持</li>
</ol>
<ul>
<li><strong>ajax轮询</strong></li>
</ul>
<p><strong>优点：</strong>兼容性良好，对标低版本IE</p>
<p><strong>缺点：</strong>请求中有大半是无用的请求，浪费资源</p>
<ul>
<li><strong>Flash Socket</strong></li>
</ul>
<p><strong>优点：</strong> 兼容低版本浏览器</p>
<p><strong>缺点：</strong></p>
<ol>
<li>浏览器开启时flash需要用户确认</li>
<li>加载时间长，用户体验较差 </li>
<li>大多数移动端浏览器不支持flash，为重灾区</li>
</ol>
<ul>
<li><strong>永久帧</strong></li>
</ul>
<p><strong>缺点：</strong> iframe会产生进度条一直存在的问题，用户体验差</p>
<p><strong>优点：</strong>兼容低版本IE浏览器</p>
<p><strong>综上：</strong></p>
<p><strong>综合兼容性和用户体验的问题，我在项目中选用了WebSocket -&gt;server-sent-event -&gt; AJAX轮询这三种方式做从上到下的兼容</strong></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-1-顺序存储结构和链式存储结构"><a href="#1-1-顺序存储结构和链式存储结构" class="headerlink" title="1.1 顺序存储结构和链式存储结构"></a>1.1 顺序存储结构和链式存储结构</h2><p><strong>优缺点</strong></p>
<ol>
<li>顺序存储时，相邻数据元素的存放地址也相邻（逻辑与物理统一）；要求内存中可用存储单元的地址必须是连续的。</li>
</ol>
<p>​		优点：存储密度大（＝1），存储空间利用率高</p>
<p>​		缺点：插入或删除元素时不方便</p>
<ol start="2">
<li>链式存储时，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针</li>
</ol>
<p>​		优点：插入或删除元素时很方便，使用灵活</p>
<p>​		缺点：存储密度小（&lt;1），存储空间利用率低</p>
<p><strong>场景</strong></p>
<ol>
<li>顺序表适宜于做查找这样的静态操作</li>
<li>链表宜于做插入、删除这样的动态操作</li>
<li>若线性表的长度变化不大，且其主要操作是查找，则采用顺序表</li>
<li>若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表</li>
</ol>
<p><strong>顺序表与链表的比较</strong></p>
<ul>
<li><p><strong>基于空间的比较</strong></p>
<ul>
<li>存储分配的方式<ul>
<li>顺序表的存储空间是静态分配的</li>
<li>链表的存储空间是动态分配的</li>
</ul>
</li>
<li>存储密度 &#x3D; 结点数据本身所占的存储量&#x2F;结点结构所占的存储总量<ul>
<li>顺序表的存储密度 &#x3D; 1</li>
<li>链表的存储密度 &lt; 1</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于时间的比较</strong></p>
<ul>
<li>存取方式<ul>
<li>顺序表可以随机存取，也可以顺序存取</li>
<li>链表是顺序存取的</li>
</ul>
</li>
<li>插入&#x2F;删除时移动元素个数<ul>
<li>顺序表平均需要移动近一半元素</li>
<li>链表不需要移动元素，只需要修改指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-1-怎样理解-Vue-的单向数据流？"><a href="#1-1-怎样理解-Vue-的单向数据流？" class="headerlink" title="1.1 怎样理解 Vue 的单向数据流？"></a>1.1 怎样理解 Vue 的单向数据流？</h2><ol>
<li>数据从父级组件传递给子组件，只能单向绑定</li>
<li>子组件内部不能直接修改从父级传递过来的数据</li>
<li>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行，这样会防止从子组件意外改变父级组件的状态， 从而导致你的应用的数据流向难以理解。&#x20;</li>
<li>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值，这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警 告&#x20;</li>
<li>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件 修改</li>
</ol>
<h2 id="1-2-谈谈你对-Vue-生命周期的理解？"><a href="#1-2-谈谈你对-Vue-生命周期的理解？" class="headerlink" title="1.2 谈谈你对 Vue 生命周期的理解？"></a>1.2 谈谈你对 Vue 生命周期的理解？</h2><p><strong>（1）生命周期是什么？</strong></p>
<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期</p>
<p><strong>（2）各个生命周期的作用</strong></p>
<table>
<thead>
<tr>
<th align="left">beforeCreate</th>
<th align="left">组件实例被创建之初，组件的属性生效之前</th>
</tr>
</thead>
<tbody><tr>
<td align="left">created</td>
<td align="left">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td align="left">update</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td align="left">activited</td>
<td align="left">keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td align="left">deadctivated</td>
<td align="left">keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td align="left">beforeDestory</td>
<td align="left">组件销毁前调用</td>
</tr>
<tr>
<td align="left">destoryed</td>
<td align="left">组件销毁后调用</td>
</tr>
</tbody></table>
<h2 id="1-3-谈谈你对-keep-alive-的了解？"><a href="#1-3-谈谈你对-keep-alive-的了解？" class="headerlink" title="1.3 谈谈你对 keep-alive 的了解？"></a>1.3 谈谈你对 keep-alive 的了解？</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated</li>
</ul>
<h2 id="1-4-组件中-data-为什么是一个函数？"><a href="#1-4-组件中-data-为什么是一个函数？" class="headerlink" title="1.4 组件中 data 为什么是一个函数？"></a>1.4 组件中 data 为什么是一个函数？</h2><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响</p>
<p>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</p>
<h2 id="1-5-你对vue项目哪些优化？"><a href="#1-5-你对vue项目哪些优化？" class="headerlink" title="1.5 你对vue项目哪些优化？"></a>1.5 你对vue项目哪些优化？</h2><p><strong>（1）代码层面的优化</strong></p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p><strong>（2）Webpack 层面的优化</strong></p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p><strong>（3）基础的 Web 技术的优化</strong></p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h2 id="1-6-vue中的key有什么作用？"><a href="#1-6-vue中的key有什么作用？" class="headerlink" title="1.6 vue中的key有什么作用？"></a>1.6 vue中的key有什么作用？</h2><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<p>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较</p>
<p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<h2 id="1-7-虚拟dom的优缺点"><a href="#1-7-虚拟dom的优缺点" class="headerlink" title="1.7 虚拟dom的优缺点"></a>1.7 虚拟dom的优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等</li>
</ul>
<p><strong>缺点：</strong></p>
<p>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化:比如动画等等</p>
<h2 id="1-8-虚拟dom实现原理？"><a href="#1-8-虚拟dom实现原理？" class="headerlink" title="1.8 虚拟dom实现原理？"></a>1.8 虚拟dom实现原理？</h2><p><strong>虚拟 DOM 的实现原理主要包括以下 3 部分：</strong></p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树</li>
</ul>
<h2 id="1-9-Vue-是如何实现数据双向绑定的？"><a href="#1-9-Vue-是如何实现数据双向绑定的？" class="headerlink" title="1.9 Vue 是如何实现数据双向绑定的？"></a>1.9 Vue 是如何实现数据双向绑定的？</h2><p>Vue 数据双向绑定主要是指：数据变化更新视图</p>
<ul>
<li>输入框内容变化时，Data 中的数据同步变化。即 View &#x3D;&gt; Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即 Data &#x3D;&gt; View 的变化</li>
</ul>
<p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<ul>
<li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li>
<li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新</li>
<li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函</li>
<li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理</li>
</ul>
<h2 id="1-20-Vue-router-有哪几种路由守卫"><a href="#1-20-Vue-router-有哪几种路由守卫" class="headerlink" title="1.20 Vue-router 有哪几种路由守卫?"></a>1.20 Vue-router 有哪几种路由守卫?</h2><ol>
<li>全局守卫：beforeEach</li>
<li>后置守卫：afterEach</li>
<li>全局解析守卫：beforeResolve</li>
<li>路由独享守卫：beforeEnter</li>
</ol>
<h2 id="1-21-Vue-router-的钩子函数都有哪些"><a href="#1-21-Vue-router-的钩子函数都有哪些" class="headerlink" title="1.21 Vue-router 的钩子函数都有哪些?"></a>1.21 Vue-router 的钩子函数都有哪些?</h2><p>关于 vue-router 中的钩子函数主要分为 3 类</p>
<ul>
<li>全局钩子函数要beforeEach 函数有三个参数,分别是&#x20;</li>
</ul>
<ol>
<li>to:router 即将进入的路由对象&#x20;</li>
<li>from:当前导航即将离开的路由</li>
<li>next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed （确认的）否则为 false,终止导航</li>
</ol>
<ul>
<li><p>单独路由独享组件<br>beforeEnter</p>
</li>
<li><p>组件内钩子&#x20;</p>
<ol>
<li>beforeRouterEnter&#x20;</li>
<li>beforeRouterUpdate&#x20;</li>
<li>beforeRouterLeave</li>
</ol>
</li>
</ul>
<h2 id="1-22-vue-router-路由模式有几种？"><a href="#1-22-vue-router-路由模式有几种？" class="headerlink" title="1.22 vue-router 路由模式有几种？"></a>1.22 vue-router 路由模式有几种？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract</p>
<ul>
<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h2 id="1-23-说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#1-23-说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="1.23 说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>1.23 说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><p><strong>（1）hash 模式的实现原理</strong></p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</li>
</ul>
<p><strong>（2）history 模式的实现原理</strong></p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）</li>
</ul>
<h2 id="1-24-vuex-包括几个模块"><a href="#1-24-vuex-包括几个模块" class="headerlink" title="1.24 vuex 包括几个模块"></a>1.24 vuex 包括几个模块</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li>
</ul>
<h2 id="1-25-Object-defineProperty-和-Proxy-的区别"><a href="#1-25-Object-defineProperty-和-Proxy-的区别" class="headerlink" title="1.25 Object.defineProperty 和 Proxy 的区别"></a>1.25 Object.defineProperty 和 Proxy 的区别</h2><p>Object.defineProperty 和 Proxy 的区别如下:</p>
<ol>
<li>Proxy 可以直接监听对象而非属性；&#x20;</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等 是 Object.defineProperty 不具备的&#x20;</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准 的性能红利&#x20;</li>
<li>Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题, 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重 写</li>
</ol>
<h2 id="1-26-MVVM-和-MVC-区别是什么？哪些场景适合？"><a href="#1-26-MVVM-和-MVC-区别是什么？哪些场景适合？" class="headerlink" title="1.26 MVVM 和 MVC 区别是什么？哪些场景适合？"></a>1.26 MVVM 和 MVC 区别是什么？哪些场景适合？</h2><p><strong>1、基本定义</strong>&#x20;</p>
<p>MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型，模型（Model） 指的是后端传递的数据，视图(View)指的是所看到的页面，视图模型(ViewModel)是 mvvm 模式 的核心，它是连接 view 和 model 的桥梁。它有两个方向：&#x20;</p>
<ol>
<li>一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到 的页面，实现的方式是：数据绑定</li>
<li>二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。 实现的方式是：DOM 事件监听，这两个方向都实现的，我们称之为数据的双向绑定</li>
<li>MVC 基本定义 MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑，使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启 下&#x20;</li>
</ol>
<p><strong>2、使用场景</strong></p>
<p>&#x20;主要就是 MVC 中 Controller 演变成 MVVM 中的 viewModel，MVVM 主要解决了 MVC中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验，vue 数据驱动，通 过数据来显示视图层而不是节点操作， 场景：数据操作比较多的场景，需要大量操作 DOM 元 素时，采用 MVVM 的开发方式，会更加便捷，让开发者更多的精力放在数据的变化上，解放繁 琐的操作 DOM 元素</p>
<p><strong>3、两者之间的区别</strong></p>
<p>&#x20;MVC 和 MVVM 其实区别并不大，都是一种设计思想， MVC 和 MVVM 的区别并不是VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念， ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图 操作业务等还是应该放在 Controller 中实现，也就是说 MVVM 实现的是业务逻辑组件的重用， 使开发更高效，结构更清晰，增加代码的复用性</p>
<h2 id="1-27-vue-中如何重置-data"><a href="#1-27-vue-中如何重置-data" class="headerlink" title="1.27 vue 中如何重置 data?"></a>1.27 vue 中如何重置 data?</h2><p>要初始化 data 中的数据，可以使用 Object.assign()方法，实现重置 data 中的数据，以下就是对该方法的详细介绍，以及如何使用该方法，重置 data 中的数据</p>
<ol>
<li>Object.assign()方法基本定义&#x20;</li>
<li>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目 标对象。它将返回目标对象。</li>
<li>用法： Object.assign(target, …sources)，第一个参数是目标对象，第二个参数 是源对象，就是将源对象属性复制到目标对象，返回目标对象</li>
</ol>
<h2 id="1-28-vue3-新特性有哪些？"><a href="#1-28-vue3-新特性有哪些？" class="headerlink" title="1.28 vue3 新特性有哪些？"></a>1.28 vue3 新特性有哪些？</h2><p>1、性能提升</p>
<ul>
<li>响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快，消除警告。</li>
<li>重写了 Vdom ，突破了 Vdom 的性能瓶颈。</li>
<li>进行模板编译优化。</li>
<li>更加高效的组件初始化</li>
</ul>
<p>2、更好的支持 typeScript</p>
<ul>
<li>有更好的类型推断，使得 Vue3 把 typeScript 支持得非常好</li>
</ul>
<p>3、新增Composition API</p>
<ul>
<li>Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强</li>
</ul>
<p>4、新增组件</p>
<ul>
<li>Fragment 不再限制 template 只有一个根几点。</li>
<li>Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。</li>
<li>Supense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。</li>
</ul>
<p>5、Tree-shaking：支持摇树优化</p>
<ul>
<li>摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快</li>
</ul>
<p>6、Custom Renderer API： 自定义渲染器</p>
<ul>
<li>实现 DOM 的方式进行 WebGL 编程</li>
</ul>
<h2 id="1-29-vue3-组合式API生命周期钩子函数有变化吗"><a href="#1-29-vue3-组合式API生命周期钩子函数有变化吗" class="headerlink" title="1.29 vue3 组合式API生命周期钩子函数有变化吗?"></a>1.29 vue3 组合式API生命周期钩子函数有变化吗?</h2><p>setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显示的定义它们。其他的钩子都可以编写到 setup 内</p>
<h2 id="1-30-watch-和-watchEffect-的区别？"><a href="#1-30-watch-和-watchEffect-的区别？" class="headerlink" title="1.30 watch 和 watchEffect 的区别？"></a>1.30 watch 和 watchEffect 的区别？</h2><p>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。它们之间的区别有：</p>
<ol>
<li>watch 需要传入监听的数据源，而 watchEffect 可以自动手机数据源作为依赖。</li>
<li>watch 可以访问倒改变之前和之后的值，watchEffect 只能获取改变后的值。</li>
<li>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。</li>
</ol>
<h2 id="1-31-vue中v-if和v-for优先级在vue2和vue3中的区别"><a href="#1-31-vue中v-if和v-for优先级在vue2和vue3中的区别" class="headerlink" title="1.31 vue中v-if和v-for优先级在vue2和vue3中的区别"></a>1.31 vue中v-if和v-for优先级在vue2和vue3中的区别</h2><p>实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。</p>
<ul>
<li>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。</li>
<li>在 vue 3.x 中， v-if 总是优先于 v-for 生效。</li>
<li>vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。</li>
<li>vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常</li>
</ul>
<h2 id="1-32-script-setup-是干啥的？"><a href="#1-32-script-setup-是干啥的？" class="headerlink" title="1.32 script setup 是干啥的？"></a>1.32 script setup 是干啥的？</h2><p>scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：</p>
<ul>
<li>属性和方法无需返回，可以直接使用。</li>
<li>引入组件的时候，会自动注册，无需通过 components 手动注册。</li>
<li>使用 defineProps 接收父组件传递的值。</li>
<li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。</li>
<li>默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。</li>
</ul>
<h2 id="1-33-vue常用的修饰符"><a href="#1-33-vue常用的修饰符" class="headerlink" title="1.33 vue常用的修饰符"></a>1.33 vue常用的修饰符</h2><ul>
<li>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</li>
<li>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；作用是阻止默认事件（例如a标签的跳转</li>
<li>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</li>
<li>.self ：只会触发自己范围内的事件，不包含子元素；</li>
<li>.once ：只会触发一次。</li>
<li>.trim修饰符的作用是把v-model绑定的值的首尾空格给去掉。在实际开发中我们一般用于搜索框的内容修饰，过滤掉用户多输入前后空格导致内容查不出来的情况。</li>
<li>.left，.right，.middle这三个修饰符是鼠标的左中右按键触发的事件.</li>
</ul>
<h2 id="1-34-vue2-0-和-vue3-0-有什么区别？-双向绑定更新"><a href="#1-34-vue2-0-和-vue3-0-有什么区别？-双向绑定更新" class="headerlink" title="1.34 vue2.0 和 vue3.0 有什么区别？ 双向绑定更新"></a>1.34 vue2.0 和 vue3.0 有什么区别？ 双向绑定更新</h2><p>vue2 的双向数据绑定是利⽤ES5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持 结合 发布订阅模式的⽅式来实现的。</p>
<p>vue3 中使⽤了 ES6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。</p>
<p>这⾥是相⽐于vue2版本，使⽤proxy的优势如下</p>
<ol>
<li><p>defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</p>
</li>
<li><p>监听数组，不⽤再去单独的对数组做特异性操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美⽀持对数组的监听。</p>
</li>
</ol>
<p><strong>获取props</strong></p>
<p>vue2在script代码块可以直接获取props，vue3通过setup指令传递</p>
<p><strong>API不同</strong></p>
<p>Vue2使⽤的是选项类型API（Options API），Vue3使⽤的是合成型API（Composition API）</p>
<p><strong>建立数据data</strong></p>
<p>vue2是把数据放入data中，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造得时候触发。</p>
<p><strong>生命周期不同</strong></p>
<table>
<thead>
<tr>
<th>vue2</th>
<th>vue3</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>setup() 开始创建组件之前，创建的是data和method</td>
</tr>
<tr>
<td>created</td>
<td>setup()</td>
</tr>
<tr>
<td>beforeMount</td>
<td>onBeforeMount 组件挂载到节点上之前执行的函数</td>
</tr>
<tr>
<td>mounted</td>
<td>onMounted 组件挂载完成后执行的函数</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeUpdate 组件更新之前执行的函数</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated 组件更新完成之后执行的函数</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>onBeforeUnmount 组件挂载到节点上之前执行的函数</td>
</tr>
<tr>
<td>destroyed</td>
<td>onUnmounted 组件卸载之前执行的函数</td>
</tr>
<tr>
<td>activated</td>
<td>onActivated 组件卸载完成后执行的函数</td>
</tr>
<tr>
<td>deactivated</td>
<td>onDeactivated</td>
</tr>
</tbody></table>
<p><strong>关于v-if和v-for的优先级:</strong></p>
<p>vue2 在一个元素上同时使用 v-if 和 v-for  v-for会优先执行</p>
<p>vue3 v-if 总会优先于  v-for生效</p>
<p><strong>vue2和vue3的diff算法</strong></p>
<p><strong>vue2</strong></p>
<p>vue2 diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点 不同的地方，最后用patch记录的消息去局部更新Dom。</p>
<p>vue2 diff算法会比较每一个vnode,而对于一些不参与更新的元素，进行比较是有 点消耗性能的。</p>
<p><strong>vue3</strong></p>
<p>vue3 diff算法在初始化的时候会给每个虚拟节点添加一个patchFlags，patchFlags 就是优化的标识。</p>
<p>只会比较patchFlags发生变化的vnode,进行更新视图，对于没有变化的元素做静 态标记，在渲染的时候直接复用。</p>
<h2 id="1-35-reactive与ref的区别？"><a href="#1-35-reactive与ref的区别？" class="headerlink" title="1.35 reactive与ref的区别？"></a>1.35 reactive与ref的区别？</h2><p>Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。</p>
<p>ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。</p>
<p>reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。</p>
<h2 id="1-36-route-和-router-的区别？"><a href="#1-36-route-和-router-的区别？" class="headerlink" title="1.36 $route 和 $router 的区别？"></a>1.36 $route 和 $router 的区别？</h2><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p>
<p>$router 是“路由实例”想要导航到不同URL 对象包括了路由的跳转方法，钩子函数等。</p>
<h2 id="1-37-v-on可以监听多个方法吗？"><a href="#1-37-v-on可以监听多个方法吗？" class="headerlink" title="1.37 v-on可以监听多个方法吗？"></a>1.37 v-on可以监听多个方法吗？</h2><p>可以一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p>
<p><code>&lt;a&gt;</code>doSomething <code>&lt;/a&gt;</code></p>
<p>在method方法里面分别写两个事件；</p>
<p>&lt;button @click&#x3D;”a(),b()”&gt;点我ab&lt;&#x2F;button&gt;</p>
<h2 id="1-38-v-model的使用？"><a href="#1-38-v-model的使用？" class="headerlink" title="1.38 v-model的使用？"></a>1.38 v-model的使用？</h2><p>v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.</p>
<p>V-model的原理：</p>
<ul>
<li><p>v-bind绑定一个value属性</p>
</li>
<li><p>v-on指令给当前元素绑定input事件</p>
</li>
</ul>
<p>可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体</p>
<p>组件上的双向绑定（原理）</p>
<p>v-model绑定在组件上的时候做了以下步骤</p>
<ul>
<li>在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性</li>
<li>子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。</li>
<li>子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值</li>
<li>v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上</li>
</ul>
<h2 id="1-39-vue遇到的坑，如何解决的？"><a href="#1-39-vue遇到的坑，如何解决的？" class="headerlink" title="1.39 vue遇到的坑，如何解决的？"></a>1.39 vue遇到的坑，如何解决的？</h2><ul>
<li>用webpack打包后访问index.html出现资源加载404问题，解决：开发环境的static文件夹是基于根目录的，所以直接用‘&#x2F;’ 。</li>
<li>vue中，假如，你引入某个样式，然后这个样式里面有引用到图片，如果你的文件中没有这个图片，这时候，即使你没有引用这个图片对应的类名，但是只要你有引入这个css文件，他找不到相应路径图片也会报错！！！</li>
<li>用for循环出来的列表，在设置列表中的元素的动态属性时，需要加bind属性“：”，不然动态属性设置不出来</li>
<li>在vue中的html中的img中的src不可以直接设置为变量，在data里面直接引路径，只能通过import的形式引入,值得注意的是，引用这个方式的时候src是变量需要加“：”，不然会报错！！！！！</li>
<li>在中使用v-for&#x3D;”(item ,index) in list”进行循环时，需要注意加：:key&#x3D;“index”,不然会出现警告！</li>
<li>父组件ajax异步更新数据，子组件props获取不到</li>
</ul>
<p>应用场景</p>
<p>当父组件  axjos  获取数据，子组件使用  props  接收数据时，执行  mounted  的时候  axjos  还没有返回数据，而且  mounted 只执行一次，这时   props  中接收的数据为空</p>
<p>解决方案：在对应组件中判断数据的长度</p>
<h2 id="1-40-说说vue中的diff算法？"><a href="#1-40-说说vue中的diff算法？" class="headerlink" title="1.40 说说vue中的diff算法？"></a>1.40 说说vue中的diff算法？</h2><p>diff算法 当data发生改变 会根据新的数据生成一个新的虚拟dom ，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法。</p>
<p>Vue2 是全量 Diff（当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。）；Vue3 是静态标记 + 非全量 Diff（Vue 3在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。）</p>
<p>使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作</p>
<h2 id="1-41-vue中怎么设置全局变量和全局组件？"><a href="#1-41-vue中怎么设置全局变量和全局组件？" class="headerlink" title="1.41 vue中怎么设置全局变量和全局组件？"></a>1.41 vue中怎么设置全局变量和全局组件？</h2><p>在main.js中</p>
<p>app.config.globalProperties.$key &#x3D; ‘’ &#x2F;&#x2F;定义全局变量</p>
<p>import {getCurrentInstance} from ‘vue’;</p>
<p>  setup(){</p>
<p>    const { proxy } &#x3D; getCurrentInstance();</p>
<p>    console.log(proxy.$key);</p>
<p>  }</p>
<h2 id="1-45-vue中给对象添加新属性时，界面不刷新怎么办"><a href="#1-45-vue中给对象添加新属性时，界面不刷新怎么办" class="headerlink" title="1.45 vue中给对象添加新属性时，界面不刷新怎么办?"></a>1.45 vue中给对象添加新属性时，界面不刷新怎么办?</h2><p>vue2的响应式原理使用的是对象代理去实现的,对象代理中有一个get和set方法,当我们访问对象的时候就会触发get方法,当我们对对象中的值进行修改时会触发set方法。但是当我们给对象添加一个新的属性时对象代理是检测不到的,所以就会出现直接给对象添加属性响应式不生效的问题。</p>
<p>所以在vue中可以使用this.$set(对象名,‘属性名’,属性值)的方法去给对象添加属性,或者使用Vue.set(对象名,‘属性名’,属性值)的方法进行添加,添加之后的属性就带有响应式了</p>
<h2 id="1-46-vuex中的辅助函数怎么使用？"><a href="#1-46-vuex中的辅助函数怎么使用？" class="headerlink" title="1.46 vuex中的辅助函数怎么使用？"></a>1.46 vuex中的辅助函数怎么使用？</h2><p>vuex的辅助函数有4个</p>
<ul>
<li>mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。</li>
<li>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他</li>
<li>mapMutations 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.$store.commit(‘montify’)</li>
<li>mapActions在组件中使用 this.$store.dispatch(‘prodect’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用</li>
</ul>
<h2 id="1-47-刷新浏览器后，Vuex的数据是否存在？如何解决？"><a href="#1-47-刷新浏览器后，Vuex的数据是否存在？如何解决？" class="headerlink" title="1.47 刷新浏览器后，Vuex的数据是否存在？如何解决？"></a>1.47 刷新浏览器后，Vuex的数据是否存在？如何解决？</h2><p>原因：因为 store 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。</p>
<p>localStorage 或者就是sessionStorage</p>
<p>下载持久化存储插件。比如使用：vuex-along 的实质也是将 vuex 中的数据存放到 localStorage 或者 sessionStroage 中，只不过这个存取过程组件会帮我们完成，我们只需要用vuex的读取数据方式操作就可以了</p>
<h2 id="x20-1-48-vue路由跳转传参的方式有哪些？"><a href="#x20-1-48-vue路由跳转传参的方式有哪些？" class="headerlink" title="&#x20;1.48 vue路由跳转传参的方式有哪些？"></a>&#x20;1.48 vue路由跳转传参的方式有哪些？</h2><p><strong>params传参(显示参数)</strong></p>
<ul>
<li>在url中会显示出传参的值，刷新页面不会失去拿到的参数，使用该方式传值的时候，需要子路由提前配置好参数</li>
</ul>
<p><strong>params传参(不显示参数)</strong></p>
<ul>
<li>在url中不会显示出传参的值，但刷新页面会失去拿到的参数，使用该方式 传值 的时候，需要子路由提前配置好name参数</li>
</ul>
<p><strong>query 传参</strong></p>
<ul>
<li>query 传过去的参数会拼接在地址栏中（?name&#x3D;xx），刷新页面数据不会丢失，使用path和name都可以</li>
</ul>
<p><strong>VUE几种路由跳转几种方式的区别</strong></p>
<ul>
<li>this.$router.push：跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面</li>
<li>this.$router.replace：跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)</li>
<li>this.$router.go(n)：向前或者向后跳转n个页面，n可为正整数或负整数</li>
</ul>
<h2 id="1-50-单页面应用和多页面应用区别及优缺点？"><a href="#1-50-单页面应用和多页面应用区别及优缺点？" class="headerlink" title="1.50 单页面应用和多页面应用区别及优缺点？"></a>1.50 单页面应用和多页面应用区别及优缺点？</h2><p><strong>单页面</strong>：顾名思义，只有一个页面。一般是一个主页和多个路由页面组成。</p>
<p>优点：</p>
<ul>
<li>公共资源不重新加载，局部加载，服务器压力小</li>
<li>切换速度快，用户体验好</li>
<li>前后端分离</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于SEO（可以优化：比如路由懒加载等）</li>
<li>初次加载时耗时多</li>
<li>开发难度较大（相对多页面）</li>
</ul>
<p><strong>多页面</strong>（Multi Page Application——MPA）：有多个HTML页面，跳转的时候是从一个html页面跳到另一个页面。</p>
<p>优点：</p>
<ul>
<li>利于SEO。</li>
<li>更容易扩展。</li>
<li>更易数据分析。</li>
</ul>
<p>缺点：</p>
<ul>
<li>开发成本高。</li>
<li>服务器压力大。</li>
<li>用户体验相对较差。</li>
</ul>
<h2 id="1-51-EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"><a href="#1-51-EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？" class="headerlink" title="1.51 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"></a>1.51 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？</h2><ul>
<li><p>添加Bus.$off来关闭</p>
<p>beforeDestroy () {</p>
<p>bus.$off(‘get’, this.myhandle)</p>
<p>}</p>
</li>
<li><p>如果想要用bus 来进行页面组件之间的数据传递，需要注意亮点，组件emit事件应在beforeDestory声明周期内。其次，组件B内的$on记得要销毁。&#x20;</p>
</li>
</ul>
<h2 id="1-52-自定义指令详解"><a href="#1-52-自定义指令详解" class="headerlink" title="1.52 自定义指令详解"></a>1.52 自定义指令详解</h2><p>为什么需要自定义指令：因为vue是MVVM模式，只需要关注于数据和业务逻辑，不需要关注DOM的操作，但是有时候面对一些特殊的业务需求时，需要进行DOM的操作，这个时候就需要进行自定义指令。</p>
<p>自定义局部指令:在options api选项中的directives中设置。局部自定义指令是一个对象，对象的属性是自定义指令的名称，对象中属性的值是自定义指令的钩子函数对象</p>
<p>自定义全局指令:在app的directive方法。参数一（name）：自定义指令的名称。参数二（hooks）：自定义指令的钩子函数对象</p>
<h2 id="1-53-slot是什么？有什么作用？原理是什么？"><a href="#1-53-slot是什么？有什么作用？原理是什么？" class="headerlink" title="1.53 slot是什么？有什么作用？原理是什么？"></a>1.53 slot是什么？有什么作用？原理是什么？</h2><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p>
<p><strong>slot又分三类，默认插槽，具名插槽和作用域插槽。</strong></p>
<ul>
<li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>
<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p><strong>实现原理：</strong></p>
<p>当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default具名插槽为vm.$slot.xxx，xxx 为插槽名</p>
<p>当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽</p>
<h2 id="1-54-nextTick的使用"><a href="#1-54-nextTick的使用" class="headerlink" title="1.54 $nextTick的使用"></a>1.54 $nextTick的使用</h2><p>用法：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p>
<p><strong>$nextTick() 的应用场景</strong></p>
<p>在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 $nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p>
<p>mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题</p>
<p>在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 $nextTick() 的回调函数中。</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="1-1-虚拟dom和真实dom"><a href="#1-1-虚拟dom和真实dom" class="headerlink" title="1.1 虚拟dom和真实dom"></a>1.1 虚拟dom和真实dom</h2><p><strong>什么是虚拟dom？</strong></p>
<p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom操作，从而 提高性能。</p>
<ol>
<li>用 JavaScript 对象结构表示 DOM 树的结构</li>
<li>用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。</li>
<li>用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的DOM 树上，视图就更新了。</li>
</ol>
<p><strong>虚拟dom和real dom区别 性能差异</strong></p>
<p>减少DOM的操作：虚拟dom可以将多次操作合并为一次操作，减少DOM操作的次数</p>
<table>
<thead>
<tr>
<th><strong>Real DOM</strong></th>
<th><strong>Virtual DOM</strong></th>
</tr>
</thead>
<tbody><tr>
<td>更新缓慢</td>
<td>更新更快</td>
</tr>
<tr>
<td>可以直接更新 HTML</td>
<td>无法直接更新 HTML</td>
</tr>
<tr>
<td>如果元素更新，则创建新DOM</td>
<td>如果元素更新，则更新 JSX</td>
</tr>
<tr>
<td>DOM操作代价很高</td>
<td>DOM 操作非常简单</td>
</tr>
<tr>
<td>消耗的内存较多</td>
<td>很少的内存消耗</td>
</tr>
</tbody></table>
<h2 id="1-2-react组件间通信"><a href="#1-2-react组件间通信" class="headerlink" title="1.2 react组件间通信"></a>1.2 <strong>react组件间通信</strong></h2><ul>
<li><p>父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯</p>
</li>
<li><p>子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</p>
</li>
<li><p>兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</p>
</li>
<li><p>跨层级通信: Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言</p>
</li>
<li><p>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信</p>
</li>
<li><p>全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态</p>
</li>
</ul>
<h2 id="1-3-redux的原理"><a href="#1-3-redux的原理" class="headerlink" title="1.3 redux的原理"></a>1.3 <strong>redux的原理</strong></h2><p><strong>Redux</strong>：Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为</p>
<p><strong>数据流</strong></p>
<ol>
<li><p>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</p>
</li>
<li><p>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</p>
</li>
<li><p>State一旦有变化，Store就会调用监听函数，来更新View</p>
</li>
</ol>
<p><strong>Redux遵循的三个原则是什么</strong></p>
<ol>
<li><p>单一事实来源：整个应用的状态存储在单个 store 中的对象&#x2F;状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。</p>
</li>
<li><p>状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像state 是数据的最小表示一样，该操作是对数据更改的最小表示。</p>
</li>
<li><p>使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</p>
</li>
</ol>
<p><strong>单一事实来源怎么理解？</strong></p>
<p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p>
<p><strong>组件组成</strong></p>
<ol>
<li><strong>Action</strong> – 这是一个用来描述发生了什么事情的对象</li>
<li><strong>Reducer</strong> – 这是一个确定状态将如何变化的地方</li>
<li><strong>Store</strong> – 整个程序的状态&#x2F;对象树保存在Store中</li>
<li><strong>View</strong> – 只显示 Store 提供的数据</li>
</ol>
<p><strong>如何在</strong> <strong>Redux</strong> <strong>中定义</strong> <strong>Action？</strong></p>
<p>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建</p>
<p><strong>解释</strong> <strong>Reducer</strong> <strong>的作用</strong></p>
<p>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。</p>
<p><strong>Store</strong> <strong>在</strong> <strong>Redux</strong> <strong>中的意义是什么？</strong></p>
<p>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态&#x2F;对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</p>
<p><strong>Redux</strong> <strong>有哪些优点？</strong></p>
<ul>
<li>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题</li>
<li>可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构</li>
<li>服务器端渲染 - 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验</li>
<li>开发人员工具 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情</li>
<li>社区和生态系统 - Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用</li>
<li>易于测试 - Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立</li>
<li>组织 - Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单</li>
</ul>
<h2 id="1-4-React组件生命周期的阶段是什么？"><a href="#1-4-React组件生命周期的阶段是什么？" class="headerlink" title="1.4 React组件生命周期的阶段是什么？"></a>1.4 <strong>React组件生命周期的阶段是什么？</strong></h2><ol>
<li><p>初始渲染阶段：这是组件即将开始其生命之旅并进入 DOM 的阶段。</p>
</li>
<li><p>更新阶段：一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。</p>
</li>
<li><p>卸载阶段：这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。</p>
</li>
</ol>
<h2 id="1-5-详细解释React-组件的生命周期方法"><a href="#1-5-详细解释React-组件的生命周期方法" class="headerlink" title="1.5 详细解释React 组件的生命周期方法"></a>1.5 <strong>详细解释React 组件的生命周期方法</strong></h2><p><strong>挂载阶段:</strong></p>
<ul>
<li><p>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</p>
</li>
<li><p>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState) ,这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps</p>
</li>
<li><p>render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</p>
</li>
<li><p>componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅</p>
</li>
</ul>
<p><strong>更新阶段:</strong></p>
<ul>
<li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li>
<li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState) ,有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能</li>
<li>render: 更新阶段也会触发此生命周期</li>
<li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState) ,这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</li>
<li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot) ,该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态</li>
</ul>
<p><strong>卸载阶段:</strong></p>
<ul>
<li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</li>
</ul>
<p><strong>扩展：</strong></p>
<p>React 16之后有三个生命周期被废弃(但并未删除)</p>
<ul>
<li><p>componentWillMount</p>
</li>
<li><p>componentWillReceiveProps</p>
</li>
<li><p>componentWillUpdate</p>
</li>
</ul>
<p>官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们</p>
<h2 id="1-6-router"><a href="#1-6-router" class="headerlink" title="1.6 router"></a>1.6 router</h2><ol>
<li>什么是React 路由？</li>
</ol>
<p>React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。</p>
<ol start="2">
<li>为什么需要 React 中的路由？</li>
</ol>
<p>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路</p>
<p>由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个</p>
<p>Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</p>
<ol start="3">
<li>为什么React Router v4中使用 switch 关键字 ？</li>
</ol>
<p>虽然 <div> 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路</p>
<p>线时，可以使用 “switch” 关键字。使用时， <switch> 标记会按顺序将已定义的 URL 与已定义的</p>
<p>路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。</p>
<ol start="4">
<li>列出 React Router 的优点</li>
</ol>
<p>​	4.1 就像 React 基于组件一样，在 React Router v4 中，API 是 ‘All About Components’。可以将Router 可视化为单个根组件（），其中我们将特定的子路由（）包起来。</p>
<p>​	4.2 无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 组件中。</p>
<p>​	4.3 包是分开的：共有三个包，分别用于 Web、Native 和 Core。这使我们应用更加紧凑。基于类似的编码风格很容易进行切换。</p>
<h2 id="1-7-React-的-refs-有什么了解？"><a href="#1-7-React-的-refs-有什么了解？" class="headerlink" title="1.7 React 的 refs 有什么了解？"></a>1.7 React <strong>的</strong> <strong>refs</strong> 有什么了解？</h2><p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ReferenceDemo extends React.Component&#123;</span><br><span class="line">    display() &#123;</span><br><span class="line">        const name = this.inputDemo.value;</span><br><span class="line">        document.getElementById(&#x27;disp&#x27;).innerHTML = name;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            Name: &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.inputDemo = input&#125; /&gt;</span><br><span class="line">            &lt;button name=&quot;Click&quot; onClick=&#123;this.display&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">            &lt;h2&gt;Hello &lt;span id=&quot;disp&quot;&gt;&lt;/span&gt; !!!&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-列出一些应该使用-Refs-的情况"><a href="#1-8-列出一些应该使用-Refs-的情况" class="headerlink" title="1.8 列出一些应该使用 Refs 的情况"></a>1.8 列出一些应该使用 Refs 的情况</h2><p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p>
<p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用event.preventDefault</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810214434062.png" alt="image-20230810214434062"></p>
<h2 id="1-9-redux-saga和mobx的比较"><a href="#1-9-redux-saga和mobx的比较" class="headerlink" title="1.9 redux-saga和mobx的比较"></a>1.9 redux-saga和mobx的比较</h2><ol>
<li><strong>状态管理</strong></li>
</ol>
<ul>
<li><p>redux-sage 是 redux 的一个异步处理的中间件。</p>
</li>
<li><p>mobx 是数据管理库，和 redux 一样。</p>
</li>
</ul>
<ol start="2">
<li><strong>设计思想</strong></li>
</ol>
<ul>
<li><p>redux-sage 属于 flux 体系， 函数式编程思想。</p>
</li>
<li><p>mobx 不属于 flux 体系，面向对象编程和响应式编程。</p>
</li>
</ul>
<ol start="3">
<li><strong>主要特点</strong></li>
</ol>
<ul>
<li><p>redux-sage 因为是中间件，更关注异步处理的，通过 Generator 函数来将异步变为同步，使代码可读性高，结构清晰。action 也不是 action creator 而是 pure action，在 Generator 函数中通过 call 或者 put 方法直接声明式调用，并自带一些方法，如 takeEvery，takeLast，race等，控制多个异步操作，让多个异步更简单。</p>
</li>
<li><p>mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。</p>
</li>
</ul>
<ol start="4">
<li><strong>数据可变性</strong></li>
</ol>
<ul>
<li><p>redux-sage 强调 state 不可变，不能直接操作 state，通过 action 和 reducer 在原来的 state 的基础上返回一个新的 state 达到改变 state 的目的。</p>
</li>
<li><p>mobx 直接在方法中更改 state，同时所有使用的 state 都发生变化，不生成新的 state。</p>
</li>
</ul>
<ol start="5">
<li><strong>写法难易度</strong></li>
</ol>
<ul>
<li><p>redux-sage 比 redux 在 action 和 reducer 上要简单一些。需要用 dispatch 触发 state 的改变，需要 mapStateToProps 订阅 state。</p>
</li>
<li><p>mobx 在非严格模式下不用 action 和 reducer，在严格模式下需要在 action 中修改 state，并且自动触发相关依赖的更新。</p>
</li>
</ul>
<ol start="6">
<li><strong>使用场景</strong></li>
</ol>
<ul>
<li><p>redux-sage 很好的解决了 redux 关于异步处理时的复杂度和代码冗余的问题，数据流向比较好追踪。但是 redux 的学习成本比 较高，代码比较冗余，不是特别需要状态管理，最好用别的方式代替。</p>
</li>
<li><p>mobx 学习成本低，能快速上手，代码比较简洁。但是可能因为代码编写的原因和数据更新时相对黑盒，导致数据流向不利于追踪。</p>
</li>
</ul>
<h2 id="1-10-简述一下-React-的源码实现"><a href="#1-10-简述一下-React-的源码实现" class="headerlink" title="1.10 简述一下 React 的源码实现"></a>1.10 简述一下 <strong>React</strong> 的源码实现</h2><ol>
<li><p>React 的实现主要分为 Component 和 Element ；</p>
</li>
<li><p>Component 属于 React 实例，在创建实例的过程中会在实例中注册 state 和 props 属性，还会依次调用内置的生命周期函数；</p>
</li>
<li><p>Component 中有一个 render 函数， render 函数要求返回一个 Element 对象（或 null ）；</p>
</li>
<li><p>Element 对象分为原生 Element 对象和组件式对象，原生 Element + 组件式对象会被一起解析成虚拟 DOM 树，并且内部使用的 state 和 props 也以 AST 的形式注入到这棵虚拟 DOM 树之中；</p>
</li>
<li><p>在渲染虚拟 DOM 树的前后，会触发 React Component 的一些生命周期钩子函数，比如componentWillMount 和 componentDidMount ，在虚拟 DOM 树解析完成后将被渲染成真实DOM 树；</p>
</li>
<li><p>调用 setState 时，会调用更新函数更新 Component 的 state ，并且触发内部的一个updater ，调用 render 生成新的虚拟 DOM 树，利用 diff 算法与旧的虚拟 DOM 树进行比对，比对以后利用最优的方案进行 DOM 节点的更新，这也是 React 单向数据流的原理（与 Vue 的MVVM 不同之处）。</p>
</li>
</ol>
<h2 id="1-11-setState到底是异步还是同步"><a href="#1-11-setState到底是异步还是同步" class="headerlink" title="1.11 setState到底是异步还是同步"></a>1.11 setState到底是异步还是同步</h2><p>有时表现出异步,有时表现出同步</p>
<ol>
<li><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</p>
</li>
<li><p>setState 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback)中的 callback 拿到更新后的结果。</p>
</li>
<li><p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p>
</li>
</ol>
<h2 id="1-12-redux异步中间件之间的优劣"><a href="#1-12-redux异步中间件之间的优劣" class="headerlink" title="1.12  redux异步中间件之间的优劣?"></a>1.12  redux异步中间件之间的优劣?</h2><p><strong>redux-thunk优点:</strong></p>
<ul>
<li><p>体积小: redux-thunk的实现方式很简单,只有不到20行代码</p>
</li>
<li><p>使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单</p>
</li>
</ul>
<p><strong>redux-thunk缺陷:</strong></p>
<ul>
<li><p>样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的</p>
</li>
<li><p>耦合严重: 异步操作与redux的action偶合在一起,不方便管理</p>
</li>
<li><p>功能孱弱: 有一些实际开发中常用的功能需要自己进行封装</p>
</li>
</ul>
<p><strong>redux-saga优点:</strong></p>
<ul>
<li><p>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中</p>
</li>
<li><p>action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function</p>
</li>
<li><p>异常处理: 受益于 generator function 的 saga 实现，代码异常&#x2F;请求失败 都可以直接通过try&#x2F;catch 语法直接捕获处理</p>
</li>
<li><p>功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用</p>
</li>
<li><p>灵活: redux-saga可以将多个Saga可以串行&#x2F;并行组合起来,形成一个非常实用的异步flow</p>
</li>
<li><p>易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等</p>
</li>
</ul>
<p><strong>redux-saga缺陷:</strong></p>
<ul>
<li><p>额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想</p>
</li>
<li><p>体积庞大: 体积略大,代码近2000行，min版25KB左右</p>
</li>
<li><p>功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码</p>
</li>
<li><p>ts支持不友好: yield无法返回TS类型</p>
</li>
</ul>
<p><strong>redux-observable优点:</strong></p>
<ul>
<li><p>功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理</p>
</li>
<li><p>背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着</p>
</li>
<li><p>rxjs的升级redux-observable也会变得更强大</p>
</li>
</ul>
<p><strong>redux-observable缺陷:</strong></p>
<ul>
<li><p>学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库</p>
</li>
<li><p>社区一般: redux-observable的下载量只有redux-saga的1&#x2F;5,社区也不够活跃,在复杂异步流中间件</p>
</li>
<li><p>这个层面redux-saga仍处于领导地位</p>
</li>
</ul>
<h2 id="1-13-state-和-props-区别是啥？"><a href="#1-13-state-和-props-区别是啥？" class="headerlink" title="1.13 state 和 props 区别是啥？"></a>1.13 state <strong>和</strong> props 区别是啥？</h2><p>props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</p>
<ul>
<li>state 是组件自己管理数据，控制自己的状态，可变</li>
<li>props 是外部传入的数据参数，不可变；</li>
<li>没有state的叫做无状态组件，有state的叫做有状态组件；</li>
<li>多用 props，少用 state，也就是多写无状态组件。</li>
</ul>
<h2 id="1-14-当调用setState时，React-render-是如何工作的？"><a href="#1-14-当调用setState时，React-render-是如何工作的？" class="headerlink" title="1.14  当调用setState时，React render 是如何工作的？"></a>1.14  当调用setState时，React render 是如何工作的？</h2><ul>
<li><p>虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下React 是没有优化的。</p>
</li>
<li><p>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</p>
</li>
</ul>
<h2 id="1-15-hooks"><a href="#1-15-hooks" class="headerlink" title="1.15 hooks"></a>1.15 hooks</h2><h3 id="Hooks简介"><a href="#Hooks简介" class="headerlink" title="Hooks简介"></a>Hooks简介</h3><p>React的组件创建方式，一种是类组件，一种是纯函数组件</p>
<ul>
<li>纯函数组件没有状态</li>
<li>纯函数组件没有生命周期</li>
<li>纯函数组件没有this</li>
</ul>
<p><strong>使用Hooks的优点：</strong></p>
<ul>
<li>告别难以理解的Class( this 和 生命周期 的痛点)</li>
<li>解决业务逻辑难以拆分的问题</li>
<li>使状态逻辑复用变得简单可行</li>
<li>函数组件从设计思想上来看更加契合React的理念</li>
</ul>
<p><strong>Hooks并非万能</strong>:</p>
<ul>
<li>Hooks暂时还不能完全的为函数组件补齐类组件地能力（如生命周期的getSnapshotBeforeUpdate、componentDidCatch方法暂时还未实现）</li>
<li>将类组件的复杂变成函数组件的轻量，可能使用者并不能很好地消化这种复杂</li>
<li>Hooks在使用层面有着严格地规则约束</li>
</ul>
<h3 id="Hook函数（9种）"><a href="#Hook函数（9种）" class="headerlink" title="Hook函数（9种）"></a>Hook函数（9种）</h3><ol>
<li>useState()：状态钩子</li>
<li>useContext()：共享状态钩子</li>
<li>useEffect()：副作用钩子</li>
<li>useReducer()：Action钩子</li>
<li>userRefef()：Ref Hook可以<strong>在函数组件中存储、查找组件内的标签或任意其它数据</strong></li>
<li>useMemo()： 主要<strong>用来解决使用React hooks产生的无用渲染的性能问题</strong></li>
<li>useCallback()： 主要<strong>是为了性能的优化</strong></li>
<li>useLayoutEffect() ：和useEffect相同，<strong>都是用来执行副作用，但是它会在所有的DOM变更之后同步调用effect</strong>。useLayoutEffect和useEffect最大的区别就是一个是同步，一个是异步。</li>
<li>useImperativeHandle()： 可以<strong>在使用 ref 时自定义暴露给父组件的实例值。</strong></li>
</ol>
<h3 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h3><p><strong>自定义 Hooks：是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook</strong></p>
<p><strong>自定义Hooks：可以封装状态，能够更好的实现状态共享</strong></p>
<h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><h2 id="1-1-前端为什么要进行打包和构建"><a href="#1-1-前端为什么要进行打包和构建" class="headerlink" title="1.1 前端为什么要进行打包和构建"></a>1.1 前端为什么要进行打包和构建</h2><ol>
<li>体积更小（Tree-Shaking、压缩、合并），加载更快</li>
<li>编译高级语言和语法（TS，ES6+，模块化，scss）</li>
<li>兼容性和错误检查（Polyfill、postcss、eslint)</li>
<li>统一、高效的开发环境</li>
<li>统一的构建流程和产出标准</li>
<li>集成公司构建规范（提测、上线等）</li>
</ol>
<h2 id="1-2-如何提高webpack的构建速度"><a href="#1-2-如何提高webpack的构建速度" class="headerlink" title="1.2 如何提高webpack的构建速度"></a>1.2 如何提高webpack的构建速度</h2><ol>
<li>优化babel-loader 开启缓存</li>
<li>使用module中的Noparse，不去解析属性值代表的库的依赖（需要在webpack.config.js的module节点添加noParse配置，使用|分割）</li>
<li>可以使用webpack内置插件lgnorePlugin插件（作用：忽略第三方包指定目录，让这些指定目录不要被打包进去）</li>
<li>使用happyPack多进程打包（需要下载）</li>
<li>使用parallelUgligyPlugin多进程压缩js（默认使用uglifyJs来压缩代码，单进程）</li>
</ol>
<h2 id="1-3-代码分割的本质是什么？"><a href="#1-3-代码分割的本质是什么？" class="headerlink" title="1.3 代码分割的本质是什么？"></a>1.3 代码分割的本质是什么？</h2><ol>
<li>代码分割的本质就是在源代码直接上线和达成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</li>
<li>源码直接上线：虽然过程可控，但是http请求多，性能开销大。</li>
<li>打包成唯一脚本：服务器压力小，但是页面空白期长，用户体验不好。</li>
</ol>
<h2 id="1-4webpack的基本功能有哪些？"><a href="#1-4webpack的基本功能有哪些？" class="headerlink" title="1.4webpack的基本功能有哪些？"></a>1.4webpack的基本功能有哪些？</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">代码转换</td>
<td align="left">typescript编译成JavaScript、scss编辑成css</td>
</tr>
<tr>
<td align="left">文件优化</td>
<td align="left">压缩JavaScript、css、html、压缩合并图片</td>
</tr>
<tr>
<td align="left">代码分割</td>
<td align="left">提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</td>
</tr>
<tr>
<td align="left">模块合并</td>
<td align="left">采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</td>
</tr>
<tr>
<td align="left">自动刷新</td>
<td align="left">监听本地源代码的变化，自动构建，刷新浏览器</td>
</tr>
<tr>
<td align="left">代码校验</td>
<td align="left">在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</td>
</tr>
<tr>
<td align="left">自动发布</td>
<td align="left">更新完代码后，自动构建出线上发布代码并传输给发布系统</td>
</tr>
</tbody></table>
<h2 id="1-5-文件指纹是什么？"><a href="#1-5-文件指纹是什么？" class="headerlink" title="1.5 文件指纹是什么？"></a>1.5 文件指纹是什么？</h2><p> 文件指纹是打包之后的文件后缀名。</p>
<p>        chunkhash：和webpack打包的chunk有关，不同的entry会生出不同的chunkhash。</p>
<p>                js后缀名：filename:’[name][chunkhash:8].js’,</p>
<p>        contenthash：根据文件内容来定义hash，文件内容不变，则其不变。</p>
<p>                css后缀名：filename:’[name][contenthash:8].css’,</p>
<p>        hash：和整个项目构建有关，只要项目文件有修改，整个构建的hash值就会修改。</p>
<p>                img后缀名：name:’[name][hash:8].[ext]’</p>
<h2 id="x20-1-6-为什么说vite比webpack更快？"><a href="#x20-1-6-为什么说vite比webpack更快？" class="headerlink" title="&#x20;1.6 为什么说vite比webpack更快？"></a>&#x20;1.6 为什么说vite比webpack更快？</h2><ol>
<li>webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。</li>
<li>vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。</li>
<li>vite在启动的时候不需要打包，意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。</li>
<li>&#x20;当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。</li>
<li>&#x20;在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。</li>
<li>&#x20;当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS&#x20;</li>
</ol>
<h2 id="1-7-vite工作原理"><a href="#1-7-vite工作原理" class="headerlink" title="1.7 vite工作原理"></a>1.7 vite工作原理</h2><p>vite是一种现代化的前端开发工具，其工作原理主要分为以下几个步骤</p>
<ol>
<li>基于ESM构建：Vite作为一款基于ESM的前端构建工具，通过ES模块提供的动态导入功能来实现快速的开发和构建。</li>
<li>零配置开发：Vite允许开发者在不需要任何配置的情况下启动一个服务器进行开发，通过对文件的即时编译和缓存，来提高开发效率。</li>
<li>基于浏览器原生的ESM加载：Vite将所有文件视为ES模块，并且在开发时会直接从源代码加载模块，而不是打包后的文件，从而可以避免打包的过程带来的性能损失。</li>
<li>按需编译和缓存：Vite会按需编译和缓存依赖项，只有当需要更新时才会进行重新编译，缓存让开发者可以忽略无关的代码变化。</li>
<li>插件化架构：Vite的插件化架构可以方便地扩展其功能，例如使用插件来处理CSS、处理图片、压缩源代码等等。</li>
</ol>
<h2 id="x20-1-8-vite核心原理"><a href="#x20-1-8-vite核心原理" class="headerlink" title="&#x20;1.8 vite核心原理"></a>&#x20;1.8 vite核心原理</h2><ul>
<li>Vite其核心原理是利用浏览器现在已经支持ES6的import，碰见import就会发送一个HTTP请求去加载文件。</li>
<li>Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出许多！</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li>快速的冷启动：基于Esbuild的依赖进行预编译优化 （Esbuild 打包速度太快了，比类似的工具快10~100倍 ）</li>
<li>增加缓存策略：源码模块使用协商缓存，依赖模块使用强缓；因此一旦被缓存它们将不需要再次请求</li>
<li>&#x20;HMR（热更新）：当修改代码时，HMR 能够在不刷新页面的情况下，把页面中发生变化的模块，替换成新的模块，同时不影响其他模块的正常运作</li>
<li>&#x20;基于 Rollup 打包：生产环境下由于esbuild对css和代码分割并使用Rollup进行打包</li>
<li>高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载&#x20;</li>
</ol>
<h2 id="1-9-Vite-冷启动为什么快"><a href="#1-9-Vite-冷启动为什么快" class="headerlink" title="1.9 Vite 冷启动为什么快"></a>1.9 Vite 冷启动为什么快</h2><p>vite 运行 Dev 命令后只做了两件事情</p>
<ol>
<li>启动本地服务器并注册了一些中间件</li>
<li>使用 ESbuild 预构建模块</li>
</ol>
<h2 id="1-10-vite生产环境缺点"><a href="#1-10-vite生产环境缺点" class="headerlink" title="1.10 vite生产环境缺点"></a>1.10 vite生产环境缺点</h2><ol>
<li><p>Vite 在是直接把转化后的 es module 的JavaScript，扔给浏览器，让浏览器根据依赖关系，自己去加载依赖</p>
</li>
<li><p>那有人就会说了，那放到 生产环境 时，是不是可以不打包，直接在开个 Vite 服务就行，反正浏览器会自己去根据依赖关系去自己加载依赖。答案是不行的，为啥呢：</p>
<p>1、你代码是放在服务器的，过多的浏览器加载依赖肯定会引起更多的网络请求</p>
<p>2、为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割、CSS处理，这些优化操作，目前 esbuild 还不怎么完善&#x20;</p>
</li>
</ol>
<h2 id="x20-1-11-vite和webpack优缺点对比"><a href="#x20-1-11-vite和webpack优缺点对比" class="headerlink" title="&#x20;1.11 vite和webpack优缺点对比"></a>&#x20;1.11 vite和webpack优缺点对比</h2><ul>
<li>更快的启动时间和更新速度</li>
<li>更好的开发体验：自动打开浏览器、自动刷新页面 配置简单。</li>
<li>不需要过多的配置就可以搭建基本的开发环境 更少的依赖。</li>
<li>借助原生的ES模块</li>
<li>避免了过多的额外依赖</li>
</ul>
<p>&#x20;<strong>缺点：</strong></p>
<ul>
<li>vite的构建技术主要用于中小型项目，对于大型项目的支持不如webpack&#x20;</li>
<li>vite主要是针对vue3的单页面应用，对于多页面应用、ssr应用、自定义流程应用不如webpack&#x20;</li>
<li>开发环境首屏加载慢，懒加载慢&#x20;</li>
<li>vite由于基于原生ES模块，不支持commonJs；webpack关注兼容性，vite关注浏览器端的开发体验，vite的生态还不如webpack</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">kilito</div><div class="post-copyright__author_desc">生活明朗,万物可爱</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://ekilito.github.io/posts/3929.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://ekilito.github.io/posts/3929.html')">八股文</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d894b4a4f06.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d894b1726cd.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://ekilito.github.io/posts/3929.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=八股文&amp;url=https://ekilito.github.io/posts/3929.html&amp;pic=https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ekilito.github.io" target="_blank">kilito</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/883eae6.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/09/04/64f5e41cda997.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智慧园区后台</div></div></a></div><div class="next-post pull-right"><a href="/posts/3936.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试准备</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/3936.html" title="面试准备"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-13</div><div class="title">面试准备</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/01/64c884ccc8322.png" ait="status"/></div></div><div class="author-info__description">以欢喜心，慢度日常，四季清宁，万物可爱.</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">kilito</h1><div class="author-info__desc">生活明朗,万物可爱</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ekilito" target="_blank" title="github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/194984444" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://cdn.jsdelivr.net/gh/ekilito/picgoblog/img/weixinhao.jpg" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://res.abeim.cn/api/qq/?qq=2856509748" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-qq"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://m.weibo.cn/u/7520593701" target="_blank" title="微博"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weibo"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://music.163.com/#/user/home?id=573476405" target="_blank" title="网易云"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">🍧今天也是元气满满的一天呢~ 开心一点！🍧</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80"><span class="toc-text">前端基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-h5%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 h5新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1.3 伪类和伪元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%BC%95%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8Clink%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.5 引入样式时，link和@import的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E5%85%83%E7%B4%A0%E7%9A%84alt%E5%92%8Ctitle%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">1.10 元素的alt和title有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-a%E6%A0%87%E7%AD%BE%E4%B8%AD-%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8href-%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2-%E6%88%96-%E5%AE%9A%E4%BD%8D%E9%93%BE%E6%8E%A5"><span class="toc-text">1.15 a标签中 如何禁用href 跳转页面 或 定位链接?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9BSEO"><span class="toc-text">1.19 前端需要注意哪些SEO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.1 标准盒模型和IE盒模型两者的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%9B%92%E5%AD%90%E5%A1%8C%E9%99%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.2 盒子塌陷是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AEpadding%EF%BC%8Cmargin%E5%90%97%EF%BC%9F"><span class="toc-text">1.4 行内元素可以设置padding，margin吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-BFC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.6 BFC是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%9D%97%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD"><span class="toc-text">1.7 块元素居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-CSS-%E4%BC%98%E5%8C%96%E3%80%81%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.8 CSS 优化、提高性能的方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E6%9E%90CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">1.11 浏览器是怎样解析CSS选择器的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-display%E3%80%81position%E5%92%8Cfloat%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">1.13 display、position和float的相互关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-IFC-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.14 IFC 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E5%88%9D%E5%A7%8B%E5%8C%96-css-%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.15 为什么不建议使用通配符初始化 css 样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-CSS3-%E6%96%B0%E7%89%B9%E6%96%B0"><span class="toc-text">1.16 CSS3 新特新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-18-%E4%BB%80%E4%B9%88%E6%98%AFCSS-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">1.18 什么是CSS 预处理器？为什么使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E6%9E%90%E7%9A%84%EF%BC%9F"><span class="toc-text">1.19 浏览器是怎样解析的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-23-li-%E4%B8%8E-li-%E4%B9%8B%E9%97%B4%E6%9C%89%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E7%A9%BA%E7%99%BD%E9%97%B4%E9%9A%94%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-text">1.23 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-24-display-inline-block-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%98%BE%E7%A4%BA%E9%97%B4%E9%9A%99%EF%BC%9F"><span class="toc-text">1.24 display:inline-block 什么时候会显示间隙？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-27-before-%E5%92%8C-after-%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%81%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">1.27 ::before 和::after 中双冒号和单冒号有什么区别、作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-29-%E6%9C%AA%E7%9F%A5%E9%AB%98%E5%BA%A6%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.29 未知高度元素垂直居中、垂直居中的实现方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-34-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88"><span class="toc-text">1.34 移动端适配方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-let-var-const%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.1 let var const的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">1.2 js数据类型，区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">1.3 Javascript 创建对象的几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E3%80%81-%E5%92%8Cobject-is-%E5%8C%BA%E5%88%AB"><span class="toc-text">1.4 &#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和object.is 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">1.5 如何区分数组和对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">1.6 作用域和作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-constructor%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1.7 constructor的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-map-%E5%92%8C-forEach-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.10 map 和 forEach 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-for-of-%E5%8F%AF%E4%BB%A5%E9%81%8D%E5%8E%86%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">1.11 for of 可以遍历哪些对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-js%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">1.11 js遍历对象的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2"><span class="toc-text">1.13 new操作符具体干了什么呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.14 作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-javascript%E4%B8%ADarguments%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1.15 javascript中arguments相关的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-instanceOf%E4%BD%9C%E7%94%A8-%E5%8D%B3%E5%8E%9F%E7%90%86"><span class="toc-text">1.16 instanceOf作用 即原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-17-%E6%95%B0%E7%BB%84%E5%92%8C%E4%BC%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.17 数组和伪数组的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-js-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1.19 简单说说 js 中有哪几种内存泄露的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-23-promise%E5%92%8C-async-await-%E5%8C%BA%E5%88%AB"><span class="toc-text">1.23 promise和 async await 区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-24-defer%E5%92%8Casync%E5%8C%BA%E5%88%AB"><span class="toc-text">1.24 defer和async区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-25-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">1.25 同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-27-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%8F%98%E4%B8%BAnull"><span class="toc-text">1.27 null 和 undefined 的区别，如何让一个属性变为null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-29-call-appy-bind%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.29 call appy bind的作用和区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-30-this%E6%8C%87%E5%90%91%EF%BC%88%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">1.30 this指向（普通函数、箭头函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-32-%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9-%E5%8F%8A%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.32 继承，优缺点 及方法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-1%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">1.32.1原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">1.32.2 构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">1.32.3 组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">1.32.4 原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-5-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">1.32.5 寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-6-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">1.32.6 寄生组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-7-ES6-class-extends"><span class="toc-text">1.32.7 ES6 class extends</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-33-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%A6"><span class="toc-text">1.33 扩展运算符 …</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-33-1%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E8%83%BD%E8%A2%AB%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">1.33.1哪些类型能被扩展操作符?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-33-2-%E5%9C%BA%E6%99%AF"><span class="toc-text">1.33.2 场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-34-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">1.34 实现异步的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-34-1-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">1.34.1 回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-34-2-promise"><span class="toc-text">1.34.2 promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-34-3-%E7%94%9F%E6%88%90%E5%99%A8generator-yield"><span class="toc-text">1.34.3 生成器generator&#x2F;yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-34-3-async-await"><span class="toc-text">1.34.3 async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-36-%E4%B8%BA%E4%BB%80%E4%B9%88js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.36 为什么js是单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-37-%E6%AD%BB%E9%94%81"><span class="toc-text">1.37 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-38-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">1.38 暂时性死区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-cookie-sessionStorage-localStorage-%E5%8C%BA%E5%88%AB"><span class="toc-text">1.1 cookie sessionStorage localStorage 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E4%BC%9A%E8%BF%87%E6%9C%9F%E7%9A%84localStorage%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%83%B3%E6%B3%95"><span class="toc-text">1.2 如何写一个会过期的localStorage，说说想法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-localStorage-%E8%83%BD%E8%B7%A8%E5%9F%9F%E5%90%97"><span class="toc-text">1.3 localStorage 能跨域吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-memory-cache-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF"><span class="toc-text">1.4 memory cache 如何开启</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-localstorage%E7%9A%84%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">1.5 localstorage的注意哪些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">1.6 浏览器输入URL发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">1.7 浏览器是如何渲染页面的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E9%87%8D%E7%BB%98%E3%80%81%E9%87%8D%E6%8E%92"><span class="toc-text">1.8 重绘、重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-loop%EF%BC%89"><span class="toc-text">1.9 事件循环（Event loop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-let-a-1-%E6%8C%82%E8%BD%BD%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">1.10 let a &#x3D; 1 挂载在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">1.11 浏览器垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-cookie"><span class="toc-text">1.12 cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-text">1.13 调试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">a.谷歌浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E5%85%B6%E4%BB%96"><span class="toc-text">b.其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-text">网络传输</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%B7%A8%E5%9F%9F"><span class="toc-text">1.1 跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BF%9D%E6%8C%81%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1"><span class="toc-text">1.2 有什么方法可以保持前后端通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1.1 顺序存储结构和链式存储结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3-Vue-%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F"><span class="toc-text">1.1 怎样理解 Vue 的单向数据流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">1.2 谈谈你对 Vue 生命周期的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-keep-alive-%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">1.3 谈谈你对 keep-alive 的了解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">1.4 组件中 data 为什么是一个函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E4%BD%A0%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">1.5 你对vue项目哪些优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">1.6 vue中的key有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.7 虚拟dom的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E8%99%9A%E6%8B%9Fdom%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">1.8 虚拟dom实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Vue-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">1.9 Vue 是如何实现数据双向绑定的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-20-Vue-router-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">1.20 Vue-router 有哪几种路由守卫?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-21-Vue-router-%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1.21 Vue-router 的钩子函数都有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-22-vue-router-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">1.22 vue-router 路由模式有几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-23-%E8%AF%B4%E4%B8%8B-vue-router-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-hash-%E5%92%8C-history-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">1.23 说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-24-vuex-%E5%8C%85%E6%8B%AC%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="toc-text">1.24 vuex 包括几个模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-25-Object-defineProperty-%E5%92%8C-Proxy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.25 Object.defineProperty 和 Proxy 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-26-MVVM-%E5%92%8C-MVC-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88%EF%BC%9F"><span class="toc-text">1.26 MVVM 和 MVC 区别是什么？哪些场景适合？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-27-vue-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AE-data"><span class="toc-text">1.27 vue 中如何重置 data?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-28-vue3-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.28 vue3 新特性有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-29-vue3-%E7%BB%84%E5%90%88%E5%BC%8FAPI%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%9C%89%E5%8F%98%E5%8C%96%E5%90%97"><span class="toc-text">1.29 vue3 组合式API生命周期钩子函数有变化吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-30-watch-%E5%92%8C-watchEffect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.30 watch 和 watchEffect 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-31-vue%E4%B8%ADv-if%E5%92%8Cv-for%E4%BC%98%E5%85%88%E7%BA%A7%E5%9C%A8vue2%E5%92%8Cvue3%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.31 vue中v-if和v-for优先级在vue2和vue3中的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-32-script-setup-%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">1.32 script setup 是干啥的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-33-vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">1.33 vue常用的修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-34-vue2-0-%E5%92%8C-vue3-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E6%9B%B4%E6%96%B0"><span class="toc-text">1.34 vue2.0 和 vue3.0 有什么区别？ 双向绑定更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-35-reactive%E4%B8%8Eref%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.35 reactive与ref的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-36-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.36 $route 和 $router 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-37-v-on%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">1.37 v-on可以监听多个方法吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-38-v-model%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">1.38 v-model的使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-39-vue%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-text">1.39 vue遇到的坑，如何解决的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-40-%E8%AF%B4%E8%AF%B4vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">1.40 说说vue中的diff算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-41-vue%E4%B8%AD%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-text">1.41 vue中怎么设置全局变量和全局组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-45-vue%E4%B8%AD%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%B1%9E%E6%80%A7%E6%97%B6%EF%BC%8C%E7%95%8C%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">1.45 vue中给对象添加新属性时，界面不刷新怎么办?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-46-vuex%E4%B8%AD%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">1.46 vuex中的辅助函数怎么使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-47-%E5%88%B7%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8E%EF%BC%8CVuex%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">1.47 刷新浏览器后，Vuex的数据是否存在？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-1-48-vue%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%8F%82%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text"> 1.48 vue路由跳转传参的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-50-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">1.50 单页面应用和多页面应用区别及优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-51-EventBus%E6%B3%A8%E5%86%8C%E5%9C%A8%E5%85%A8%E5%B1%80%E4%B8%8A%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E6%97%B6%E4%BC%9A%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-text">1.51 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-52-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">1.52 自定义指令详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-53-slot%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.53 slot是什么？有什么作用？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-54-nextTick%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.54 $nextTick的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%99%9A%E6%8B%9Fdom%E5%92%8C%E7%9C%9F%E5%AE%9Edom"><span class="toc-text">1.1 虚拟dom和真实dom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">1.2 react组件间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-redux%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.3 redux的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.4 React组件生命周期的阶段是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8AReact-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">1.5 详细解释React 组件的生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-router"><span class="toc-text">1.6 router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-React-%E7%9A%84-refs-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">1.7 React 的 refs 有什么了解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E5%88%97%E5%87%BA%E4%B8%80%E4%BA%9B%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-Refs-%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1.8 列出一些应该使用 Refs 的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-redux-saga%E5%92%8Cmobx%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">1.9 redux-saga和mobx的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-React-%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.10 简述一下 React 的源码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-setState%E5%88%B0%E5%BA%95%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5"><span class="toc-text">1.11 setState到底是异步还是同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-redux%E5%BC%82%E6%AD%A5%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-text">1.12  redux异步中间件之间的优劣?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-state-%E5%92%8C-props-%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-text">1.13 state 和 props 区别是啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-%E5%BD%93%E8%B0%83%E7%94%A8setState%E6%97%B6%EF%BC%8CReact-render-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">1.14  当调用setState时，React render 是如何工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-hooks"><span class="toc-text">1.15 hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks%E7%AE%80%E4%BB%8B"><span class="toc-text">Hooks简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook%E5%87%BD%E6%95%B0%EF%BC%889%E7%A7%8D%EF%BC%89"><span class="toc-text">Hook函数（9种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Hooks"><span class="toc-text">自定义Hooks</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-text">打包工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%89%8D%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E5%92%8C%E6%9E%84%E5%BB%BA"><span class="toc-text">1.1 前端为什么要进行打包和构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="toc-text">1.2 如何提高webpack的构建速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.3 代码分割的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.4webpack的基本功能有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.5 文件指纹是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-1-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4vite%E6%AF%94webpack%E6%9B%B4%E5%BF%AB%EF%BC%9F"><span class="toc-text"> 1.6 为什么说vite比webpack更快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-vite%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.7 vite工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-1-8-vite%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text"> 1.8 vite核心原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Vite-%E5%86%B7%E5%90%AF%E5%8A%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">1.9 Vite 冷启动为什么快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-vite%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%BC%BA%E7%82%B9"><span class="toc-text">1.10 vite生产环境缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x20-1-11-vite%E5%92%8Cwebpack%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-text"> 1.11 vite和webpack优缺点对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3936.html" title="面试准备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试准备"/></a><div class="content"><a class="title" href="/posts/3936.html" title="面试准备">面试准备</a><time datetime="2023-10-13T06:43:53.500Z" title="发表于 2023-10-13 14:43:53">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3929.html" title="八股文"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/21/64e360fb93fef.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文"/></a><div class="content"><a class="title" href="/posts/3929.html" title="八股文">八股文</a><time datetime="2023-10-02T05:10:47.779Z" title="发表于 2023-10-02 13:10:47">2023-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/883eae6.html" title="智慧园区后台"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/09/04/64f5e41cda997.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智慧园区后台"/></a><div class="content"><a class="title" href="/posts/883eae6.html" title="智慧园区后台">智慧园区后台</a><time datetime="2023-09-04T14:01:29.006Z" title="发表于 2023-09-04 22:01:29">2023-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f82ea27.html" title="Vue原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2022/07/17/62d4106238e7c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue原理"/></a><div class="content"><a class="title" href="/posts/f82ea27.html" title="Vue原理">Vue原理</a><time datetime="2023-08-20T08:31:26.861Z" title="发表于 2023-08-20 16:31:26">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/undefined.html" title="设计模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2022/11/30/6386ccb347d84.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/undefined.html" title="设计模式">设计模式</a><time datetime="2023-08-19T08:57:01.871Z" title="发表于 2023-08-19 16:57:01">2023-08-19</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:2856509748@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/7520593701" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://res.abeim.cn/api/qq/?qq=2856509748" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/26/64ea10217f8f4.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/ekilito" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/194984444" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAAyFaeLYIe730NcTBynr1H-tGRx3EfYELNjx05MMP4pEc" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/糖果屋-营业中-6adea8?style=social&amp;logo=cakephp" alt="小小清" title="小小清"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2023 By <a class="footer-bar-link" href="/" title="kilito" target="_blank">kilito</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期.","你今天真好看！","今天也是元气满满的一天呢！","以欢喜心&#44;慢度日常&#44;四季清宁&#44;万物可爱."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.0.15/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/ekilito/blog" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://7bu.top/" title="图床">图床</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://wudl.cn" title="主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/48.png" alt="主页"/><span class="back-menu-item-text">主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.wudl.cn" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://ccv-engineer.gitee.io/" title="旧站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/32.png" alt="旧站"/><span class="back-menu-item-text">旧站</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://7bu.top/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tag faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://chatgpt.wudl.cn"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> ChatGPT</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://gpt.zhizhubao.com/chat"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 私人助理</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=891137324&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/kongtiao/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zaobao/"><span> 早报</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Generato/" style="font-size: 0.88rem;">Generato<sup>1</sup></a><a href="/tags/fetch/" style="font-size: 0.88rem;">fetch<sup>1</sup></a><a href="/tags/koa/" style="font-size: 0.88rem;">koa<sup>1</sup></a><a href="/tags/this/" style="font-size: 0.88rem;">this<sup>1</sup></a><a href="/tags/vue%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">vue原理<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99/" style="font-size: 0.88rem;">手写<sup>1</sup></a><a href="/tags/%E6%89%8B%E5%86%99Promise/" style="font-size: 0.88rem;">手写Promise<sup>1</sup></a><a href="/tags/%E6%99%BA%E6%85%A7%E5%9B%AD%E5%8C%BA/" style="font-size: 0.88rem;">智慧园区<sup>1</sup></a><a href="/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/" style="font-size: 0.88rem;">柯里化<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>1</sup></a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 0.88rem;">继承<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7061615494" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/user/home?id=573476405&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script> // 消除控制台打印
 var HoldLog = console.log;
 console.log = function () {};
 let now1 = new Date();
 queueMicrotask(() => {
   const Log = function () {
     HoldLog.apply(console, arguments);
   }; //在恢复前输出日志
   const grt = new Date("08/04/2023 20:00:00"); //此处修改你的建站时间或者网站上线时间
   now1.setTime(now1.getTime() + 250);
   const days = (now1 - grt) / 1000 / 60 / 60 / 24;
   const dnum = Math.floor(days);
   const ascll = [
     `欢迎来到ekilito🥝の小窝!`,
     `Future is now 🍭🍭🍭`,
     `
         
  
██    ██   ██   ██        ██   ████████    ██████  
██  ██     ██   ██        ██      ██      ██    ██ 
████       ██   ██        ██      ██      ██    ██ 
██  ██     ██   ██        ██      ██      ██    ██ 
██    ██   ██   ███████   ██      ██       ██████  
         
         `,
     "已上线",
     dnum,
     "天",
     "©2022 By kilito V1.6.6",
   ];
   const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

   setTimeout(
     Log.bind(
       console,
       `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
       "color:#3b70fc",
       "",
       "color:#3b70fc",
       "color:#3b70fc",
       "",
       "color:#3b70fc",
       ""
     )
   );
   setTimeout(
     Log.bind(
       console,
       `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
       "color:white; background-color:#4fd953",
       "",
       "",
       'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
     )
   );

   setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

   setTimeout(
     console.warn.bind(
       console,
       "%c ⚡ Powered by 小小清 %c 你正在访问 kilito 的博客.",
       "color:white; background-color:#f0ad4e",
       ""
     )
   );

   setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

   setTimeout(
     console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
   );
 });</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("08/04/2023 20:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://img.shields.io/badge/糖果屋-打烊了-6adea8?style=social&amp;logo=coffeescript";
      img.title = "小小清";
      img.alt = "小小清";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.wudl.cn/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.wudl.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.wudl.cn/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "longlong1015@outlook.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/gghello.js"></script><script src="/js/iconfont.js"></script><script src="/js/cursur.js"></script><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="/js/fps.js"></script><div id="fps"></div><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>