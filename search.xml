<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试准备</title>
      <link href="/posts/3936.html"/>
      <url>/posts/3936.html</url>
      
        <content type="html"><![CDATA[<h5 id="3-css的盒模型"><a href="#3-css的盒模型" class="headerlink" title="3.css的盒模型"></a>3.css的盒模型</h5><ol><li>w3c标准的盒模型（标准盒模型）<ol><li>width: 指的是内容区域 content 的宽度</li><li>标准盒模型下盒子的大小 &#x3D; content + padding + border + margin</li></ol></li><li>怪异盒模型<ol><li>width：指的是 content + border + padding 总的宽度</li><li>怪异盒模型下盒子的大小 &#x3D; width(content + padding + border) + margin</li></ol></li><li>box-sizing<ol><li>content-box: 默认值 标准模型 ，border 和 padding 不算到width中</li><li>border-box: 怪异盒模型 ， border 和 padding 规划到width中</li></ol></li></ol><h5 id="4-css中选择器的优先级以及css权重如何计算？"><a href="#4-css中选择器的优先级以及css权重如何计算？" class="headerlink" title="4.css中选择器的优先级以及css权重如何计算？"></a>4.css中选择器的优先级以及css权重如何计算？</h5><p>important &gt; 行内样式   &gt; Id选择器   &gt; 类选择器  &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><h5 id="5-px、em、rem的区别？"><a href="#5-px、em、rem的区别？" class="headerlink" title="5.px、em、rem的区别？"></a>5.px、em、rem的区别？</h5><ol><li>px：绝对单位。像素px是相对于显示器屏幕分辨率而言的。</li><li>em：是相对长度单位，相对于当前对象内为文字的字体尺寸。如当前的行内文字的字体尺寸未被人设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小因此并不是一个固定的值。</li><li>rem：c3新增的一个相对单位（root em，根em），使用rem为元素设定字体大小时，任然是相对大小，但相对的只是html根元素。</li><li>区别：IE无法调整那些使用px作为单位的字体大小，而em和rem可以缩放，rem相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的有点于一身。通过它可以做到只修改根元素就成比例的调整所有字体的大小。</li></ol><h5 id="6-rem适配方案"><a href="#6-rem适配方案" class="headerlink" title="6.rem适配方案"></a>6.rem适配方案</h5><p>通用方案（有网易方案、手淘方案）</p><ol><li>设置根 font-size （换算规则 1rem 不能小于 12px）</li><li>通过媒体查询分别设置每个屏幕的根 font-size</li><li>CSS直接除以 2 再除以100 即可换算为 rem</li></ol><p>优：有一定的适用性，换算也较为简单  缺：有兼容性的坑</p><h5 id="7-display-none-与-visibility-hidden-的区别？"><a href="#7-display-none-与-visibility-hidden-的区别？" class="headerlink" title="7.display:none 与 visibility:hidden 的区别？"></a>7.display:none 与 visibility:hidden 的区别？</h5><ol><li>display: none 设置该属性后，该元素下的元素都会隐藏，占据的空间都会消失</li><li>visibility：hidden  元素虽然不见了，但是依然占据空间的位置</li></ol><p>区别：</p><ol><li>visibility 具有继承性，其子元素也会继承此属性。 visibility：visible 子元素会显示</li><li>visibility 不会响应计数器的计算，虽然隐藏掉了，但是计数器依然继续运行着</li><li>css3中，transition中支持visibility属性，不支持display，因此transition可以延迟执行，配合visibility使用纯css实现hover延时显示效果可以提高用户体验</li><li>display：none 会引起回流（重排）和重绘， visibility：hidden 会引起重绘</li></ol><h5 id="8-position的值有哪些，分别有哪些作用？"><a href="#8-position的值有哪些，分别有哪些作用？" class="headerlink" title="8.position的值有哪些，分别有哪些作用？"></a>8.position的值有哪些，分别有哪些作用？</h5><ol><li><p>静态定位 static ：默认值，不脱离文档流，top、right、bottom、left等属性不生效</p></li><li><p>绝对定位 absolute：关键是找对参照物，找到最近一级的带有定位的父级元素进行位置移动，如果找不到，那么相对于浏览器窗口进行定位。 元素会脱离正常文档流，不在占据空间，margin：auto将会失效，通过top、left、bottom、right 来决定元素位置。</p></li><li><p>相对定位 relative ：参照物，元素偏移前位置。设置相对定位后，margin：auto仍然有效，不会脱离文档流</p></li><li><p>固定定位 fixed ：参照浏览器窗口。会脱离文档流。</p><p>当出现滚动条时，固定定位的元素不会跟随滚动条滚动，绝对定位会跟随滚动条滚动。</p></li></ol><h5 id="9-为什么会出现浮动？浮动元素有引起什么问题？如何清除浮动？"><a href="#9-为什么会出现浮动？浮动元素有引起什么问题？如何清除浮动？" class="headerlink" title="9.为什么会出现浮动？浮动元素有引起什么问题？如何清除浮动？"></a>9.为什么会出现浮动？浮动元素有引起什么问题？如何清除浮动？</h5><p>浮动将元素排除在普通流之外，即元素会脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留。</p><p><strong>为什么需要清除浮动</strong>？</p><ol><li>子元素浮动后，不占位置，元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动的元素同级的非浮动元素会跟随其后</li><li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面的结构解决方法</li></ol><p><strong>清除浮动的方式</strong>？</p><ol><li>使用 css 中的 clear：both；</li><li>给父元素添加 clearfix 样式；</li><li>给父元素设置双伪元素；</li><li>给父级元素设置 overflow:hidden;  或 overflow:auto; 本质是构建一个 BFC；</li></ol><h5 id="10-简述弹性盒子flex布局以及rem布局？"><a href="#10-简述弹性盒子flex布局以及rem布局？" class="headerlink" title="10.简述弹性盒子flex布局以及rem布局？"></a>10.简述弹性盒子flex布局以及rem布局？</h5><p>rem是CSS3新增的一个相对单位，相对于根节点（html）字体的大小，r 就是 root。</p><p>例如： html { font-size：12px }  则 2rem &#x3D; 24px</p><p>通过它就可以做到只修改根元素的大小，就能成比例的调整所有的字体大小，只依赖html的大小。</p><p>适配方案步骤：</p><ol><li>首先动态计算html的 font-size</li><li>将所有的px换算成rem（rem的换算是根据设计稿的像素计算的）</li></ol><p>注意：</p><ol><li>必须动态的去设置 html 的大小，才能适配</li><li>根据页面的宽度除以一个系数，把算出的这个值赋给html的font-size属性，rem换算值是根据psd设计图的宽度&#x2F;系数的rem系数。</li></ol><h5 id="11-如何解决margin塌陷？"><a href="#11-如何解决margin塌陷？" class="headerlink" title="11.如何解决margin塌陷？"></a>11.如何解决margin塌陷？</h5><ol><li>父盒子设置border，添加border后父子盒子就不是真正意义上的贴合， 可以设置border透明色</li><li>父盒子添加 overflow:hidden</li><li>父盒子添加 padding</li><li>父盒子添加 position：fixed</li><li>父盒子添加 display：table</li><li>利用伪元素给父元素的前面添加一个空元素</li></ol><h5 id="13-BFC是什么？"><a href="#13-BFC是什么？" class="headerlink" title="13.BFC是什么？"></a>13.BFC是什么？</h5><p>BFC直译为 “<strong>块级格式化上下文</strong>”。他是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。</p><p>布局规则：</p><ol><li>内部的 Box 会在垂直方向，一个接一个的放置。</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的margin 会发生重叠。</li><li>每个元素的 margin box 的左边，与包含快 border box 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li></ol><p>哪些元素会生成 BFC：</p><ol><li>根元素</li><li>float 属性不为 none</li><li>position 为 absolute 或 fixed</li><li>display 为 inline-block， table-cell， table-caption， flex， inline-flex </li><li>overflow 不为 visible</li></ol><h4 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h4><h5 id="1-JavaScript的基本类型有哪些？引用类型有哪些？null和undefined的区别？"><a href="#1-JavaScript的基本类型有哪些？引用类型有哪些？null和undefined的区别？" class="headerlink" title="1.JavaScript的基本类型有哪些？引用类型有哪些？null和undefined的区别？"></a>1.JavaScript的基本类型有哪些？引用类型有哪些？null和undefined的区别？</h5><ol><li>基本数据类型：Number、String、Boolean、null、undefined、Symbol（符号，ES6新增 ）、BigInt</li><li>引用数据类型：Function、Object、Array</li></ol><p>区别：</p><p>undefined：表示变量声明但未初始化时的值</p><p>null：表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null值表示一个空对象指针</p><p>ECMA标准要求null和undefined等值判断返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="2-如何判断JavaScript-的数据类型？"><a href="#2-如何判断JavaScript-的数据类型？" class="headerlink" title="2.如何判断JavaScript 的数据类型？"></a>2.如何判断JavaScript 的数据类型？</h5><ol><li><strong>typeof</strong></li></ol><p><strong>typeof</strong> 可以用来区分除了 null 类型以外的原始数据类型，对象类型的可以从普通对象里面识别出函数</p><ol start="2"><li><p><strong>instanceof</strong></p><p>instanceof 不能用于判断原始数据类型的数据！</p></li></ol><p>​        instanceof 可以用来判断对象的类型</p><p>需要注意的是，instanceof 的结果并不是一定可靠的，可以在ES7中通过自定义 Symbol.hasInstance 方法覆盖</p><ol start="3"><li><strong>Object.prototype.toString.call()</strong></li></ol><h5 id="3-简述创建函数的几种方式？"><a href="#3-简述创建函数的几种方式？" class="headerlink" title="3.简述创建函数的几种方式？"></a>3.简述创建函数的几种方式？</h5><ol><li>函数声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数表达式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>函数对象方式 new一个</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;return a+b&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="4-JavaScript-创建对象的几种方式？"><a href="#4-JavaScript-创建对象的几种方式？" class="headerlink" title="4.JavaScript 创建对象的几种方式？"></a>4.JavaScript 创建对象的几种方式？</h5><ol><li><p>字面量方式  推荐</p></li><li><p>用 Function 来模拟Class</p></li><li><p>使用工厂函数来创建 （Object关键字）</p></li><li><p>使用原型对象的方式 prototype 关键字</p></li><li><p>混合模式（原型和构造函数）</p></li><li><p>动态原型的方式（可以看作是混合模式的一种特例）</p></li></ol><h5 id="6-和-的区别？"><a href="#6-和-的区别？" class="headerlink" title="6.&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别？"></a>6.&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别？</h5><p>&#x3D;&#x3D;&#x3D;：等同符，既要判断值也要判断类型是否相等。</p><p>&#x3D;&#x3D;：等值符，两个等号只要值相等就可以。类型不同时会发生类型的自动转换，转换为相同的类型后作比较</p><h5 id="7-null，undefined-的区别？"><a href="#7-null，undefined-的区别？" class="headerlink" title="7.null，undefined 的区别？"></a>7.null，undefined 的区别？</h5><p>null 表示一个对象被定义了，值为“空值”； undefined 表示不存在这个值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="attr">undefined</span>: 是一个表示 “无” 的原始值或者说表示 “缺少值”，就是此处应该有一个值，但还没有定义。</span><br><span class="line"></span><br><span class="line">当尝试读取时就会返回 <span class="literal">undefined</span> ，例如变量被声明了，但没有赋值时，就等于 <span class="literal">undefined</span>。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="attr">null</span>: 是一个对象（空对象，没有任何属性和方法）</span><br><span class="line">例如 作为函数的参数，表示该函数的参数不是对象； 在验证 <span class="literal">null</span> 时，一定要使用 ===</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/<span class="literal">undefined</span></span><br><span class="line"><span class="number">1.</span> 变量被声明了，但没有赋值时，就等于 <span class="literal">undefined</span></span><br><span class="line"><span class="number">2.</span> 调用函数时，应该提供的参数没有提供，该参数等于 <span class="literal">undefined</span></span><br><span class="line"><span class="number">3.</span> 对象没有赋值的属性，该属性的值为 <span class="literal">undefined</span></span><br><span class="line"><span class="number">4.</span> 函数没有返回值时，默认返回 <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">/<span class="literal">null</span>  表示‘没有对象’，即该处不应该有值。</span><br><span class="line"><span class="number">1.</span> 作为函数的参数，表示该函数的参数不是对象</span><br><span class="line"><span class="number">2.</span> 作为对象原型链的终点</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="8-JavaScript-中什么情况下会返回-undefined-值？"><a href="#8-JavaScript-中什么情况下会返回-undefined-值？" class="headerlink" title="8.JavaScript 中什么情况下会返回 undefined 值？"></a>8.JavaScript 中什么情况下会返回 undefined 值？</h5><ol><li><p>访问声明，但是没有初始化的变量</p></li><li><p>访问不存在的属性</p></li><li><p>访问函数的参数没有被显式的传递值</p></li><li><p>访问任何被设置为 undefined 值的变量</p></li><li><p>没有定义 return 的函数隐式返回</p></li><li><p>函数 return 没有显示的返回任何内容</p></li></ol><h5 id="9-如何区分数组和对象？"><a href="#9-如何区分数组和对象？" class="headerlink" title="9.如何区分数组和对象？"></a>9.如何区分数组和对象？</h5><ol><li>通过 es6 中的 Array.isArray 来识别</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([])  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过 istanceof 来识别</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>   <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Array</span>   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过调用 constructor 来识别</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.<span class="property">constructor</span>  <span class="comment">// object</span></span><br><span class="line">[].<span class="property">constructor</span>  <span class="comment">// array</span></span><br></pre></td></tr></table></figure><ol start="4"><li>通过 object.prototype.toString.call 方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])  <span class="comment">// [&quot;object Array&quot;]</span></span><br><span class="line">object.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// [&quot;object Object&quot;]</span></span><br></pre></td></tr></table></figure><h5 id="10-多维数组降维的几种方法？"><a href="#10-多维数组降维的几种方法？" class="headerlink" title="10.多维数组降维的几种方法？"></a>10.多维数组降维的几种方法？</h5><ol><li>数组字符串化  split( ‘ ,’ )</li><li>递归</li><li>Array.prototype.flat()</li><li>使用 stack 无限反嵌套多层嵌套数组</li><li>使用 reduce、concat 和 递归无限反嵌套多层嵌套的数组</li></ol><h5 id="13-什么是类数组（伪数组），如何转换为真实的数组？"><a href="#13-什么是类数组（伪数组），如何转换为真实的数组？" class="headerlink" title="13.什么是类数组（伪数组），如何转换为真实的数组？"></a>13.什么是类数组（伪数组），如何转换为真实的数组？</h5><p>伪数组：无法直接调用数组方法或期望 length 属性有什么特殊的行为，不具有数组的 push、pop方法，但仍可以对它们进行遍历。典型的是函数 document.childnodes 之类的、<strong>dom.querySelectorAll</strong>等获取的NodeList类。</p><ol><li>具有 length 属性</li><li>按索引方式存储数据</li><li>不具有数组的 push、pop等方法</li></ol><p>伪数组—&gt; 真数组</p><ol><li>Array.from()    es6</li><li>[].slice.call(eleArr) 或者  Array.prototype.slice.call(eleArr)</li></ol><h5 id="14-JavaScript中的作用域、预解析与变量声明提升？"><a href="#14-JavaScript中的作用域、预解析与变量声明提升？" class="headerlink" title="14.JavaScript中的作用域、预解析与变量声明提升？"></a>14.JavaScript中的作用域、预解析与变量声明提升？</h5><p><strong>作用域</strong></p><p>就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域</p><ol><li>全局作用域：最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的；</li><li>局部作用域：局部作用域一般只在固定的代码片段内可访问到，函数外部是无法访问的，常见函数内部。</li><li>块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域</li></ol><p>块级作用域 函数作用域 词法作用域之间的区别？</p><ol><li>块级作用域和函数作用域描述的是， 什么东西可以划分变量的作用域</li><li>词法作用域描述的是，变量的查找规则</li></ol><p><strong>预解析</strong></p><p>Js 代码的执行是由浏览器中的 Js 解析器来执行的。Js 解析器执行 js代码的时候，分为两个过程：<strong>预解析过程</strong>和代<strong>码执行过程</strong>。</p><p>预解析过程：</p><p>1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值</p><p>2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用</p><p>3.先提升 function，在提升 var</p><p><strong>变量提升</strong></p><p>变量提升：定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升</p><p>函数提升：Js 解析器首先会把当前作用域的函数声明提前到整个作用域的最前面</p><p>变量声明提升：</p><p>使用 var 关键字定义的变量，被称为变量声明；</p><p>函数声明提升的特点是，在函数声明的前面，可以调用这个函数</p><h5 id="15-变量提升与函数提升的区别？"><a href="#15-变量提升与函数提升的区别？" class="headerlink" title="15.变量提升与函数提升的区别？"></a>15.变量提升与函数提升的区别？</h5><p><strong>变量提升</strong></p><p>在 js 代码执行前引擎会先进行预编译，预编译期间会将变量声明与函 数声明提升至其对应作用域的最顶端，函数内声明的变量只会提升至该函数作用域最顶层</p><p>当函数内部定义的一个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 预编译后的代码结构可以看做如下运行顺序</span></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">// 将变量 a 的声明提升至最顶端， 赋值逻辑不提升。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">3</span>; <span class="comment">// 代码执行到原位置即执行原赋值逻辑</span></span><br></pre></td></tr></table></figure><p><strong>函数提升</strong></p><p>函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升</p><p>函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上。</p><h5 id="16-什么是作用域链？"><a href="#16-什么是作用域链？" class="headerlink" title="16.什么是作用域链？"></a>16.什么是作用域链？</h5><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链</p><p>由子级作用域链返回父级作用域中寻找变量，就叫做作用域链</p><p>作用域的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自下一个包含环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><h5 id="17-如何延长作用域链？"><a href="#17-如何延长作用域链？" class="headerlink" title="17.如何延长作用域链？"></a>17.如何延长作用域链？</h5><ol><li>try-catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对对象的声明。</li><li>wih 语句。with 语句会将指定的对象添加到作用域链中。</li></ol><h5 id="18-判断一个值是什么类型有哪些方法"><a href="#18-判断一个值是什么类型有哪些方法" class="headerlink" title="18.判断一个值是什么类型有哪些方法?"></a>18.判断一个值是什么类型有哪些方法?</h5><ol><li><p>typeof 运算符</p></li><li><p>instanceof 运算符</p></li><li><p>Object.prototype.toString 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> 只能区分基本类型 即 <span class="title class_">Number</span>、<span class="title class_">String</span>、<span class="literal">undefined</span>、<span class="title class_">Boolean</span>、<span class="title class_">Object</span>、<span class="title class_">Function</span>、<span class="title class_">Symbol</span>（es6新增的 七种）</span><br><span class="line"></span><br><span class="line">对于数组、<span class="literal">null</span>、对象来说，使用 <span class="keyword">typeof</span> 都会统一返回  object,  要使用 <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> 来判断某个对象值属于那种内置类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//直接对一个数组调用 toString()</span></span><br><span class="line">arr.<span class="title function_">toString</span>();<span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="comment">//通过 call 指定 arr 数组为 Object.prototype 对象中的 toString 方法的上下文</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="WebAPI"><a href="#WebAPI" class="headerlink" title="WebAPI"></a>WebAPI</h4><h5 id="6-event对象的常见应用？"><a href="#6-event对象的常见应用？" class="headerlink" title="6.event对象的常见应用？"></a>6.event对象的常见应用？</h5><ol><li>e.preventDefault() ; 阻止默认行为，阻止a链接默认的跳转行为</li><li>e.stopPropagation() ; 阻止冒泡</li><li>e.target</li></ol><h5 id="8-事件三要素"><a href="#8-事件三要素" class="headerlink" title="8.事件三要素"></a>8.事件三要素</h5><ol><li>事件源</li><li>事件类型</li><li>事件处理函数</li></ol><h5 id="9-事件执行过程"><a href="#9-事件执行过程" class="headerlink" title="9.事件执行过程"></a>9.事件执行过程</h5><p>事件捕获过程：当我们点击 TEXT 时，首先是 window -&gt; document -&gt; body -&gt; div -&gt; text. 这个过程称为事件捕获，W3C浏览器的标准执行流程。</p><p>事件冒泡过程：text -&gt; div -&gt; body -&gt; document -&gt; window. 这个过程称为事件冒泡。ie浏览器只支持冒泡，不支持捕获。W3C浏览器先执行捕获，后执行冒泡。</p><h5 id="10-谈谈事件委托的理解？"><a href="#10-谈谈事件委托的理解？" class="headerlink" title="10.谈谈事件委托的理解？"></a>10.谈谈事件委托的理解？</h5><p>js事件代理则是一种简单的技巧，把事件处理器添加到一个上级元素上，这样就避免了把事件处理器添加到多个子级元素上。这主要得益于浏览器的事件冒泡机制。</p><p>优点：</p><ol><li>减少事件注册，节省内存。</li><li>在table上代理所有的td的click事件。</li><li>在ul上代理所有 li 的 click 事件。</li><li>简化了 dom 节点更新时，相应事件的更新。</li><li>不用在新添加的 li 上绑定 click 事件。</li><li>当删除某个 li 时，不用解绑上面的 click 事件。</li></ol><p>缺点：</p><ol><li>事件委托基于冒泡，对于不冒泡的事件不支持。</li><li>层级过多，冒泡过程中，可能会被某层阻止掉。</li><li>理论上委托会导致浏览器频繁调用处理函数，虽然可能不需要处理。所以建议就近委托。</li><li>把所有事件都用代理就可能会出现事件误判。</li></ol><h5 id="11-JavaScript-中定时器有哪些？区别及用法是什么？"><a href="#11-JavaScript-中定时器有哪些？区别及用法是什么？" class="headerlink" title="11.JavaScript 中定时器有哪些？区别及用法是什么？"></a>11.JavaScript 中定时器有哪些？区别及用法是什么？</h5><ol><li>setTimeout( )  ：方法用于在指定的毫秒数后调用函数或计算表达式。也叫定时器。</li><li>setInterval( ) ：方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。也叫计时器。</li></ol><p>setInterval() 方法会不停的调用函数，直到 clearInterval() 被调用或窗口被关闭。由setInterval()返回的ID值可用作 clearInterval() 方法的参数。</p><h5 id="13-JS拖动的原理？"><a href="#13-JS拖动的原理？" class="headerlink" title="13.JS拖动的原理？"></a>13.JS拖动的原理？</h5><p>js的拖拽效果主要用到以下三个事件：</p><p>mousedown 鼠标按下事件</p><p>mousemove 鼠标移动事件</p><p>mouseup 鼠标抬起事件</p><p>当点击dom的时候，记录当前鼠标的坐标值，也就是x，值，以及被拖拽的dom的top、left值，而且还要在鼠标按下的回调函数回调函数里添加鼠标移动的事件 mousemove 和添加鼠标抬起的事件 mouseup</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot; mousemove&quot;</span>, moving, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot; mouseup&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot; mousemove&quot;</span>, moving, <span class="literal">false</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这个抬起的事件是为了解除鼠标移动的监听，因为只有在鼠标按下才可以拖拽，抬起就不会移动了。</p><p>当鼠标按下鼠标移动的时候，记录移动中的 x,y值，那么这个被拖拽的dom的top、left值就是：</p><p>top &#x3D; 鼠标按下时记录的dom的 top 值 + （移动中的 y 值 - 鼠标按下时的 y 值）</p><p>left &#x3D; 鼠标按下时记录的 left 值 + （移动中的 x 值 - 鼠标按下时的 x 值）</p><h5 id="14-简述浏览器的渲染过程，DOM树和渲染树的区别？"><a href="#14-简述浏览器的渲染过程，DOM树和渲染树的区别？" class="headerlink" title="14.简述浏览器的渲染过程，DOM树和渲染树的区别？"></a>14.简述浏览器的渲染过程，DOM树和渲染树的区别？</h5><ol><li>浏览器的渲染过程：<ol><li>解析 HTML 构建DOM（DOM树），并行请求 css&#x2F;image&#x2F;js</li><li>CSS文件下载完成，开始构建 css树</li><li>css树构建结束后， 和 DOM一起生成 Render Tree（渲染树）</li><li>布局：计算出每个节点在屏幕中的位置</li><li>显示：通过显卡把页面画到屏幕上</li></ol></li><li>DOM树和渲染树的区别：<ol><li>DOM树与 HTML 标签一一对应，包括head和隐藏元素</li><li>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</li></ol></li></ol><h5 id="15-如何最小化重绘和回流？"><a href="#15-如何最小化重绘和回流？" class="headerlink" title="15.如何最小化重绘和回流？"></a>15.如何最小化重绘和回流？</h5><p>重绘：当元素的一部分属性发生改变，如外观、背景、颜色等不会引起布局变化，只需要浏览器根据元素的新属性重新绘制，使元素呈现新的外观叫做重绘。</p><p>重排（回流）：当render树中的一部分或者全部因为大小边距等问题发生改变而需要DOM树重新计算的过程</p><p><strong>重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</strong></p><p>方法：</p><ol><li><p>需要对元素进行复杂的操作时，可以先隐藏（display：none），操作完成后再显示</p></li><li><p>需要创建多个DOM节点时，使用 DocumentFragment创建完后一次性加入document缓存Layout属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> left = elem.<span class="property">offsetLeft</span>;    <span class="comment">// 这样，多次使用left只产生一次回流</span></span><br></pre></td></tr></table></figure></li><li><p>尽量避免用table布局（会引起回流）</p></li><li><p>避免使用css表达式，因为每次调用都会重新计算值（包括加载页面）</p></li><li><p>尽量使用 css 属性简写</p></li><li><p>批量修改元素样式</p></li></ol><h5 id="16-JS延迟加载的方式有哪些？"><a href="#16-JS延迟加载的方式有哪些？" class="headerlink" title="16.JS延迟加载的方式有哪些？"></a>16.JS延迟加载的方式有哪些？</h5><ol><li><p><strong>defer</strong> 属性</p><p>用途：表明脚本在执行时不会影响页面的构造。脚本会被延迟到整个页面都解析完毕之后再执行</p><p>在 script 元素中设置 defer 属性，等同告诉浏览器立即下载，但延迟执行!</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;text1.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;text2.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：虽然 script 元素放在了 head 元素中，但包含的脚本将延迟浏览器遇到 &#x2F;html 标签后执行</p><p>延迟脚本并不一定会按照顺序执行  defer 属性只适用于外部脚本</p></li><li><p><strong>async</strong> 属性</p><p>html5为 script 标签定义了 async 属性，用于改变处理脚本的行为。 只适用于外部脚本文件。</p><p>目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容。异步脚本一定会在页面load事件前执行。不能保证脚本会按顺序执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;text1.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;text2.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>async和defer一样，都不会阻塞其他资源下载，所有不会影响页面的加载。</p><p>缺点：不能控制加载的顺序。</p></li><li><p>动态创建 DOM 方式</p></li><li><p>使用 jQuery的getScript（）方法</p></li><li><p>使用 setTimeout 延迟方法的加载时间 延迟加载js代码，给网页加载留出更多时间</p></li><li><p>让js最后加载</p></li></ol><h4 id="JavaScript-高级"><a href="#JavaScript-高级" class="headerlink" title="JavaScript 高级"></a>JavaScript 高级</h4><h5 id="1-typeof-和-instanceof-区别？"><a href="#1-typeof-和-instanceof-区别？" class="headerlink" title="1.typeof 和 instanceof 区别？"></a>1.typeof 和 instanceof 区别？</h5><p>在js中，判断一个变量的类型可以用 typeof</p><ol><li>数字类型，typeof 返回的值是number</li><li>字符串类型，typeof 返回的值是 string</li><li>布尔类型，typeof 返回的值是 boolean</li><li>对象、数组、null 返回的值是 object</li><li>不存在的变量、函数或者undefined，将返回 undefined</li><li>使用 typeod 运算符无论引用的是什么类型的对象，它都返回 object</li><li>运算符 instanceof 来解决这个问题。用于判断某个对象是否被另一个函数构造</li></ol><h5 id="2-js使用typeof能得到的哪些类型？"><a href="#2-js使用typeof能得到的哪些类型？" class="headerlink" title="2.js使用typeof能得到的哪些类型？"></a>2.js使用typeof能得到的哪些类型？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeof只能区分值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>       <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// function</span></span><br><span class="line">typ]eof <span class="title class_">NaN</span>       <span class="comment">// number</span></span><br></pre></td></tr></table></figure><h5 id="4-什么是闭包？"><a href="#4-什么是闭包？" class="headerlink" title="4.什么是闭包？"></a>4.什么是闭包？</h5><p><strong>定义：</strong></p><p> 一个作用域可以访问到另外一个函数内部的局部变量，或者说一个函数（子函数）访问另一个函数（父函数）中的变量。此时就会产生闭包，那么这个变量所在的函数我们就称之为闭包函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(a++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fun = <span class="title function_">aaa</span>()</span><br><span class="line"><span class="title function_">fun</span>()              <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>优缺点：</strong></p><p>闭包的主要作用：延伸了变量的作用范围，因为闭包函数中的局变量不会等着闭包函数执行完就销毁，因为还有别的函数要调用它，只有等着所有的函数都调用完了它才会销毁。</p><p>闭包会造成内存泄露，如何解决：用完之后手动是释放。</p><p><strong>详解：</strong></p><p>闭包不仅仅可以实现函数内部的作用域访问这个函数中的局部变量，还可以实现全局作用域或者别的地方的作用域也可以访问到函数内部的局部变量，实现方法就是 return 了一个函数。</p><p>所以 return 函数也是我们实现闭包的一个主要原理，因为返回的这个函数本身就是我们 fn 函数内部的一个子函数，所以子函数是可以访问父函数里面的局部变量的，所以返回完毕之后，外面的函数一调用，就会回头调用返回的这个函数，所以就可以拿到这个子函数对应的父函数里面的局部变量。</p><p><strong>注意：</strong></p><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗詪大，所以不能滥用闭包，否则会造成网页的性能问题。</li><li>闭包会在父函数外部，改变父函数内部变量的值。</li></ol><h5 id="5-什么是内存泄漏？"><a href="#5-什么是内存泄漏？" class="headerlink" title="5.什么是内存泄漏？"></a>5.什么是内存泄漏？</h5><p>内存泄漏也称为“ 存储泄漏 ”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。</p><p>其实说白了就是该内存空间使用完毕之后未回收，导致内存泄漏。</p><h5 id="6-哪些操作会造成内存泄漏？"><a href="#6-哪些操作会造成内存泄漏？" class="headerlink" title="6.哪些操作会造成内存泄漏？"></a>6.哪些操作会造成内存泄漏？</h5><ol><li>setTimeout 的第一个参数使用字符串而非函数的话，会造成内存泄漏。</li><li>闭包、控制台日志、循环</li><li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0，或对该对象的唯一引用是循环的，那么该对象的内存即可回收。</li></ol><h5 id="7-说说你对原型prototype的理解"><a href="#7-说说你对原型prototype的理解" class="headerlink" title="7.说说你对原型prototype的理解"></a>7.说说你对原型prototype的理解</h5><p>在js中，原型也是一个对象，通过原型可以实现对象的属性继承，JS的函数对象中都包含了一个 prototype 内部属性，这个属性所对应的就是该函数对象的原型。</p><p>prototype 作为函数对象的内部属性，是不能被直接访问的。</p><p>原型的主要作用就是实现继承与扩展对象。</p><h5 id="8-介绍下原型链？"><a href="#8-介绍下原型链？" class="headerlink" title="8.介绍下原型链？"></a>8.介绍下原型链？</h5><p>js原型：每个对象都会在其内部初始化一个属性，就是 prototype （原型）</p><p><strong>原型链：</strong></p><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的 <strong>_  _proto  _ _</strong></p><p>隐式原型上查找，即它的构造函数的<strong>prototype</strong>，如果还没有找到就会再在构造函数的prototype的**_  _proto  _ _**中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p><p>当我们修改原型时，与之相关的对象也会继承这一改变。</p><h5 id="9-常见的js中继承的方式？"><a href="#9-常见的js中继承的方式？" class="headerlink" title="9.常见的js中继承的方式？"></a>9.常见的js中继承的方式？</h5><ol><li>原型链继承</li><li>构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li><li>es6中class实现继承</li></ol><h5 id="10-介绍this各种情况"><a href="#10-介绍this各种情况" class="headerlink" title="10.介绍this各种情况"></a>10.介绍this各种情况</h5><ol><li>以函数形式调用时，this 永远都是 window</li><li>以方法的形式调用时，this 是调用方法的对象</li><li>以构造函数的形式调用时，this 是新创建的那个实例对象</li><li>使用 call 和 apply 调用时，this 是指定的那个对象</li><li>箭头函数：箭头函数的 this 看外层是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，就是window</li><li>特殊情况：通常意义上 this 指针指向为最后调用它的对象。这里需要注意的一点就是如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么this 还是指向函数的实例</li></ol><h5 id="11-forEach-和-map-的区别？"><a href="#11-forEach-和-map-的区别？" class="headerlink" title="11.forEach 和 map 的区别？"></a>11.forEach 和 map 的区别？</h5><p>相同点：都是循环遍历数组中的每一项。</p><p>forEach 和 map 方法里每次执行匿名函数都支持3个参数，参数分别是 item，index，arr（原数组）</p><p>匿名函数中的this都是指向window 只能遍历数组 都不会改变原数组</p><p>map方法：</p><ol><li>返回一个新数组，数组中的元素为原始数组调用函数处理后的值</li><li>map方法不会对空数组进行检测，map方法不会改变原始数</li></ol><p>forEach方法：</p><ol><li>foreach方法用来调用数组的每个元素，将元素传给回调函数</li><li>foreach对于空数组就不会调用回调函数的。</li></ol><h5 id="12-for-in-和-for-of-的区别？"><a href="#12-for-in-和-for-of-的区别？" class="headerlink" title="12.for in 和 for of 的区别？"></a>12.for in 和 for of 的区别？</h5><ol><li>推荐在循环对象属性的时候使用 for…in，在遍历数组的时候使用 for…of</li><li>for…in 循环的是 key，for…of 循环的是 value</li><li>注意，for…of 是ES6新引入的特性。修复了ES5引入的for…in 的不足</li><li>for…of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</li></ol><h5 id="13-call、apply、bind-的区别？"><a href="#13-call、apply、bind-的区别？" class="headerlink" title="13.call、apply、bind 的区别？"></a>13.call、apply、bind 的区别？</h5><p>共同点：</p><ol><li>都是用来改变函数的 this 对象的指向的。</li><li>第一个参数都是 this 要指向的对象。</li><li>都可以利用后续参数传参。</li></ol><p><strong>call</strong> 方法调用一个函数，其具有一个指定的 this 值分别地提供的参数（参数的列表）</p><p><strong>call</strong> 方法的作用和 <strong>apply（）</strong>方法类似区别就是 </p><p>call() 方法接受的是参数列表</p><p>apply（）方法接收的是一个参数数组。</p><p>bind（）方法创建一个新的函数，当这个新的函数被调用时，其 this 值为提供的值，其参数列表前几项，置为创建时指定的参数列表。</p><h5 id="14-EventLoop事件循环机制"><a href="#14-EventLoop事件循环机制" class="headerlink" title="14.EventLoop事件循环机制"></a>14.EventLoop事件循环机制</h5><p>JS的事件分两种，宏任务和微任务。</p><p>宏任务：包括整体代码script，setTimeout，setInterval</p><p>微任务：Promise.then(非 new Promise：同步的)，process，nextTick（node中 ）</p><p>事件的执行顺序——先执行宏任务，然后执行微任务，任务有同步的任务和异步的任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放在队列中，如果还有异步的宏任务，那么就会进行循环执行上述的操作。</p><h5 id="15-js-防抖和节流"><a href="#15-js-防抖和节流" class="headerlink" title="15.js 防抖和节流"></a>15.js 防抖和节流</h5><p>在进行窗口的 resize、scroll，输入框内容校验等操作时，如果事件处理函数的频率无限制，会加重浏览器的负担，导致用户的体验不好。此时可以使用防抖和节流来减少使用频率，同时又不影响实际结果。</p><p><strong>防抖（debounce）</strong>：</p><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p><p><strong>节流（throttle）</strong>：</p><p>当持续触发事件时，保证一定时间内只调用一次事件处理函数</p><p>比如持续触发scroll事件时，并不立即执行handle函数，每隔1000ms才会执行一次。就比如水龙头，最好是按照一定规律在某个时间间隔内一滴一滴的往下滴。</p><p>总结：</p><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在延迟时间后触发函数，但是在延迟时间内再次触发的话，机会取消之前的计时器而重新设置。只有最后一次操作能被触发。</p><p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别：</p><p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，</p><p>而函数防抖只是在最后一次事件后才触发一次函数。</p><p>应用场景：</p><p>防抖：</p><ol><li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li><li>window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖 来让其只触发一次</li></ol><p>节流：</p><ol><li>鼠标不断点击触发，mousedown （单位时间内只触发一次）</li><li>监听滚动事件，比如是否滑倒底部自动加载更多，用 throttle 来判断 ；</li></ol><h5 id="16-new-操作符具体干了什么呢？"><a href="#16-new-操作符具体干了什么呢？" class="headerlink" title="16.new 操作符具体干了什么呢？"></a>16.new 操作符具体干了什么呢？</h5><ol><li>创建一个空的对象，并且 this 变量引入该对象，同时还继承了函数的原型</li><li>设置原型链   空对象指向构造函数的原型对象</li><li>执行函数体   修改构造函数 this 指针指向空对象，并执行函数体</li><li>判断返回值   返回对象就用该对象，没有的话就创建一个对象</li></ol><h5 id="19-split-和-join-的区别？"><a href="#19-split-和-join-的区别？" class="headerlink" title="19.split( ) 和 join( ) 的区别？"></a>19.split( ) 和 join( ) 的区别？</h5><p>split（）是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里，即切割成数组的形式</p><p>join（） 是把数组中的字符串连成一个长串，可以大体上认为是 split（）的逆操作</p><h5 id="21-谈谈你对-JS-垃圾回收机制的理解？"><a href="#21-谈谈你对-JS-垃圾回收机制的理解？" class="headerlink" title="21.谈谈你对 JS 垃圾回收机制的理解？"></a>21.谈谈你对 JS 垃圾回收机制的理解？</h5><ol><li>标记清除法</li><li>引用计数法</li></ol><h5 id="22-JS-里垃圾回收机制是什么，常用的是哪种，怎么处理的？"><a href="#22-JS-里垃圾回收机制是什么，常用的是哪种，怎么处理的？" class="headerlink" title="22.JS 里垃圾回收机制是什么，常用的是哪种，怎么处理的？"></a>22.JS 里垃圾回收机制是什么，常用的是哪种，怎么处理的？</h5><p>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p><p>JS 最常见的垃圾回收方式是标记清除</p><p>工作原理：是当变量进入环境时，将这个变量标记为 “ 进入环境 ” 。 当变量离开环境的时候，则将其标记为 “ 离开环境  ” 。标记 离开环境 就回收内存。</p><p>工作流程：</p><ol><li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记</li><li>去掉环境中的变量以及破环环境中的变量引用的变量的标记</li><li>再被加上标记的会被视为准备删除的变量</li><li>垃圾回收器完成内存清除工作，销毁按那些带标记的值并回收他们所占用的内存空间</li></ol><h5 id="23-什么是任务队列？"><a href="#23-什么是任务队列？" class="headerlink" title="23.什么是任务队列？"></a>23.什么是任务队列？</h5><p>任务队列主要分两种：</p><ol><li><p>宏任务</p><p>script（整体代码）、setTimeout、setInterval、..</p></li><li><p>微任务</p><p>process.nextTick、Promise、</p></li></ol><p>同步任务：在主线程上，排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p><p>异步任务：不进入主线程，而进入“ 任务队列 ”的任务，只有 “ 任务队列 ” 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><h5 id="1-echarts-的基本用法？"><a href="#1-echarts-的基本用法？" class="headerlink" title="1.echarts 的基本用法？"></a>1.echarts 的基本用法？</h5><ol><li><p>初始化类</p><p>创建一个id为box的div，并初始化echarts 绘图实例   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myChat = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>样式配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title</span>: 标题</span><br><span class="line"><span class="attr">tooltip</span>: 鼠标悬停气泡</span><br><span class="line"><span class="attr">xAxis</span>: 配置横轴类别</span><br><span class="line"><span class="attr">series</span>: 销量数据，data 参数与横轴一一对应</span><br></pre></td></tr></table></figure></li><li><p>渲染图展示表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myChart.<span class="title function_">setOption</span>(option)</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-如何使用-echarts？"><a href="#2-如何使用-echarts？" class="headerlink" title="2.如何使用 echarts？"></a>2.如何使用 echarts？</h5><ol><li>获取 echarts ：在官网下载 echarts 版本 或 npm 下载</li><li>引入 echarts ：script 引入 或者 vue 在入口文件里引用</li><li>创建一个 dom 元素  用来放置图表</li><li>配置 echarts 属性</li></ol><h4 id="Ajax-计算机网络"><a href="#Ajax-计算机网络" class="headerlink" title="Ajax&#x2F;计算机网络"></a>Ajax&#x2F;计算机网络</h4><h5 id="1-什么是Ajax，Ajax的原理，Ajax都有哪些优点和缺点？"><a href="#1-什么是Ajax，Ajax的原理，Ajax都有哪些优点和缺点？" class="headerlink" title="1.什么是Ajax，Ajax的原理，Ajax都有哪些优点和缺点？"></a>1.什么是Ajax，Ajax的原理，Ajax都有哪些优点和缺点？</h5><p>什么是Ajax？</p><p>它是一种创建交互式网页应用的网页开技术。沟通客户端与服务器，可以在不必刷新整个浏览器的情况下，与服务器进行异步通讯的技术。</p><p>Ajax的原理？</p><p>通过xhr对象来向服务器发送异步请求，从服务器获得数据。xhr是Ajax的核心机制。简单的说，也就是js可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p><p>Ajax的优点？</p><ol><li>最大的一点是页面无刷新，用户体验非常好</li><li>使用异步方式与服务器通信，具有更加迅速的响应能力</li><li>Ajax的原则是 “ 按需取数据 ” ，可以最大层度上减少冗余请求，和响应服务器造成的负担</li></ol><h5 id="2-常见的-HTTP-状态码以及代表的意义？"><a href="#2-常见的-HTTP-状态码以及代表的意义？" class="headerlink" title="2.常见的 HTTP 状态码以及代表的意义？"></a>2.常见的 HTTP 状态码以及代表的意义？</h5><p>200（OK）：请求已成功，请求所希望的响应头或数据体将随此响应返回。</p><p>400：请求格式错误</p><p>404：请求失败，请求所希望得到的资源未在服务器上发现</p><p>500：服务器遇到了一个未曾预料的抓状况，导致了它无法完成对i请求的处理</p><p>401：未认证，没有网站登录</p><h5 id="3-Ajax的实现流程"><a href="#3-Ajax的实现流程" class="headerlink" title="3.Ajax的实现流程"></a>3.Ajax的实现流程</h5><ol><li>创建xhr对象，也就是创建一个异步调用对象</li><li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息</li><li>设置响应HTTP请求状态变化的函数</li><li>发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用 js 和 dom 实现局部刷新</li></ol><h5 id="4-Ajax接收到的数据类型有哪些，数据如何处理？"><a href="#4-Ajax接收到的数据类型有哪些，数据如何处理？" class="headerlink" title="4.Ajax接收到的数据类型有哪些，数据如何处理？"></a>4.Ajax接收到的数据类型有哪些，数据如何处理？</h5><p>String &#x2F; JSON字符串 &#x2F; 二进制流数据</p><p>JSON字符串反序列化后，转成引用类型使用</p><p>String 直接使用</p><p>前端用Blob转换</p><p><strong>如何处理数据？</strong></p><p>字符串转对象   <strong>JSON.parse（）</strong>  json格式的data数据转换成对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data =<span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">     &quot;student&quot; : [</span></span><br><span class="line"><span class="string">          &#123;&quot;name&quot;:&quot; 张 三 &quot;,&quot;age&quot;:&quot;11&quot;&#125;,</span></span><br><span class="line"><span class="string">          &#123;&quot;name&quot;:&quot; 李 四&quot;,&quot;age&quot;:&quot;11&quot;&#125;,</span></span><br><span class="line"><span class="string">          &#123;&quot;name&quot;:&quot; 王 五&quot;,&quot;age&quot;:&quot;11&quot;&#125;]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)</span><br></pre></td></tr></table></figure><h5 id="5-请解释一下js的同源策略"><a href="#5-请解释一下js的同源策略" class="headerlink" title="5.请解释一下js的同源策略"></a>5.请解释一下js的同源策略</h5><p>同源策略是客户端脚本的重要的安全度量标准。目的是防止某个文档或脚本从多个不同源装载。</p><p>同源是指：协议、域名、端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h5 id="6-为什么会有跨域的问题出现，如何解决跨域问题？"><a href="#6-为什么会有跨域的问题出现，如何解决跨域问题？" class="headerlink" title="6.为什么会有跨域的问题出现，如何解决跨域问题？"></a>6.为什么会有跨域的问题出现，如何解决跨域问题？</h5><p><strong>什么是跨域？</strong></p><p>指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，是浏览器对js施加的安全限制，防止他人恶意攻击网站。</p><p><strong>解决跨域</strong></p><ol><li><p>jsonp：动态创建一个 script 标签，利用script标签的 src 属性不受同源策略限制。</p></li><li><p>CORS：跨域资源共享</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cors原理：服务器设置 <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">OriginHTTP</span> 响应头之后，浏览器将会允许跨域请求</span><br><span class="line">限制：浏览器需要支持 <span class="title class_">HTML5</span>，可以支持 <span class="variable constant_">POST</span>、<span class="variable constant_">PUT</span> 等方法兼容ie9以上需要后台设置</span><br><span class="line"></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *    <span class="comment">// 允许所有域名访问</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">HTTP</span>:<span class="comment">//a.com   // 只允许所有域名访问</span></span><br></pre></td></tr></table></figure></li><li><p>反向代理</p></li><li><p>window + iframe</p></li></ol><h5 id="7-Get-和-Post-的区别以及使用场景"><a href="#7-Get-和-Post-的区别以及使用场景" class="headerlink" title="7.Get 和 Post 的区别以及使用场景"></a>7.Get 和 Post 的区别以及使用场景</h5><p>区别：</p><ol><li>Get 使用 url 或 Cookie 传参。而 Post 将数据放在body中</li><li>Get 的 url 会有长度上的限制，而 Post 的数据则可以非常大</li><li>Post 比 Get 更安全，因为数据在地址栏上不可见</li></ol><p>最本质的区别：基于http协议进行请求的，其实get和post无区别，只是请求的方式不同，都可以携带请求体，也可以在 url 带参数。</p><p>使用场景：</p><ol><li>使用post<ol><li>请求的结果有持续性的作用，例如 数据库内添加新的数据行</li><li>若使用 get 方法，则表单上收集的数据可能让url过长</li><li>要传送的数据不是采用 ASCII 编码</li></ol></li><li>使用get<ol><li>请求是为了查找资源，html表单数据仅用来搜索</li><li>请求结果无持续性的副作用</li><li>收集的数据及html表单内的输入字段名称的总长度不超过1024个字符</li></ol></li></ol><h5 id="8-解释-jsonp-的原理"><a href="#8-解释-jsonp-的原理" class="headerlink" title="8.解释 jsonp 的原理"></a>8.解释 jsonp 的原理</h5><p>什么是jsonp，jsonp的作用？</p><p>jsonp并不是一种数据格式，而 json 是一种数据格式， jsonp 是用来解决跨域获取数据的一种解决方案。</p><p><strong>具体原理</strong></p><p>是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax 技术，Ajax 请求受同源策略的影响，不允许进行跨域请求， 而 script 标签的 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不在返回 json 格式的数据，而是返回调用某个函数的 js 代码，在 src 中进行了调用，这样就实现了跨域。</p><h5 id="9-封装好的-Ajax-里的常见参数及其代表的含义"><a href="#9-封装好的-Ajax-里的常见参数及其代表的含义" class="headerlink" title="9.封装好的 Ajax 里的常见参数及其代表的含义"></a>9.封装好的 Ajax 里的常见参数及其代表的含义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url：发送请求的地址</span><br><span class="line">type：请求方式，默认为get</span><br><span class="line">async：同步异步请求，默认true 所有请求均为异步请求</span><br><span class="line">timeout：超时时间设置，单位毫秒</span><br><span class="line">data：要求为 Object 或 String 类型的参数，发送到服务器的数据</span><br><span class="line">cache：默认为true，设置为false将不会从浏览器缓存中加载请求信息</span><br><span class="line">dataType：预期服务器返回的数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="10-HTTP-与-HTTPS-的区别？"><a href="#10-HTTP-与-HTTPS-的区别？" class="headerlink" title="10.HTTP 与 HTTPS 的区别？"></a>10.HTTP 与 HTTPS 的区别？</h5><ol><li>https 协议需要到CA申请证书，一般免费证书较少，因而需要一定的费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ， 后者是 443</li><li>http 的连接很简单，是无状态的。https 协议是由 sll + http 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li></ol><h5 id="11-localStorage、sessionStorage、cookie-的区别？"><a href="#11-localStorage、sessionStorage、cookie-的区别？" class="headerlink" title="11.localStorage、sessionStorage、cookie 的区别？"></a>11.localStorage、sessionStorage、cookie 的区别？</h5><p>共同点：都是保存在浏览器、且同源的</p><p>区别：</p><ol><li>cookie 数据始终在同源的 http 请求中携带，即使不需要，即cookie在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径path的概念，可以限制cookie只属于某个路径下。</li><li>存储大小限制也不同，cookie 数据不能超过4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</li><li>数据有效期不同<ol><li>sessionStorage：仅在当前浏览器窗口关闭之前有效</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据</li><li>cookie：只设置在 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭</li></ol></li><li>作用域不同<ol><li>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面</li><li>localStorage：在所有同源窗口中都是共享的</li><li>cookie：在所有同源中都是共享的</li></ol></li><li>web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者</li><li>web Storage 的 api 接口使用更方便</li></ol><h5 id="12-一个页面从输入-url-到页面加载显示完成，这个过程都发生了什么？"><a href="#12-一个页面从输入-url-到页面加载显示完成，这个过程都发生了什么？" class="headerlink" title="12.一个页面从输入 url 到页面加载显示完成，这个过程都发生了什么？"></a>12.一个页面从输入 url 到页面加载显示完成，这个过程都发生了什么？</h5><ol><li>浏览器查找域名对应的 IP 地址</li><li>浏览器向 web 服务器发送一个 http 请求 （TCP 三次握手）</li><li>服务器 301 重定向</li><li>浏览器跟踪重定向地址，请求另一个带www的网址</li><li>服务器处理请求（通过路由读取资源）</li><li>服务器返回一个 http 响应</li><li>浏览器进行 DOM 树构建</li><li>浏览器发送请求获取嵌在 html 中的资源</li><li>浏览器显示完成页面</li><li>浏览器发送异步请求</li></ol><h5 id="13-介绍一下websocket"><a href="#13-介绍一下websocket" class="headerlink" title="13.介绍一下websocket"></a>13.介绍一下websocket</h5><p>websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议，这个对比 http 协议来说， http 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。http 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接，就可以一直保持连接状态</p><h5 id="1-module、export、import-有什么作用"><a href="#1-module、export、import-有什么作用" class="headerlink" title="1.module、export、import 有什么作用"></a>1.<strong>module、export、import 有什么作用</strong></h5><p>module、export、import 是 ES6 用来统一前端模块化方案的设计思路和实现方案。</p><p>export、import 的出现统一了前端模块化的实现方案， 整合规范了浏览器&#x2F;服务端的模块化的方法，用来取代传统的 AMD&#x2F;CMD、requireJS、seaJS、commondJS 等等一系列前端模块不同的实现方案，使前端模块化更加统一规范， JS 也能更加能实现大型的应用程序开发。</p><p>import 引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</p><p>import 引入 export 导出的接口值是动态绑定关系， 即通过该接口， 可以取到模块内部实时的值</p><h5 id="2、使用箭头函数应注意什么-箭头函数和普通函数的区别"><a href="#2、使用箭头函数应注意什么-箭头函数和普通函数的区别" class="headerlink" title="2、使用箭头函数应注意什么&#x2F;箭头函数和普通函数的区别"></a><strong>2、使用箭头函数应注意什么&#x2F;箭头函数和普通函数的区别</strong></h5><p><strong>区别</strong></p><p>用了箭头函数， this 就不是指向 window，而是父级（指向是可变的）</p><p>不能够使用 arguments 对象</p><p>不能用作构造函数，这就是说不能够使用 new 命令，否则会抛出一个错误</p><p>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</p><h5 id="3、介绍下-Set、Map-的区别"><a href="#3、介绍下-Set、Map-的区别" class="headerlink" title="3、介绍下 Set、Map 的区别"></a><strong>3、介绍下 Set、Map 的区别</strong></h5><p><strong>区别</strong></p><p>应用场景 Set 用于数据重组，Map 用于数据储存</p><p>Set：</p><p>成员不能重复</p><p>只有键值没有键名，类似数组</p><p>可以遍历，方法有 add, delete,has</p><p>Map:</p><p>本质上是健值对的集合，类似集合</p><p>可以遍历，可以跟各种数据格式转换</p><h5 id="4、setTimeout、Promise、Async-Await-的区别（必会）"><a href="#4、setTimeout、Promise、Async-Await-的区别（必会）" class="headerlink" title="4、setTimeout、Promise、Async&#x2F;Await 的区别（必会）"></a><strong>4、setTimeout、Promise、Async&#x2F;Await 的区别（必会）</strong></h5><p><strong>事件循环中分为宏任务队列和微任务队列</strong></p><p>宏任务（macrotask）：在新标准中叫 task</p><p>主要包括：script(整体代码)，setTimeout，setInterval，setImmediate，I&#x2F;O，ui rendering</p><p>微任务（microtask）：在新标准中叫 jobs </p><p>主要包括：process.nextTick， Promise，MutationObserver（html5 新特性）</p><p><strong>setTimeout、Promise、Async&#x2F;Await 的区别</strong></p><p>setTimeout 的回调函数放到宏任务队列里， 等到执行栈清空以后执行</p><p>Promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码</p><p>执 行完再执行async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式</p><p>async 方法执行时， 遇到 await 会立即执行表达式， 然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行</p><h5 id="5、Promise-有几种状态，什么时候会进入-catch？"><a href="#5、Promise-有几种状态，什么时候会进入-catch？" class="headerlink" title="5、Promise 有几种状态，什么时候会进入 catch？"></a><strong>5、Promise 有几种状态，什么时候会进入 catch？</strong></h5><p><strong>Promise 有几种状态</strong></p><p>三个状态：pending、fulfilled、reject</p><p>两个过程：padding -&gt; fulfilled、padding -&gt; rejected</p><p><strong>Promise 什么时候会进入 catch</strong></p><p>当 pending 为 rejected 时，会进入 catch</p><h5 id="6、理解-async-await-以及相对-Generator-的优势"><a href="#6、理解-async-await-以及相对-Generator-的优势" class="headerlink" title="6、理解 async&#x2F;await 以及相对 Generator 的优势"></a><strong>6、理解 async&#x2F;await 以及相对 Generator 的优势</strong></h5><p><strong>理解 async await</strong></p><p>async await 是用来解决异步的， async 函数是 Generator 函数的语法糖</p><p>使用关键字 async 来表示，在函数内部使用 await 来表示异步</p><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</p><p>当函数执行的时候， 一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p><h5 id="1、对-Node-js-有没有了解，-它有什么特点，-适合做什么业务"><a href="#1、对-Node-js-有没有了解，-它有什么特点，-适合做什么业务" class="headerlink" title="1、对 Node.js 有没有了解， 它有什么特点， 适合做什么业务"></a><strong>1、对 Node.js 有没有了解， 它有什么特点， 适合做什么业务</strong></h5><p><strong>什么是 Node</strong></p><p>Node.js…它既是开发平台, 也是运行环境, 也是个新的语言…它本身是基于 google 的</p><p>javascript v8 引擎开发的, 因此在编写基于它的代码的时候使用 javascript 语言. 但是</p><p>又不同于传统概念的 javascript…它的服务端功能以及部分客户端功能必须在服务端运行, </p><p>所以它实际上是一种在服务端的开发+运行的 javascript 语言. 它本身可以作为 HTTP Server, </p><p>也可 以当作 TCP Server 用</p><p><strong>特点</strong></p><p>他是一个 javascript 运行环境，依赖于 Chrome V8 引擎进行代码解释</p><p>特征：单线程、事件驱动、非阻塞 I&#x2F;O，轻量， 可伸缩，适于实时数据交互应用</p><p>单进程， 单线程 (一个应用程序对应一个进程, 一个进程下面会有多个线程, 每个线程用</p><p>于 </p><p>处理任务..)</p><p>Node 无法直接渲染静态页面，提供静态服务</p><p>Node 没有根目录的概念</p><p>Node 必须通过路由程序指定文件才能渲染文件</p><p>Node 比其他服务端性能更好，速度更快</p><p><strong>适用业务</strong></p><p>Node.js 是单线程， 非阻塞 I&#x2F;O，事件驱动， 它的特点决定了它适合做一些大量 I&#x2F;O 的东西，</p><p>比如， 聊天室，表单提交等不需要大量计算的功能。做一些微信后端开发， 或者做消息系统</p><p>等。可以整个项目用，也可以根据它的特点在某个模块使用， 比如 socketio，打造一个消息</p><p>系统等</p><h5 id="2、Node-的优点是什么？-缺点是什么（必会）"><a href="#2、Node-的优点是什么？-缺点是什么（必会）" class="headerlink" title="2、Node 的优点是什么？ 缺点是什么（必会）"></a><strong>2、Node 的优点是什么？ 缺点是什么（必会）</strong></h5><p><strong>优点</strong></p><p>1、高并发（最主要的一个优点）</p><p>2、适合 I&#x2F;O 密集型应用</p><p><strong>缺点</strong></p><p>1、不适合 CPU 密集型应用； CPU 密集型应用给 node 带来的挑战主要是： 由于 JavaScript 单</p><p>线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使</p><p>得后续 I&#x2F;O 无法发起；</p><p>解决方案： 分解大型运算任务为多个小任务， 使得运算能够适时释放，不阻塞 I&#x2F;O 调用的发</p><p>起；</p><p>2、只支持单核 CPU，不能充分利用 CPU</p><p>3、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</p><p><strong>原因：</strong> 单进程，单线程</p><p><strong>解决方案</strong></p><p>3.1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口</p><p>3.2）开多个进程监听同一个端口， 使用 cluster 模块</p><p>4、开源组件库质量参差不齐，更新快，向下不兼容</p><p>5、Debug 不方便，错误没有 stack trace </p><h5 id="3、为什么要进行模块化（高薪常问）"><a href="#3、为什么要进行模块化（高薪常问）" class="headerlink" title="3、为什么要进行模块化（高薪常问）"></a><strong>3、为什么要进行模块化（高薪常问）</strong></h5><p>目前前端的开发形势就是模块化和组件化；从软件工程学分析来说就是有了更好的可维护</p><p>性、可复用性等好处； 但是前端的主要语言 js 在 ES6</p><p>之前却没有模块化功能，之前有使用 require.js 和 sea.js 但是推出 ES6 的模块化之后，</p><p>ES6 的模块化使用形式基本统一</p><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a><strong>Webpack</strong></h4><h5 id="1、什么是-Webpack（必会）"><a href="#1、什么是-Webpack（必会）" class="headerlink" title="1、什么是 Webpack（必会）"></a><strong>1、什么是 Webpack（必会）</strong></h5><p>1、基本定义</p><p>Webpack 是一个打包模块化 javascript 的工具，在 Webpack 里一切文件皆模块，通过</p><p>loader 转换文件， 通过 plugin 注入钩子， 最后输出由多个模块组合成的文件，Webpack 专注构</p><p>建模块化项目， Webpack 可以看做是模块打包机： 它做的事情是，分析你的项目结构，找到</p><p>JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将</p><p>其打包为合适的格式以供浏览器使用</p><h5 id="2、Webpack-的优点是什么？（必会）"><a href="#2、Webpack-的优点是什么？（必会）" class="headerlink" title="2、Webpack 的优点是什么？（必会）"></a><strong>2、Webpack 的优点是什么？（必会）</strong></h5><p>1、专注于处理模块化的项目，能做到开箱即用， 一步到位</p><p>2、通过 plugin 扩展，完整好用又不失灵活</p><p>3、使用场景不局限于 web 开发</p><p>4、社区庞大活跃，经常引入紧跟时代发展的新特性， 能为大多数场景找到已有的开源扩展</p><p>5、提供了更好的开发体验</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股文</title>
      <link href="/posts/3929.html"/>
      <url>/posts/3929.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="1-2-h5新特性"><a href="#1-2-h5新特性" class="headerlink" title="1.2 h5新特性"></a>1.2 h5新特性</h2><ul><li>新增选择器 document.querySelector、document.querySelectorAll</li><li>拖拽释放(Drag and drop) API</li><li>媒体播放的 video 和 audio</li><li>本地存储 localStorage 和 sessionStorage</li><li>离线应用 manifest</li><li>桌面通知 Notififications</li><li>语意化标签 article、footer、header、nav、section</li><li>增强表单控件 calendar、date、time、email、url、search</li><li>地理位置 Geolocation</li><li>多任务 webworker</li><li>全双工通信协议 websocket</li><li>历史管理 history</li><li>跨域资源共享(CORS) Access-Control-Allow-Origin</li><li>页面可见性改变事件 visibilitychange</li><li>跨窗口通信 PostMessage</li><li>Form Data 对象</li><li>绘画 canvas</li></ul><h2 id="1-3-伪类和伪元素"><a href="#1-3-伪类和伪元素" class="headerlink" title="1.3 伪类和伪元素"></a>1.3 伪类和伪元素</h2><p>伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的;:hover</p><p>伪元素：用于创建一些不在DOM树中的元素，并为其添加样式 ;例如，我们可以通过  :before  :after</p><p><strong>语义化优点</strong></p><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重</li><li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐</li></ul><h2 id="1-5-引入样式时，link和-import的区别？"><a href="#1-5-引入样式时，link和-import的区别？" class="headerlink" title="1.5 引入样式时，link和@import的区别？"></a>1.5 引入样式时，link和@import的区别？</h2><ul><li>链接样式时，link只能在HTML页面中引入外部样式</li><li>导入样式表时，@import 既可以在HTML页面中导入外部样式，也可以在css样式文件中导入外部css样式</li></ul><h2 id="1-10-元素的alt和title有什么不同？"><a href="#1-10-元素的alt和title有什么不同？" class="headerlink" title="1.10 元素的alt和title有什么不同？"></a>1.10 元素的alt和title有什么不同？</h2><ul><li>在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字</li></ul><h2 id="1-15-a标签中-如何禁用href-跳转页面-或-定位链接"><a href="#1-15-a标签中-如何禁用href-跳转页面-或-定位链接" class="headerlink" title="1.15 a标签中 如何禁用href 跳转页面 或 定位链接?"></a>1.15 a标签中 如何禁用href 跳转页面 或 定位链接?</h2><p>e.preventDefault();</p><p>href&#x3D;”javascript:void(0);</p><h2 id="1-19-前端需要注意哪些SEO"><a href="#1-19-前端需要注意哪些SEO" class="headerlink" title="1.19 前端需要注意哪些SEO"></a>1.19 前端需要注意哪些SEO</h2><p>1、合理的title、description、keywords：搜素时对这三项的权重逐个减少，title强调重点，重要关键词不要超过两次，而且要靠前，不同页面title要有所不同，description高度概括页面内容，长度合适，不过分堆砌关键词，不同页面description有所不同，keywords列出重要关键词即可</p><p>2、语义化的html代码，符合W3C标准</p><p>3、提高网站速度</p><p>4、重要HTML代码放前面</p><p>5、重要内容不要用js输出：爬虫不会执行js获取内容</p><p>6、少用 iframe：搜索引擎不会抓取 iframe 中的内容</p><p>7、非装饰性图片必须加 alt  (网站的logo)</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-1-标准盒模型和IE盒模型两者的区别是什么？"><a href="#1-1-标准盒模型和IE盒模型两者的区别是什么？" class="headerlink" title="1.1 标准盒模型和IE盒模型两者的区别是什么？"></a>1.1 标准盒模型和IE盒模型两者的区别是什么？</h2><p><strong>概念</strong></p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括： 外边距<code>（margin）</code> 、 边框</p><p><code>（border）</code> 、 <code>内边距（padding）</code> 、<code> 实际内容（content）</code> 四个属性</p><p><strong>设置盒子模型</strong></p><ul><li>box-sizing:content-box;(标准)</li><li>box-sizing:border-box;(IE)</li></ul><p><strong>区别</strong></p><ul><li>标准的(W3C)盒模型：元素的实际宽度等于设置的宽高 + border + padding (默认方式)</li><li>IE盒模型： 元素的实际宽度就等于设置的宽高，即使定义有 border 和 padding 也不会改变元素的实际宽度，即 ( Element width &#x3D; width )</li></ul><h2 id="1-2-盒子塌陷是什么？"><a href="#1-2-盒子塌陷是什么？" class="headerlink" title="1.2 盒子塌陷是什么？"></a>1.2 盒子塌陷是什么？</h2><p><strong>盒子塌陷</strong></p><p>本应该在父盒子内部的元素跑到了外部。</p><p><strong>为什么会出现盒子塌陷？</strong></p><p>当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文</p><p>档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度</p><p>就会直接塌陷为零， 我们称这是<strong>CSS</strong>高度塌陷</p><p><strong>解决塌陷的方法</strong></p><ol><li>设置宽高</li><li>设置BFC</li><li>清楚浮动</li><li>给父盒子添加border</li><li>给父盒子设置padding-top</li></ol><h2 id="1-4-行内元素可以设置padding，margin吗？"><a href="#1-4-行内元素可以设置padding，margin吗？" class="headerlink" title="1.4 行内元素可以设置padding，margin吗？"></a>1.4 行内元素可以设置padding，margin吗？</h2><ul><li>行内元素的margin左右有效，上下无效</li><li>行内元素的padding左右有效 ，但是由于设置padding上下不占页面空间，无法显示效果，所以无效</li></ul><h2 id="1-6-BFC是什么？"><a href="#1-6-BFC是什么？" class="headerlink" title="1.6 BFC是什么？"></a>1.6 BFC是什么？</h2><p><strong>文档有几种流</strong></p><ol><li>定位流<ul><li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li><li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li><li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li><li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、</li><li>absolute，如果没有则相对于body；</li></ul></li><li>浮动流<ul><li>左浮动元素尽量靠左、靠上，右浮动同理</li><li>这导致常规流环绕在它的周边，除非设置 clear 属性</li><li>浮动元素不会影响块级元素的布局</li><li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li><li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li><li>不超过它的包含块，除非元素本身已经比包含块更宽</li><li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的</li><li>右边是不会摆放浮动元素的</li></ul></li><li>普通流<ul><li>在常规流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面， 它们竖着排列；</li><li>在行内格式化上下文里面， 它们横着排列;</li><li>当position为static或relative，并且float为none时会触发常规流；</li><li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li><li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、</li><li>left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li></ul></li></ol><p><strong>定义</strong></p><p>BFC的基本概念–BFC就是“<strong>块级格式化上下文</strong>”的意思，也有译作“块级格式化范围”。</p><p>通俗的讲，就是一个特殊的块，内部有自己的布局方式，不受外边元素的影响。</p><p><strong>布局规则</strong></p><ol><li>内部的 Box 会在垂直方向，一个接一个地放置</li><li>垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li></ol><p><strong>哪些元素会创建 BFC</strong></p><ol><li>根元素</li><li>float 属性不为 none</li><li>position 为 absolute 或 fixed</li><li>display 为 inline-block， table-cell， table-caption， flex， inline-flex</li><li>overflow 不为 visible</li></ol><p><strong>场景</strong></p><ol><li><p><strong>清除元素内部浮动</strong></p><p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。</p><p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p></li><li><p><strong>解决外边距合并问题(嵌套崩塌)</strong></p><p>外边距合并的问题。</p><p>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p><p>属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p></li><li><p><strong>制作右侧自适应的盒子问题</strong></p><p>普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</p></li></ol><h2 id="1-7-块元素居中"><a href="#1-7-块元素居中" class="headerlink" title="1.7 块元素居中"></a>1.7 块元素居中</h2><ul><li><p>我们可以利用<strong>margin:0 auto</strong>来实现元素的水平居中。</p></li><li><p>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</p></li><li><p>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。</p></li><li><p>!!!利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。</p></li><li><p>!!!使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p></li></ul><p>对于宽高不定的元素，后面两种方法，可以实现元素的垂直和水平的居中。</p><h2 id="1-8-CSS-优化、提高性能的方法有哪些？"><a href="#1-8-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="1.8 CSS 优化、提高性能的方法有哪些？"></a>1.8 CSS 优化、提高性能的方法有哪些？</h2><p><strong>加载性能：</strong></p><ul><li>css压缩：将写好的css进行打包压缩，可以减小文件体积</li><li>css单一样式：当需要下边距和左边距的时候，很多时候会选择使用margin-left:20px;margin-bottom:30px</li><li>减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载</li></ul><p><strong>选择器性能：</strong></p><ul><li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。</li><li>当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等</li><li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。</li><li>过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li><li>尽量少的去对标签进行选择，而是用class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后</li><li>代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li></ul><p><strong>渲染性能：</strong></p><ul><li>属性值为0时，不加单位。</li><li>可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ul><p><strong>可维护性、健壮性：</strong></p><ul><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中</li></ul><h2 id="1-11-浏览器是怎样解析CSS选择器的？"><a href="#1-11-浏览器是怎样解析CSS选择器的？" class="headerlink" title="1.11 浏览器是怎样解析CSS选择器的？"></a>1.11 浏览器是怎样解析CSS选择器的？</h2><p>CSS选择器的解析是从右向左解析的</p><p><strong>原因：</strong></p><p>从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点(叶子节点)，而从左向右的匹配规则的性能都浪</p><p>费在了失败的查找上面</p><h2 id="1-13-display、position和float的相互关系？"><a href="#1-13-display、position和float的相互关系？" class="headerlink" title="1.13 display、position和float的相互关系？"></a>1.13 display、position和float的相互关系？</h2><ul><li>首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现</li><li>然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被 设置为table或者block，具体转换需要看初始转换值</li><li>如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display 的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对 于浮动后的最终位置定位</li><li>如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是， 则保持指定的display属性值不变</li></ul><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在 的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素 的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h2 id="1-14-IFC-是什么？"><a href="#1-14-IFC-是什么？" class="headerlink" title="1.14 IFC 是什么？"></a>1.14 IFC 是什么？</h2><p>IFC指的是<strong>行级格式化上下文</strong>，它有这样的一些布局规则：</p><ul><li>行级上下文内部的盒子会在水平方向，一个接一个地放置。</li><li>当一行不够的时候会自动切换到下一行。&#x20;</li><li>行级上下文的高度由内部最高的内联盒子的高度决定</li></ul><h2 id="1-15-为什么不建议使用通配符初始化-css-样式"><a href="#1-15-为什么不建议使用通配符初始化-css-样式" class="headerlink" title="1.15 为什么不建议使用通配符初始化 css 样式"></a>1.15 为什么不建议使用通配符初始化 css 样式</h2><ul><li>采用*{pading:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时， 样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一 套初始化样式</li><li>出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即 可，并不需使用通配符*来初始化</li></ul><h2 id="1-16-CSS3-新特新"><a href="#1-16-CSS3-新特新" class="headerlink" title="1.16 CSS3 新特新"></a>1.16 CSS3 新特新</h2><ol><li>新增各种 CSS 选择器 <code> :not(p) </code> 选择每个非p的元素； <code>p:empty</code> 选择每个没有任何子级的p元素（包括文本节点）</li><li>边框（Borders）</li><li>背景 background-clip（规定背景图的绘制区域），background-origin，background-size</li><li>线性渐变 （Linear Gradients） 向下&#x2F;向上&#x2F;向左&#x2F;向右&#x2F;对角方向</li><li>文本效果 阴影text-shadow，textwrap，word-break，word-wrap</li><li>2D 转换 transform:scale(0.85,0.90) | translate(0px,-30px) | skew(-9deg,0deg) |rotate()  <strong>3D转换</strong> perspective()；transform是向元素应用 2D 或者 3D 转换</li><li>过渡 transition</li><li>动画</li><li>多列布局 （multi-column layout）</li><li>盒模型</li><li>flex 布局</li><li>多媒体查询 **定义两套css，当浏览器的尺寸变化时会采用不同的属性</li></ol><h2 id="1-18-什么是CSS-预处理器？为什么使用？"><a href="#1-18-什么是CSS-预处理器？为什么使用？" class="headerlink" title="1.18 什么是CSS 预处理器？为什么使用？"></a>1.18 什么是CSS 预处理器？为什么使用？</h2><ul><li>Less、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率</li></ul><p><strong>为什么要使用？</strong></p><ul><li>可嵌套性</li><li>变量</li><li>Mixins(混合@mixin)：可重用性高，可以注入任何东西</li><li>@extend：允许一个选择器继承另一个选择器</li><li>@function:函数功能，用户使用@function 可以去编写自己的函数</li><li>引用父元素&amp;：在编译时，&amp;将被替换成父选择符</li><li>计算功能</li><li>组合连接： #{} :变量连接字符串</li><li>循环语句：（很少用到）</li><li>if 语句：（很少用到）</li></ul><h2 id="1-19-浏览器是怎样解析的？"><a href="#1-19-浏览器是怎样解析的？" class="headerlink" title="1.19 浏览器是怎样解析的？"></a>1.19 浏览器是怎样解析的？</h2><ol><li>HTML 被 HTML 解析器解析成 DOM 树；2. CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><h2 id="1-23-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#1-23-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="1.23 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>1.23 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><p>行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</p><p><strong>解决方法：</strong></p><ol><li>可以将代码全部写在一排</li><li>浮动li中float：left</li><li><strong>在ul中用font-size：0（谷歌不支持</strong>）；</li><li>可以将 ul{letter-spacing: -4px;};li{letter-spacing: normal;}</li></ol><h2 id="1-24-display-inline-block-什么时候会显示间隙？"><a href="#1-24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="1.24 display:inline-block 什么时候会显示间隙？"></a>1.24 display:inline-block 什么时候会显示间隙？</h2><ol><li>有空格时候会有间隙 解决：s除空格</li><li>margin正值的时候 解决：margin使用负值</li><li>使用font-size时候 解决：font-size:0、letter-spacing、word-spacing</li></ol><h2 id="1-27-before-和-after-中双冒号和单冒号有什么区别、作用？"><a href="#1-27-before-和-after-中双冒号和单冒号有什么区别、作用？" class="headerlink" title="1.27 ::before 和::after 中双冒号和单冒号有什么区别、作用？"></a>1.27 ::before 和::after 中双冒号和单冒号有什么区别、作用？</h2><p><strong>区别</strong></p><p>在css中伪类一直用:表示，如 <code>:hover</code>，<code>:active</code>等</p><p>伪元素在CSS1中已存在，当时语法使用 : 表示 ，如：<code>:before</code>和<code>:after</code></p><p>后来在CSS3中修订，伪元素用 ::表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类</p><p>由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</p><p>单冒号<code>:</code> CSS3表示伪类；双冒号<code>::</code>CSS3伪元素</p><h2 id="1-29-未知高度元素垂直居中、垂直居中的实现方式有哪些？"><a href="#1-29-未知高度元素垂直居中、垂直居中的实现方式有哪些？" class="headerlink" title="1.29 未知高度元素垂直居中、垂直居中的实现方式有哪些？"></a>1.29 未知高度元素垂直居中、垂直居中的实现方式有哪些？</h2><ol><li>绝对定位+css3 transform:translate(-50%，-50%)</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line"><span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">-webkit-<span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>css3</strong> 的flex布局</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:flex;</span><br><span class="line"><span class="attribute">justify-content</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line"><span class="attribute">align-self</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>table布局</li></ol><h2 id="1-34-移动端适配方案"><a href="#1-34-移动端适配方案" class="headerlink" title="1.34 移动端适配方案"></a>1.34 移动端适配方案</h2><ol><li><strong>viewport</strong> <strong>适配</strong></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=750,initial-scale=0.5&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">initial-scale = 屏幕的宽度 / 设计稿的宽度</span></span><br><span class="line"><span class="comment">为了适配其他屏幕，需要动态的设置 initial-scale 的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = <span class="number">750</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">mobileAdapter</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> scale = screen.<span class="property">width</span> / <span class="variable constant_">WIDTH</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> content = <span class="string">`width=<span class="subst">$&#123;WIDTH&#125;</span>, initial-scale=<span class="subst">$&#123;scale&#125;</span>, maximumscale=<span class="subst">$&#123;scale&#125;</span>, minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> meta = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=viewport]&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (!meta) &#123;</span></span><br><span class="line"><span class="language-javascript">meta = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;meta&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">meta.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(meta)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">meta.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>,content)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">mobileAdapter</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onorientationchange</span> = mobileAdapter <span class="comment">//屏幕翻转时再次执行</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好</p><ol start="2"><li><p><strong>vw</strong> <strong>适配（部分等比缩放）</strong></p><ul><li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100&#x2F;750)*32 vw</li><li>对于需要等比缩放的元素，CSS使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximumscale=1, minimum-scale=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = <span class="number">750</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//:root &#123; --width: 0.133333 &#125; 1像素等于多少 vw</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--width&#x27;</span>, (<span class="number">100</span> / <span class="variable constant_">WIDTH</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>rem适配</strong></p></li><li><p><strong>弹性盒适配（合理布局）</strong></p></li></ol><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-1-let-var-const的区别？"><a href="#1-1-let-var-const的区别？" class="headerlink" title="1.1 let var const的区别？"></a>1.1 let var const的区别？</h2><p><strong>var ES5变量声明方式</strong></p><ol><li>在变量未赋值时，变量undefined（为使用声明变量时也为undefined）</li><li>作用域 var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</li></ol><p><strong>let ES6变量声明方式</strong></p><ol><li>在变量为声明前直接使用会报错</li><li>作用域   let为块级作用域   通常let比var范围要小</li><li>let进制重复声明变量，否则会报错；var可以重复声明</li></ol><p><strong>const ES6变量声明</strong></p><ol><li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值</li><li>const实际上保证的，并不是变量的值不得改动，而时变量指向的哪个内存地址不得改动</li></ol><h2 id="1-2-js数据类型，区别"><a href="#1-2-js数据类型，区别" class="headerlink" title="1.2 js数据类型，区别"></a>1.2 js数据类型，区别</h2><p><strong>基本数据类型：</strong></p><p>number，string，boolean，null，undefined，symbol，bigint</p><p><strong>引用数据类型：</strong></p><p>object，function</p><p>object：普通对象，数组对象，正则对象，日期对象，math数学函数对象。</p><h2 id="1-3-Javascript-创建对象的几种方式？"><a href="#1-3-Javascript-创建对象的几种方式？" class="headerlink" title="1.3 Javascript 创建对象的几种方式？"></a>1.3 <strong>Javascript 创建对象的几种方式？</strong></h2><ol><li>简单对象的创建 使用对象字面量的方式{}</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Cat</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>new 一个function</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personOne=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><ol start="3"><li>使用工厂方式来创建（Object 关键字）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wcDog =<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 Object.create() 创建对象（使用现有对象作为原型）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(anotherPerson);</span><br></pre></td></tr></table></figure><ol start="5"><li>使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="1-4-、-和object-is-区别"><a href="#1-4-、-和object-is-区别" class="headerlink" title="1.4 &#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和object.is 区别"></a>1.4 &#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和object.is 区别</h2><ol><li>&#x3D;&#x3D; 值比较值</li><li>&#x3D;&#x3D;&#x3D;值和类型都比较</li><li>object.is 和 &#x3D;&#x3D;&#x3D; 区别  +-0 false   NaN true</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === -<span class="number">0</span>);       <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>);     <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>,-<span class="number">0</span>)              <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>,<span class="title class_">NaN</span>)            <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="1-5-如何区分数组和对象？"><a href="#1-5-如何区分数组和对象？" class="headerlink" title="1.5 如何区分数组和对象？"></a>1.5 如何区分数组和对象？</h2><ol><li>通过 ES6 中的 Array.isArray</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过 instanceof 来识别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过调用 constructor 来识别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.<span class="property">constructor</span> <span class="comment">//返回 object</span></span><br><span class="line">[].<span class="property">constructor</span> <span class="comment">//返回 Array</span></span><br></pre></td></tr></table></figure><ol start="4"><li>通过 Object.prototype.toString.call 方法来识别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">//[&quot;object Array&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">//[&quot;object Object&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="1-6-作用域和作用域链"><a href="#1-6-作用域和作用域链" class="headerlink" title="1.6 作用域和作用域链"></a>1.6 作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离<br>变量，不同作用域下同名变量不会有冲突</p><ol><li>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。</li><li>ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现</li></ol><p><strong>什么是作用域链？</strong></p><ul><li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链</p></li><li><p>由子级作用域返回父级作用域中寻找变量，就叫做作用域链</p></li><li><p>作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自中的最后一个对象</p></li><li><p>作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象</p></li></ul><p><strong>如何延长作用域链？</strong></p><p>执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除具体来说就是执行这两个语句时，作用域链都会得到加强</p><ol><li><p>try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明</p></li><li><p>with 语句。with 语句会将指定的对象添加到作用域链中</p></li></ol><h2 id="1-7-constructor的理解"><a href="#1-7-constructor的理解" class="headerlink" title="1.7 constructor的理解"></a>1.7 constructor的理解</h2><p>创建的每个函数都有一个prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，之后属性是一个指向prototype属性坐在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。注意当将构造函数的prototype设置为等于一个以对象字面量形式创建的新对象时，constructor属性不再指向该构造函数</p><h2 id="1-10-map-和-forEach-的区别？"><a href="#1-10-map-和-forEach-的区别？" class="headerlink" title="1.10 map 和 forEach 的区别？"></a>1.10 map 和 forEach 的区别？</h2><p><strong>相同点：</strong></p><ol><li>都是循环遍历数组中的每一项</li><li>每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），<br>arr（原数组）</li><li>匿名函数中的this都是指向window</li><li>只能遍历数组</li></ol><p><strong>不同点：</strong></p><ol><li>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</li><li>forEach()允许callback更改原始数组的元素。map()返回新的数组。</li></ol><h2 id="1-11-for-of-可以遍历哪些对象？"><a href="#1-11-for-of-可以遍历哪些对象？" class="headerlink" title="1.11 for of 可以遍历哪些对象？"></a>1.11 for of 可以遍历哪些对象？</h2><p>for..of..: 它是es6新增的一个遍历方法，但只限于迭代器(iterator), 所以普通的对象用for..of遍历<br>是会报错的。<br>可迭代的对象：包括Array, Map, Set, String, TypedArray, arguments对象等等</p><h2 id="1-11-js遍历对象的方法？"><a href="#1-11-js遍历对象的方法？" class="headerlink" title="1.11 js遍历对象的方法？"></a>1.11 js遍历对象的方法？</h2><ol><li><code>for...in</code> 循环</li><li><code>Object.keys()</code> 方法</li><li><code>Object.entries()</code> 方法</li></ol><h2 id="1-13-new操作符具体干了什么呢"><a href="#1-13-new操作符具体干了什么呢" class="headerlink" title="1.13 new操作符具体干了什么呢?"></a>1.13 new操作符具体干了什么呢?</h2><ol><li>创建空对象；<br>var obj &#x3D; {};</li><li>设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的<br>prototype对象；<br>obj.proto &#x3D; ClassA.prototype;<br>扩展了新对象的原型链。</li><li>使用新对象调用函数，函数中的this被指向新实例对象：<br>ClassA.call(obj); &#x2F;&#x2F;{}.构造函数();</li><li>返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。</li></ol><h2 id="1-14-作用域"><a href="#1-14-作用域" class="headerlink" title="1.14 作用域"></a>1.14 作用域</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离<br>变量，不同作用域下同名变量不会有冲突</p><ol><li>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。</li><li>ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现</li></ol><h2 id="1-15-javascript中arguments相关的问题"><a href="#1-15-javascript中arguments相关的问题" class="headerlink" title="1.15 javascript中arguments相关的问题"></a>1.15 javascript中arguments相关的问题</h2><p><strong>arguments</strong><br>在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一<br>个叫arguments的对象里面。它是一个类数组数据<br><strong>作用</strong><br>有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函<br>数加入参数</p><h2 id="1-16-instanceOf作用-即原理"><a href="#1-16-instanceOf作用-即原理" class="headerlink" title="1.16 instanceOf作用 即原理"></a>1.16 instanceOf作用 即原理</h2><p>instanceof主要作用就是判断一个实例是否属于某种类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rightProto = rightVaule.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">    leftVaule = leftVaule.<span class="property">__proto__</span>; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftVaule === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leftVaule = leftVaule.<span class="property">__proto__</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><h2 id="1-17-数组和伪数组的区别"><a href="#1-17-数组和伪数组的区别" class="headerlink" title="1.17 数组和伪数组的区别?"></a>1.17 数组和伪数组的区别?</h2><ol><li>定义</li></ol><ul><li>数组是一个特殊对象,与常规对象的区别：<ul><li>当由新元素添加到列表中时，自动更新length属性</li><li>设置length属性，可以截断数组</li><li>从Array.protoype中继承了方法</li><li>属性为’Array’</li></ul></li><li>类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。</li></ul><ol start="2"><li>区别<br>本质：类数组是简单对象，它的原型关系与数组不同</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike.<span class="title function_">toString</span>()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike.<span class="title function_">valueOf</span>()); <span class="comment">// &#123;length: 10&#125;</span></span><br><span class="line"><span class="keyword">let</span> array = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">toString</span>()); <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">valueOf</span>()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><ol start="3"><li>类数组转换为数组</li></ol><ul><li><p>转换方法</p><ul><li>使用 Array.from()</li><li>使用 Array.prototype.slice.call()</li><li>使用 Array.prototype.forEach() 进行属性遍历并组成新的数组</li></ul></li></ul><h2 id="1-19-简单说说-js-中有哪几种内存泄露的情况"><a href="#1-19-简单说说-js-中有哪几种内存泄露的情况" class="headerlink" title="1.19 简单说说 js 中有哪几种内存泄露的情况"></a>1.19 简单说说 js 中有哪几种内存泄露的情况</h2><ol><li>意外的全局变量；</li><li>闭包；</li><li>未被清空的定时器；</li><li>未被销毁的事件监听；</li><li>DOM 引用；</li></ol><h2 id="1-23-promise和-async-await-区别"><a href="#1-23-promise和-async-await-区别" class="headerlink" title="1.23 promise和 async await 区别?"></a>1.23 promise和 async await 区别?</h2><p><strong>概念</strong><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强<br>大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而<br>这些结果一旦生成是无法改变的<br>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执<br>行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象<br><strong>两者的区别</strong></p><ol><li>Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向<br>发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async<br>await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同<br>于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li><li>async await与Promise一样，是非阻塞的。</li><li>async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函<br>数。</li></ol><h2 id="1-24-defer和async区别"><a href="#1-24-defer和async区别" class="headerlink" title="1.24 defer和async区别?"></a>1.24 defer和async区别?</h2><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。多个defer脚本会按照它们在页面出现的顺序加载。&#x3D;&#x3D;“渲染完再执行”&#x3D;&#x3D;</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本是不能保证加载顺序的。&#x3D;&#x3D;“下载完就执行”&#x3D;&#x3D;</li></ul><h2 id="1-25-同步和异步"><a href="#1-25-同步和异步" class="headerlink" title="1.25 同步和异步"></a>1.25 同步和异步</h2><p><strong>同步</strong></p><ul><li>指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。</li><li>也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序<br>和任务排列顺序是一致的。</li></ul><p><strong>异步</strong></p><ul><li>异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</li><li>每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。</li><li>程序的执行顺序和任务的排列顺序是不一致的，异步的。</li><li>我们常用的setTimeout和setInterval函数，Ajax都是异步操作。</li></ul><h2 id="1-27-null-和-undefined-的区别，如何让一个属性变为null"><a href="#1-27-null-和-undefined-的区别，如何让一个属性变为null" class="headerlink" title="1.27 null 和 undefined 的区别，如何让一个属性变为null"></a>1.27 null 和 undefined 的区别，如何让一个属性变为null</h2><p><strong>undefined</strong></p><ol><li>声明了一个变量，但没有赋值</li><li>访问对象上不存在的属性</li><li>函数定义了形参，但没有传递实参</li><li>使用 void 对表达式求值</li></ol><p><strong>null</strong></p><ol><li>null是一个空值</li><li>null 有属于自己的类型 Null，而不属于Object类型</li><li>二进制的前三位为 0 会被 typeof 判断为对象类型</li></ol><h2 id="1-29-call-appy-bind的作用和区别？"><a href="#1-29-call-appy-bind的作用和区别？" class="headerlink" title="1.29 call appy bind的作用和区别？"></a>1.29 call appy bind的作用和区别？</h2><p><strong>作用：</strong></p><p>都可以改变函数内部的this指向</p><p><strong>区别点：</strong></p><ol><li>call 和 apply 会调用函数，并且改变函数内部this指向。</li><li>call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg]</li><li>bind 不会调用函数，可以改变函数内部this指向</li></ol><h2 id="1-30-this指向（普通函数、箭头函数）"><a href="#1-30-this指向（普通函数、箭头函数）" class="headerlink" title="1.30 this指向（普通函数、箭头函数）"></a>1.30 this指向（普通函数、箭头函数）</h2><ol><li>谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁</li><li>匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象</li></ol><p><strong>箭头函数中的this</strong></p><ul><li>箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的</li><li>箭头函数中的this指向父级作用域的执行上下文；</li><li>箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来</li></ul><h2 id="1-32-继承，优缺点-及方法有哪些？"><a href="#1-32-继承，优缺点-及方法有哪些？" class="headerlink" title="1.32 继承，优缺点 及方法有哪些？"></a>1.32 继承，优缺点 及方法有哪些？</h2><p><strong>继承的好处</strong></p><p>a：提高了代码的复用性</p><p>b：提高了代码的维护性</p><p>c：让类与类之间产生了关系，是多态的前提</p><p><strong>继承的弊端</strong></p><p>类的耦合性增强了,但是开发的原则：高内聚，低耦合</p><h3 id="1-32-1原型链继承"><a href="#1-32-1原型链继承" class="headerlink" title="1.32.1原型链继承"></a>1.32.1原型链继承</h3><p>实现方式：将子类的原型链指向父类的对象实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">list</span> = [<span class="string">&#x27;坤&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>);</span><br><span class="line">child.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure><p><strong>原理：</strong>子类实例child的<code>__proto__</code> 指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的 <code>__proto__</code> 指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法</p><p><strong>优点：</strong>可继承构造函数的属性，父类构造函数的属性，父类原型的属性</p><p><strong>缺点：</strong></p><ol><li>无法向父类构造函数传参；</li><li>共享父类实例的属性（若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">a.<span class="property">list</span>.<span class="title function_">push</span>(<span class="string">&#x27;rap&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">list</span>); <span class="comment">// [&#x27;坤&#x27;,&#x27;rap&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="1-32-2-构造函数继承"><a href="#1-32-2-构造函数继承" class="headerlink" title="1.32.2 构造函数继承"></a>1.32.2 构造函数继承</h3><p>实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, id) <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;坤&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">child.<span class="title function_">printName</span>() <span class="comment">// 坤</span></span><br><span class="line">child.<span class="title function_">sayName</span>() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>原理：</strong>使用call或者apply改变子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性</p><p>优点：可解决原型链继承 <strong>共享</strong> 的问题</p><p>缺点： 不可继承父类的原型方法，构造函数不可以被复用</p><h3 id="1-32-3-组合继承"><a href="#1-32-3-组合继承" class="headerlink" title="1.32.3 组合继承"></a>1.32.3 组合继承</h3><p><strong>原理：</strong>综合使用构造函数继承和原型链继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="string">&#x27;rap&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, id);<span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;坤坤&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">child.<span class="title function_">printName</span>(); <span class="comment">// 坤坤</span></span><br><span class="line">child.<span class="title function_">sayName</span>() <span class="comment">// 坤坤</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">a.<span class="property">list</span>.<span class="title function_">push</span>(<span class="string">&#x27;篮球&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">list</span>); <span class="comment">// [&#x27;rap&#x27;]    </span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong>可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的</p><p><strong>缺点：</strong>会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数</p><h3 id="1-32-4-原型式继承"><a href="#1-32-4-原型式继承" class="headerlink" title="1.32.4 原型式继承"></a>1.32.4 原型式继承</h3><p><strong>原理：</strong>类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的 <code>__proto__</code> 指向父对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line"><span class="attr">name</span>: [<span class="string">&#x27;坤坤&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object</span>) &#123;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">fn.<span class="property"><span class="keyword">prototype</span></span> = object</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">copy</span>(parent)</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong> 共享引用数据类型</p><h3 id="1-32-5-寄生式继承"><a href="#1-32-5-寄生式继承" class="headerlink" title="1.32.5 寄生式继承"></a>1.32.5 寄生式继承</h3><p><strong>原理：</strong>扩展原型式继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object</span>) &#123;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">fn.<span class="property"><span class="keyword">prototype</span></span> = object</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">copy</span>(obj);</span><br><span class="line">obj.<span class="property">getNames</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">names</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">names</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>可添加新的属性和方法</p><h3 id="1-32-6-寄生组合式继承"><a href="#1-32-6-寄生组合式继承" class="headerlink" title="1.32.6 寄生组合式继承"></a>1.32.6 寄生组合式继承</h3><p><strong>原理：</strong>改进组合继承，利用寄生式继承的思想继承原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subClass, superClass</span>) &#123;</span><br><span class="line"><span class="comment">// 复制一份父类的原型</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">copy</span>(superClass.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 修正构造函数</span></span><br><span class="line">p.<span class="property">constructor</span> = subClass;</span><br><span class="line"><span class="comment">// 设置子类原型</span></span><br><span class="line">subClass.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, id</span>)&#123;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, id);</span><br><span class="line"><span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br></pre></td></tr></table></figure><h3 id="1-32-7-ES6-class-extends"><a href="#1-32-7-ES6-class-extends" class="headerlink" title="1.32.7 ES6 class extends"></a>1.32.7 ES6 class extends</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><h2 id="1-33-扩展运算符-…"><a href="#1-33-扩展运算符-…" class="headerlink" title="1.33 扩展运算符 …"></a>1.33 扩展运算符 …</h2><h3 id="1-33-1哪些类型能被扩展操作符"><a href="#1-33-1哪些类型能被扩展操作符" class="headerlink" title="1.33.1哪些类型能被扩展操作符?"></a>1.33.1哪些类型能被扩展操作符?</h3><p><strong>类型：</strong>数组、对象、字符串</p><ul><li><p>复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作。</p></li><li><p>基础数据只有string可以使用扩展运算符，number,boolean,null,undefined无效</p></li></ul><h3 id="1-33-2-场景"><a href="#1-33-2-场景" class="headerlink" title="1.33.2 场景"></a>1.33.2 场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、函数调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(...[<span class="number">4</span>, <span class="number">38</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, c, d, e</span>) &#123; &#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, ...[<span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>, ...[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.往数组里push多个元素</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;子异&#x27;</span>, <span class="string">&#x27;坤坤&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;说&#x27;</span>, <span class="string">&#x27;唱&#x27;</span>, <span class="string">&#x27;跳&#x27;</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">//[&#x27;子异&#x27;, &#x27;坤坤&#x27;,&#x27;说&#x27;, &#x27;唱&#x27;, &#x27;跳&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.替代函数的apply方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args); <span class="comment">//ES5 的写法</span></span><br><span class="line"><span class="title function_">f</span>(...args); <span class="comment">//ES6的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.求一个数组的最大数简化</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]) <span class="comment">//ES5 的写法</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]) <span class="comment">//ES6 的写法，等同于Math.max(14, 3, 77)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.扩展运算符后面可以放表达式</span></span><br><span class="line"><span class="keyword">const</span> arr = [...(<span class="number">5</span> &gt; <span class="number">0</span> ? [<span class="string">&#x27;a&#x27;</span>] : []),<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.与解构赋值结合，用于生成数组</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1]; <span class="comment">//写法1</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1; <span class="comment">//写法2</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">//1</span></span><br><span class="line">rest <span class="comment">//[2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">//undefined</span></span><br><span class="line">rest <span class="comment">//[]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first <span class="comment">//&quot;foo&quot;</span></span><br><span class="line">rest <span class="comment">//[]</span></span><br><span class="line"><span class="comment">//1234567891011121314151617</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3] <span class="comment">//[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">//8.数组的克隆</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[0, 1, 2]</span></span><br><span class="line"><span class="comment">/* 乍一看，arr2与arr1不共用引用地址，arr2不随着arr1变化，接着往下看 */</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, [<span class="number">1</span>,<span class="number">11</span>,<span class="number">111</span>], <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[0, [100,11,111], 2]</span></span><br></pre></td></tr></table></figure><h2 id="1-34-实现异步的方法"><a href="#1-34-实现异步的方法" class="headerlink" title="1.34 实现异步的方法"></a>1.34 实现异步的方法</h2><h3 id="1-34-1-回调函数"><a href="#1-34-1-回调函数" class="headerlink" title="1.34.1 回调函数"></a>1.34.1 回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 处理逻辑</span></span><br><span class="line">    <span class="title function_">ajax</span>(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="title function_">ajax</span>(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>简单、容易理解和实现</p><p><strong>缺点：</strong>不利阅读和维护，耦合度高，不能使用try…catch捕获，不能直接 return</p><h3 id="1-34-2-promise"><a href="#1-34-2-promise" class="headerlink" title="1.34.2 promise"></a>1.34.2 promise</h3><p>本意是承诺，<strong>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了</strong></p><p><strong>Promise的三种状态</strong></p><ul><li><p>Pending—-Promise对象实例创建时候的初始状态</p></li><li><p>Fulfilled—-可以理解为成功的状态</p></li><li><p>Rejected—-可以理解为失败的状态</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)<span class="comment">//无效代码不会执行</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reason)<span class="comment">//reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>promise的链式调用</p><ul><li><p>每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)</p></li><li><p>如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调</p></li><li><p>如果then中出现异常,会走下一个then的失败回调</p></li><li><p>在 then中使用了return，那么 return 的值会被Promise.resolve() 包装(见例1，2)</p></li><li><p>then中可以不传递参数，如果不传递会透到下一个then中(见例3)</p></li><li><p>catch 会捕获到没有捕获的异常</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">//包装成 Promise.resolve(2)</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="number">3</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="title function_">ajax</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">ajax</span>(url1)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">ajax</span>(url2)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure><p>存在一个缺点：无法取消promise，错误需要通过回调函数捕获</p><h3 id="1-34-3-生成器generator-yield"><a href="#1-34-3-生成器generator-yield" class="headerlink" title="1.34.3 生成器generator&#x2F;yield"></a>1.34.3 生成器generator&#x2F;yield</h3><p><strong>特点：</strong>控制函数的执行</p><ul><li>Generator 函数是一个状态机，封装了多个内部状态</li><li>Generator 函数除了状态机，还是一个遍历器对象生成函数</li><li>可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果</li><li>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))      </span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">5</span>)           </span><br><span class="line">    <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// =&gt; &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">20</span>))<span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">30</span>)) <span class="comment">// =&gt; &#123;value: 72, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决回调地狱</span></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="title function_">ajax</span>(url, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">yield</span> <span class="title function_">ajax</span>(url1, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">yield</span> <span class="title function_">ajax</span>(url2, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">fetch</span>()</span><br><span class="line"><span class="keyword">let</span> result1 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result2 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result3 = it.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><h3 id="1-34-3-async-await"><a href="#1-34-3-async-await" class="headerlink" title="1.34.3 async&#x2F;await"></a>1.34.3 async&#x2F;await</h3><p><strong>特点：</strong></p><ul><li>async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数</li><li>async&#x2F;await与Promise一样，是非阻塞的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;async&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()) <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: &quot;async&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>类似generator调用方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">ff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">ajax</span>(url1, <span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">ajax</span>(url2,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">ajax</span>(url3,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">ff</span>()</span><br></pre></td></tr></table></figure><p>模拟一个并发请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">read1</span>()</span><br><span class="line"><span class="title function_">read2</span>()<span class="comment">//这个函数同步执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">read1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">await</span> <span class="title function_">ajax</span>(url1,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">read2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">await</span> <span class="title function_">ajax</span>(url2,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">readAll</span>()</span><br></pre></td></tr></table></figure><h2 id="1-36-为什么js是单线程"><a href="#1-36-为什么js是单线程" class="headerlink" title="1.36 为什么js是单线程"></a>1.36 为什么js是单线程</h2><p><strong>用途：</strong>js在创立之初主要是应用于用户与浏览器的交互，以及操作dom，这一特性决定了，只能是单线程，否则会带来复杂的同步问题。</p><p>​例如： 如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom，这时候就不能处理。避免这个问题，浏览器就设计了单线程，避免了这个麻烦</p><h2 id="1-37-死锁"><a href="#1-37-死锁" class="headerlink" title="1.37 死锁"></a>1.37 死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</p><p><strong>产生原因：</strong></p><ul><li>竞争资源引起进程死锁</li><li>可剥夺和非剥夺资源</li><li>竞争非剥夺资源</li><li>竞争临时性资源</li><li>进程推进顺序不当</li></ul><p><strong>产生条件：</strong></p><ol><li><p>互斥条件：涉及的资源是非共享的</p><ul><li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li></ul></li><li><p>不剥夺条件：不能强行剥夺进程拥有的资源</p><ul><li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li></ul></li><li><p>请求和保持条件：进程在等待一新资源时继续占有已分配的资源</p><ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li></ul></li></ol><p>解决办法</p><p>只要打破四个必要条件中的一个就能有效防止死锁的发生</p><h2 id="1-38-暂时性死区"><a href="#1-38-暂时性死区" class="headerlink" title="1.38 暂时性死区"></a>1.38 暂时性死区</h2><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>let 、const具有暂时性死区</p><p>var 不具有暂时性死区</p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="1-1-cookie-sessionStorage-localStorage-区别"><a href="#1-1-cookie-sessionStorage-localStorage-区别" class="headerlink" title="1.1 cookie sessionStorage localStorage 区别"></a><strong>1.1 cookie sessionStorage localStorage</strong> <strong>区别</strong></h2><p><strong>共同点：</strong></p><p>都是保存在浏览器端、且同源的</p><p><strong>区别：</strong></p><ol><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 </p></li><li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 </p></li><li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </p></li><li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p></li><li><p>Storage的api接口使用更方便</p></li></ol><h2 id="1-2-如何写一个会过期的localStorage，说说想法"><a href="#1-2-如何写一个会过期的localStorage，说说想法" class="headerlink" title="1.2 如何写一个会过期的localStorage，说说想法"></a>1.2 如何写一个会过期的localStorage，说说想法</h2><p><strong>惰性删除 和 定时删除</strong></p><p><strong>惰性删除</strong></p><p>惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lsc = (<span class="keyword">function</span> (<span class="params">self</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> prefix = <span class="string">&#x27;lsc_&#x27;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 增加一个键值对数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expires 过期时间，单位为秒</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    self.<span class="property">set</span> = <span class="keyword">function</span>(<span class="params">key, val, expires</span>) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        val = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&#x27;val&#x27;</span>: val, <span class="string">&#x27;expires&#x27;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + expires * <span class="number">1000</span>&#125;);</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, val);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取对应键的值数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns</span> &#123;<span class="type">null|*</span>&#125; 对应键的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    self.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        <span class="keyword">var</span> val = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    val = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val.<span class="property">expires</span> &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()) &#123;</span><br><span class="line">            <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> val.<span class="property">val</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><p><strong>定时删除</strong></p><p>定时删除是指，每隔一段时间执行一次删除操作</p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复<strong>步骤****1</strong>，直至重复500次。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lsc = (<span class="keyword">function</span> (<span class="params">self</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> prefix = <span class="string">&#x27;lsc_&#x27;</span></span><br><span class="line"><span class="keyword">var</span> list = [];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    self.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">localStorage</span>);</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^&#x27;</span> + prefix);</span><br><span class="line">        <span class="keyword">var</span> temp = [];</span><br><span class="line">        <span class="comment">//遍历所有localStorage中的所有key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//找出可过期缓存的key</span></span><br><span class="line">            <span class="keyword">if</span> (reg.<span class="title function_">test</span>(keys[i])) &#123;</span><br><span class="line">                temp.<span class="title function_">push</span>(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">&#125;;</span><br><span class="line">self.<span class="title function_">init</span>();</span><br><span class="line">self.<span class="property">check</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list || list.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> checkCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (checkCount &lt; <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> expireCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 随机测试20个设置了过期时间的key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * list.<span class="property">length</span>);</span><br><span class="line">            <span class="keyword">var</span> key = list[index];</span><br><span class="line">            <span class="keyword">var</span> val = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(list[index]);</span><br><span class="line">            <span class="comment">// 从list中删除被惰性删除的key</span></span><br><span class="line">            <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">                list.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">                expireCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(val);</span><br><span class="line">            <span class="comment">// 删除所有发现的已过期的key</span></span><br><span class="line">            <span class="keyword">if</span> (val.<span class="property">expires</span> &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()) &#123;</span><br><span class="line">                list.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">                <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key);</span><br><span class="line">                expireCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若删除的key不超过5个则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (expireCount &lt;= <span class="number">5</span> || list.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">checkCount++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//每隔一秒执行一次定时删除</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(self.<span class="property">check</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="1-3-localStorage-能跨域吗"><a href="#1-3-localStorage-能跨域吗" class="headerlink" title="1.3 localStorage 能跨域吗"></a>1.3 <strong>localStorage</strong> <strong>能跨域吗</strong></h2><p>不能</p><p><strong>解决办法</strong></p><ul><li>通过postMessage来实现跨源通信</li><li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li><li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li></ul><h2 id="1-4-memory-cache-如何开启"><a href="#1-4-memory-cache-如何开启" class="headerlink" title="1.4 memory cache 如何开启"></a><strong>1.4 memory cache</strong> <strong>如何开启</strong></h2><p>memory cache 如何开启是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，也不会生效</p><h2 id="1-5-localstorage的注意哪些问题"><a href="#1-5-localstorage的注意哪些问题" class="headerlink" title="1.5 localstorage的注意哪些问题"></a>1.5 localstorage的注意哪些问题</h2><ol><li>兼容性问题</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h2 id="1-6-浏览器输入URL发生了什么"><a href="#1-6-浏览器输入URL发生了什么" class="headerlink" title="1.6 浏览器输入URL发生了什么"></a>1.6 浏览器输入URL发生了什么</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h2 id="1-7-浏览器是如何渲染页面的？"><a href="#1-7-浏览器是如何渲染页面的？" class="headerlink" title="1.7 浏览器是如何渲染页面的？"></a>1.7 浏览器是如何渲染页面的？</h2><p>不同浏览器内核渲染机制有所区别</p><ol><li>HTML 被 HTML 解析器解析成 DOM 树；</li><li>CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><p>webkit</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810145750627.png" alt="image-20230810145750627"></p><p>Gecko</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810145831120.png" alt="image-20230810145831120"></p><h2 id="1-8-重绘、重排"><a href="#1-8-重绘、重排" class="headerlink" title="1.8 重绘、重排"></a>1.8 重绘、重排</h2><p><strong>概念</strong></p><ol><li>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树</li><li>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</li></ol><p><strong>区别：</strong></p><p>重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p><p><strong>引发重排</strong></p><ol><li>添加、删除可见的dom</li><li>元素的位置改变</li><li>元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</li><li>页面渲染初始化</li><li>浏览器窗口尺寸改变</li><li>获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存</li></ol><p><strong>优化方案</strong></p><p>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p><p>减少 reflow&#x2F;repaint：</p><ol><li><p>不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的className。</p></li><li><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会reflow 的。</p></li><li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)</p></li><li><p>不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</p></li></ol><h2 id="1-9-事件循环（Event-loop）"><a href="#1-9-事件循环（Event-loop）" class="headerlink" title="1.9 事件循环（Event loop）"></a>1.9 事件循环（Event loop）</h2><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环</p><p><strong>JavaScript 的事件分两种</strong></p><ol><li>宏任务：包括整体代码 script，setTimeout，setInterval</li><li>微任务：Promise.then(非 new Promise)，process.nextTick(node 中)</li></ol><p><strong>具体执行：</strong></p><p>事件的执行顺序——先执行宏任务，然后执行微任务，任务有同步的任务和异步的任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放在队列中，如果还有异步的宏任务，那么就会进行循环执行上述的操作</p><p>主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行</p><p><strong>详细步骤</strong>：</p><ol><li><p>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</p></li><li><p>将事件循环的当前运行宏任务设置为已选择的宏任务。</p></li><li><p>运行宏任务。</p></li><li><p>将事件循环的当前运行任务设置为null。</p></li><li><p>将运行完的宏任务从宏任务队列中移除。</p></li><li><p>microtasks步骤：进入microtask检查点。</p></li><li><p>更新界面渲染。</p></li><li><p>返回第一步。</p></li></ol><p><strong>执行进入microtask检查的的具体步骤如下:</strong></p><ol><li>设置进入microtask检查点的标志为true。</li><li>当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事</li></ol><p>件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务</p><p>为null；将运行结束 的microtask从microtask队列中移除。</p><ol start="3"><li>对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些</li></ol><p>promise为 rejected。</p><ol start="4"><li>清理indexedDB的事务。</li><li>设置进入microtask检查点的标志为false。</li></ol><p><strong>注意</strong></p><p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件,然后再去宏任务队列中取出一个事件。同一次事件循环中,微任务永远在宏任务之前执行</p><h2 id="1-10-let-a-1-挂载在哪里？"><a href="#1-10-let-a-1-挂载在哪里？" class="headerlink" title="1.10 let a &#x3D; 1 挂载在哪里？"></a>1.10 let a &#x3D; 1 挂载在哪里？</h2><p>var a 挂载在window下。而let是挂载在 全局函数下面</p><h2 id="1-11-浏览器垃圾回收机制"><a href="#1-11-浏览器垃圾回收机制" class="headerlink" title="1.11 浏览器垃圾回收机制"></a>1.11 浏览器垃圾回收机制</h2><p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation),执行环境会负责管理代码执行过程中使用的内存</p><p><strong>原理：</strong></p><p>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;hanzichi&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;hanzichi&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">fn2</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先定义了两个function，分别叫做fn1和fn2,当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象&#123;name: &#x27;hanzichi&#x27;, age: 10&#125;，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>到底哪个变量是没有用的？</p><p><strong>解决</strong></p><p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常</p><p>情况下有两种实现方式：<strong>标记清除</strong>和<strong>引用计数</strong>。引用计数不太常用，标记清除较为常用。</p><p><strong>标记清除</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> ; <span class="comment">//被标记 ，进入环境</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span> ; <span class="comment">//被标记 ，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">//执行完毕 之后 a、b又被标离开环境，被回收。</span></span><br></pre></td></tr></table></figure><p><strong>引用计数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125; ; <span class="comment">//a的引用次数为0</span></span><br><span class="line"><span class="keyword">var</span> b = a ; <span class="comment">//a的引用次数加1，为1</span></span><br><span class="line"><span class="keyword">var</span> c =a; <span class="comment">//a的引用次数再加1，为2</span></span><br><span class="line"><span class="keyword">var</span> b =&#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); </span><br></pre></td></tr></table></figure><p><strong>GC****方案</strong></p><p>​<strong>1.</strong> <strong>基础方案</strong></p><p>​Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>​<strong>2. GC的缺陷</strong></p><p>​和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。</p><p>​<strong>3. GC优化策略</strong></p><ol><li><strong>分代回收</strong>（Generation GC） 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时</li></ol><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810163252320.png" alt="image-20230810163252320"></p><p>补充：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。</p><ol start="2"><li><strong>增量GC</strong> 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”</li></ol><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810163307127.png" alt="image-20230810163307127"></p><p>​这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。</p><p>​因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。</p><p>​比如：低 (对象&#x2F;s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。</p><h2 id="1-12-cookie"><a href="#1-12-cookie" class="headerlink" title="1.12 cookie"></a>1.12 cookie</h2><ol><li><strong>cookie是什么？</strong></li></ol><ul><li><p>cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。</p></li><li><p>实际上 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。</p></li><li><p>不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。</p></li></ul><ol start="2"><li>怎么使用 cookie？</li></ol><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=value;expires=evalue; path=pvalue; domain=dvalue;secure;”</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>注意事项</strong></li></ol><ul><li>cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能</li><li>cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的</li><li>cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除</li><li>cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理</li><li>cookie 在保存时，只要后面保存的 name 相同，那么就会覆盖前面的 cookie，注意是完全覆盖，包括失效时间，pat</li></ul><ol start="4"><li><strong>cookie禁用</strong></li></ol><p>sessionID通过cookie保存在客户端，如果将cookie禁用，必将对session的使用造成一定的影响</p><p>解决办法：url重写</p><h2 id="1-13-调试工具"><a href="#1-13-调试工具" class="headerlink" title="1.13 调试工具"></a>1.13 调试工具</h2><h3 id="a-谷歌浏览器"><a href="#a-谷歌浏览器" class="headerlink" title="a.谷歌浏览器"></a>a.谷歌浏览器</h3><ol><li><p>Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。</p></li><li><p>console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。</p></li><li><p>Sources：断点调试JS，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。</p></li><li><p>Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“小编有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。</p></li><li><p>Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。</p></li><li><p>Application：记录网站加载的各个资源信息。</p></li><li><p>Security：判断网页是否安全。</p></li><li><p>Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。</p></li></ol><h3 id="b-其他"><a href="#b-其他" class="headerlink" title="b.其他"></a>b.其他</h3><p><strong>postman</strong></p><p>Postman 是调试接口的最佳工具之一，使用 Postman，我们可以调整请求，分析响应和调试问题</p><p><strong>CSSLint</strong></p><p>CSSLint 是一个用来帮你找出 CSS 代码中问题的工具，它可做基本的语法检查以及使用一套预设的规则 来检查代码中的问题，规则是可以扩展的</p><p><strong>Sentry</strong></p><p>Sentry就是来帮我们解决这个问题的，它是是一个实时事件日志记录和聚合平台。它专门用于监视错误 和提取执行适当的事后操作所需的所有信息, 而无需使用标准用户反馈循环的任何麻烦</p><p><strong>BrowserStack</strong></p><p>BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备 很多虚拟机或者手机模拟器</p><h1 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h1><h2 id="1-1-跨域"><a href="#1-1-跨域" class="headerlink" title="1.1 跨域"></a>1.1 跨域</h2><p><strong>跨域是什么？</strong></p><p>跨域（Cross-Origin）指的是在浏览器中，当一个请求的源（Origin）与目标资源的源不一致时，即发生跨域访问。在默认情况下，浏览器的同源策略（Same-Origin Policy）会阻止这种跨域访问。同源策略是为了保护用户的信息安全，防止恶意网站对其他网站的资源进行访问和操作。</p><p><strong>同源策略规定几个约束</strong></p><ol><li>协议相同</li><li>域名相同</li><li>端口号相同</li></ol><p><strong>同源策略限制内容有</strong></p><ul><li>cookie、localstorage、indexedDB 等</li><li>dom节点</li><li>ajax 请求</li></ul><p><strong>不受同源策略影响</strong></p><p>当存在跨域请求时，浏览器的安全策略也不同</p><ul><li><p>post、get、heade等请求，浏览器会自动发送一个跨域请求的预检请求（options）到目标资源的服务器，如果服务器返回的响应满足一定条件，浏览器会继续发送正式的请求，否则会跨域</p></li><li><p>put、delete、等，浏览器会先发送一个预检请求到目标资源的服务器服务器返回的响应满足条件后，浏览器发送正式请求。与简单请求不同的是，非简单请求血药确保服务器在响应中设置了跨域请求所允许的响应首部字段</p></li></ul><p><strong>解决方案</strong></p><ul><li>jsonp</li></ul><p><strong>原理：</strong>利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定 需要对方的服务器做支持才可以</p><p><strong>优缺点：</strong>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题</p><p><strong>缺点：</strong>仅支持get方法 具有局限性, 不安全可能会遭受XSS攻击</p><p>实现流程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;http://www.baidu.com?callback=fn&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">r</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>cors</li></ul><p>服务器端设置 Access-Control-Allow-Origin: 白名单&#x2F;* </p><p>注意：<code>*</code>不能使用cookie</p><ul><li>postMessage</li><li>iframe</li></ul><h2 id="1-2-有什么方法可以保持前后端通信"><a href="#1-2-有什么方法可以保持前后端通信" class="headerlink" title="1.2 有什么方法可以保持前后端通信"></a>1.2 有什么方法可以保持前后端通信</h2><p>实现保持前后端实时通信的方式有以下几种</p><ul><li><p>WebSocket： IE10以上才支持，Chrome16, FireFox11,Safari7以及Opera12以上完全支持，移动端形势大</p></li><li><p>event-source: IE完全不支持（注意是任何版本都不支持），Edge76，Chrome6,Firefox6,Safari5和Opera以上支持， 移动端形势大好</p></li><li><p>AJAX轮询： 用于兼容低版本的浏览器</p></li><li><p>永久帧（ forever iframe）可用于兼容低版本的浏览器</p></li><li><p>flash socket 可用于兼容低版本的浏览器</p></li></ul><p><strong>优缺点</strong></p><ul><li><strong>websocket</strong></li></ul><p><strong>优点：</strong>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，可从HTTP升级而来，浏览器和服务器只需要一次握手，就可以进行持续的，双向的数据传输，因此能显著节约资源和带宽</p><p><strong>缺点：</strong></p><ol><li>兼容问题、</li><li>不支持断线重连，需要手写心跳连接的逻辑</li><li>通信机制相对复杂</li></ol><ul><li><strong>event-source</strong></li></ul><p><strong>优点：</strong></p><ol><li>只需一次请求，便可以stream的方式多次传送数据，节约资源和带宽 </li><li>相对WebSocket来说简单易用</li><li>内置断线重连功能(retry)</li></ol><p><strong>缺点：</strong></p><ol><li>是单向的，只支持服务端-&gt;客户端的数据传送，客户端到服务端的通信仍然依靠AJAX，没有”一家人整整齐齐“的感觉</li><li>兼容性令人担忧，IE浏览器完全不支持</li></ol><ul><li><strong>ajax轮询</strong></li></ul><p><strong>优点：</strong>兼容性良好，对标低版本IE</p><p><strong>缺点：</strong>请求中有大半是无用的请求，浪费资源</p><ul><li><strong>Flash Socket</strong></li></ul><p><strong>优点：</strong> 兼容低版本浏览器</p><p><strong>缺点：</strong></p><ol><li>浏览器开启时flash需要用户确认</li><li>加载时间长，用户体验较差 </li><li>大多数移动端浏览器不支持flash，为重灾区</li></ol><ul><li><strong>永久帧</strong></li></ul><p><strong>缺点：</strong> iframe会产生进度条一直存在的问题，用户体验差</p><p><strong>优点：</strong>兼容低版本IE浏览器</p><p><strong>综上：</strong></p><p><strong>综合兼容性和用户体验的问题，我在项目中选用了WebSocket -&gt;server-sent-event -&gt; AJAX轮询这三种方式做从上到下的兼容</strong></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-1-顺序存储结构和链式存储结构"><a href="#1-1-顺序存储结构和链式存储结构" class="headerlink" title="1.1 顺序存储结构和链式存储结构"></a>1.1 顺序存储结构和链式存储结构</h2><p><strong>优缺点</strong></p><ol><li>顺序存储时，相邻数据元素的存放地址也相邻（逻辑与物理统一）；要求内存中可用存储单元的地址必须是连续的。</li></ol><p>​优点：存储密度大（＝1），存储空间利用率高</p><p>​缺点：插入或删除元素时不方便</p><ol start="2"><li>链式存储时，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针</li></ol><p>​优点：插入或删除元素时很方便，使用灵活</p><p>​缺点：存储密度小（&lt;1），存储空间利用率低</p><p><strong>场景</strong></p><ol><li>顺序表适宜于做查找这样的静态操作</li><li>链表宜于做插入、删除这样的动态操作</li><li>若线性表的长度变化不大，且其主要操作是查找，则采用顺序表</li><li>若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表</li></ol><p><strong>顺序表与链表的比较</strong></p><ul><li><p><strong>基于空间的比较</strong></p><ul><li>存储分配的方式<ul><li>顺序表的存储空间是静态分配的</li><li>链表的存储空间是动态分配的</li></ul></li><li>存储密度 &#x3D; 结点数据本身所占的存储量&#x2F;结点结构所占的存储总量<ul><li>顺序表的存储密度 &#x3D; 1</li><li>链表的存储密度 &lt; 1</li></ul></li></ul></li><li><p><strong>基于时间的比较</strong></p><ul><li>存取方式<ul><li>顺序表可以随机存取，也可以顺序存取</li><li>链表是顺序存取的</li></ul></li><li>插入&#x2F;删除时移动元素个数<ul><li>顺序表平均需要移动近一半元素</li><li>链表不需要移动元素，只需要修改指针</li></ul></li></ul></li></ul><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-1-怎样理解-Vue-的单向数据流？"><a href="#1-1-怎样理解-Vue-的单向数据流？" class="headerlink" title="1.1 怎样理解 Vue 的单向数据流？"></a>1.1 怎样理解 Vue 的单向数据流？</h2><ol><li>数据从父级组件传递给子组件，只能单向绑定</li><li>子组件内部不能直接修改从父级传递过来的数据</li><li>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行，这样会防止从子组件意外改变父级组件的状态， 从而导致你的应用的数据流向难以理解。&#x20;</li><li>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值，这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警 告&#x20;</li><li>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件 修改</li></ol><h2 id="1-2-谈谈你对-Vue-生命周期的理解？"><a href="#1-2-谈谈你对-Vue-生命周期的理解？" class="headerlink" title="1.2 谈谈你对 Vue 生命周期的理解？"></a>1.2 谈谈你对 Vue 生命周期的理解？</h2><p><strong>（1）生命周期是什么？</strong></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期</p><p><strong>（2）各个生命周期的作用</strong></p><table><thead><tr><th align="left">beforeCreate</th><th align="left">组件实例被创建之初，组件的属性生效之前</th></tr></thead><tbody><tr><td align="left">created</td><td align="left">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td align="left">beforeMount</td><td align="left">在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td align="left">mounted</td><td align="left">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td align="left">beforeUpdate</td><td align="left">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td align="left">update</td><td align="left">组件数据更新之后</td></tr><tr><td align="left">activited</td><td align="left">keep-alive 专属，组件被激活时调用</td></tr><tr><td align="left">deadctivated</td><td align="left">keep-alive 专属，组件被销毁时调用</td></tr><tr><td align="left">beforeDestory</td><td align="left">组件销毁前调用</td></tr><tr><td align="left">destoryed</td><td align="left">组件销毁后调用</td></tr></tbody></table><h2 id="1-3-谈谈你对-keep-alive-的了解？"><a href="#1-3-谈谈你对-keep-alive-的了解？" class="headerlink" title="1.3 谈谈你对 keep-alive 的了解？"></a>1.3 谈谈你对 keep-alive 的了解？</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated</li></ul><h2 id="1-4-组件中-data-为什么是一个函数？"><a href="#1-4-组件中-data-为什么是一个函数？" class="headerlink" title="1.4 组件中 data 为什么是一个函数？"></a>1.4 组件中 data 为什么是一个函数？</h2><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响</p><p>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</p><h2 id="1-5-你对vue项目哪些优化？"><a href="#1-5-你对vue项目哪些优化？" class="headerlink" title="1.5 你对vue项目哪些优化？"></a>1.5 你对vue项目哪些优化？</h2><p><strong>（1）代码层面的优化</strong></p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><p><strong>（2）Webpack 层面的优化</strong></p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><p><strong>（3）基础的 Web 技术的优化</strong></p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="1-6-vue中的key有什么作用？"><a href="#1-6-vue中的key有什么作用？" class="headerlink" title="1.6 vue中的key有什么作用？"></a>1.6 vue中的key有什么作用？</h2><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较</p><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><h2 id="1-7-虚拟dom的优缺点"><a href="#1-7-虚拟dom的优缺点" class="headerlink" title="1.7 虚拟dom的优缺点"></a>1.7 虚拟dom的优缺点</h2><p><strong>优点：</strong></p><ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等</li></ul><p><strong>缺点：</strong></p><p>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化:比如动画等等</p><h2 id="1-8-虚拟dom实现原理？"><a href="#1-8-虚拟dom实现原理？" class="headerlink" title="1.8 虚拟dom实现原理？"></a>1.8 虚拟dom实现原理？</h2><p><strong>虚拟 DOM 的实现原理主要包括以下 3 部分：</strong></p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树</li></ul><h2 id="1-9-Vue-是如何实现数据双向绑定的？"><a href="#1-9-Vue-是如何实现数据双向绑定的？" class="headerlink" title="1.9 Vue 是如何实现数据双向绑定的？"></a>1.9 Vue 是如何实现数据双向绑定的？</h2><p>Vue 数据双向绑定主要是指：数据变化更新视图</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View &#x3D;&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data &#x3D;&gt; View 的变化</li></ul><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><ul><li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li><li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新</li><li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函</li><li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理</li></ul><h2 id="1-20-Vue-router-有哪几种路由守卫"><a href="#1-20-Vue-router-有哪几种路由守卫" class="headerlink" title="1.20 Vue-router 有哪几种路由守卫?"></a>1.20 Vue-router 有哪几种路由守卫?</h2><ol><li>全局守卫：beforeEach</li><li>后置守卫：afterEach</li><li>全局解析守卫：beforeResolve</li><li>路由独享守卫：beforeEnter</li></ol><h2 id="1-21-Vue-router-的钩子函数都有哪些"><a href="#1-21-Vue-router-的钩子函数都有哪些" class="headerlink" title="1.21 Vue-router 的钩子函数都有哪些?"></a>1.21 Vue-router 的钩子函数都有哪些?</h2><p>关于 vue-router 中的钩子函数主要分为 3 类</p><ul><li>全局钩子函数要beforeEach 函数有三个参数,分别是&#x20;</li></ul><ol><li>to:router 即将进入的路由对象&#x20;</li><li>from:当前导航即将离开的路由</li><li>next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed （确认的）否则为 false,终止导航</li></ol><ul><li><p>单独路由独享组件<br>beforeEnter</p></li><li><p>组件内钩子&#x20;</p><ol><li>beforeRouterEnter&#x20;</li><li>beforeRouterUpdate&#x20;</li><li>beforeRouterLeave</li></ol></li></ul><h2 id="1-22-vue-router-路由模式有几种？"><a href="#1-22-vue-router-路由模式有几种？" class="headerlink" title="1.22 vue-router 路由模式有几种？"></a>1.22 vue-router 路由模式有几种？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract</p><ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li><li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul><h2 id="1-23-说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#1-23-说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="1.23 说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>1.23 说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><p><strong>（1）hash 模式的实现原理</strong></p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</li></ul><p><strong>（2）history 模式的实现原理</strong></p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）</li></ul><h2 id="1-24-vuex-包括几个模块"><a href="#1-24-vuex-包括几个模块" class="headerlink" title="1.24 vuex 包括几个模块"></a>1.24 vuex 包括几个模块</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ul><h2 id="1-25-Object-defineProperty-和-Proxy-的区别"><a href="#1-25-Object-defineProperty-和-Proxy-的区别" class="headerlink" title="1.25 Object.defineProperty 和 Proxy 的区别"></a>1.25 Object.defineProperty 和 Proxy 的区别</h2><p>Object.defineProperty 和 Proxy 的区别如下:</p><ol><li>Proxy 可以直接监听对象而非属性；&#x20;</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等 是 Object.defineProperty 不具备的&#x20;</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准 的性能红利&#x20;</li><li>Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题, 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重 写</li></ol><h2 id="1-26-MVVM-和-MVC-区别是什么？哪些场景适合？"><a href="#1-26-MVVM-和-MVC-区别是什么？哪些场景适合？" class="headerlink" title="1.26 MVVM 和 MVC 区别是什么？哪些场景适合？"></a>1.26 MVVM 和 MVC 区别是什么？哪些场景适合？</h2><p><strong>1、基本定义</strong>&#x20;</p><p>MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型，模型（Model） 指的是后端传递的数据，视图(View)指的是所看到的页面，视图模型(ViewModel)是 mvvm 模式 的核心，它是连接 view 和 model 的桥梁。它有两个方向：&#x20;</p><ol><li>一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到 的页面，实现的方式是：数据绑定</li><li>二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。 实现的方式是：DOM 事件监听，这两个方向都实现的，我们称之为数据的双向绑定</li><li>MVC 基本定义 MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑，使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启 下&#x20;</li></ol><p><strong>2、使用场景</strong></p><p>&#x20;主要就是 MVC 中 Controller 演变成 MVVM 中的 viewModel，MVVM 主要解决了 MVC中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验，vue 数据驱动，通 过数据来显示视图层而不是节点操作， 场景：数据操作比较多的场景，需要大量操作 DOM 元 素时，采用 MVVM 的开发方式，会更加便捷，让开发者更多的精力放在数据的变化上，解放繁 琐的操作 DOM 元素</p><p><strong>3、两者之间的区别</strong></p><p>&#x20;MVC 和 MVVM 其实区别并不大，都是一种设计思想， MVC 和 MVVM 的区别并不是VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念， ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图 操作业务等还是应该放在 Controller 中实现，也就是说 MVVM 实现的是业务逻辑组件的重用， 使开发更高效，结构更清晰，增加代码的复用性</p><h2 id="1-27-vue-中如何重置-data"><a href="#1-27-vue-中如何重置-data" class="headerlink" title="1.27 vue 中如何重置 data?"></a>1.27 vue 中如何重置 data?</h2><p>要初始化 data 中的数据，可以使用 Object.assign()方法，实现重置 data 中的数据，以下就是对该方法的详细介绍，以及如何使用该方法，重置 data 中的数据</p><ol><li>Object.assign()方法基本定义&#x20;</li><li>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目 标对象。它将返回目标对象。</li><li>用法： Object.assign(target, …sources)，第一个参数是目标对象，第二个参数 是源对象，就是将源对象属性复制到目标对象，返回目标对象</li></ol><h2 id="1-28-vue3-新特性有哪些？"><a href="#1-28-vue3-新特性有哪些？" class="headerlink" title="1.28 vue3 新特性有哪些？"></a>1.28 vue3 新特性有哪些？</h2><p>1、性能提升</p><ul><li>响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快，消除警告。</li><li>重写了 Vdom ，突破了 Vdom 的性能瓶颈。</li><li>进行模板编译优化。</li><li>更加高效的组件初始化</li></ul><p>2、更好的支持 typeScript</p><ul><li>有更好的类型推断，使得 Vue3 把 typeScript 支持得非常好</li></ul><p>3、新增Composition API</p><ul><li>Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强</li></ul><p>4、新增组件</p><ul><li>Fragment 不再限制 template 只有一个根几点。</li><li>Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。</li><li>Supense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。</li></ul><p>5、Tree-shaking：支持摇树优化</p><ul><li>摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快</li></ul><p>6、Custom Renderer API： 自定义渲染器</p><ul><li>实现 DOM 的方式进行 WebGL 编程</li></ul><h2 id="1-29-vue3-组合式API生命周期钩子函数有变化吗"><a href="#1-29-vue3-组合式API生命周期钩子函数有变化吗" class="headerlink" title="1.29 vue3 组合式API生命周期钩子函数有变化吗?"></a>1.29 vue3 组合式API生命周期钩子函数有变化吗?</h2><p>setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显示的定义它们。其他的钩子都可以编写到 setup 内</p><h2 id="1-30-watch-和-watchEffect-的区别？"><a href="#1-30-watch-和-watchEffect-的区别？" class="headerlink" title="1.30 watch 和 watchEffect 的区别？"></a>1.30 watch 和 watchEffect 的区别？</h2><p>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。它们之间的区别有：</p><ol><li>watch 需要传入监听的数据源，而 watchEffect 可以自动手机数据源作为依赖。</li><li>watch 可以访问倒改变之前和之后的值，watchEffect 只能获取改变后的值。</li><li>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。</li></ol><h2 id="1-31-vue中v-if和v-for优先级在vue2和vue3中的区别"><a href="#1-31-vue中v-if和v-for优先级在vue2和vue3中的区别" class="headerlink" title="1.31 vue中v-if和v-for优先级在vue2和vue3中的区别"></a>1.31 vue中v-if和v-for优先级在vue2和vue3中的区别</h2><p>实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。</p><ul><li>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。</li><li>在 vue 3.x 中， v-if 总是优先于 v-for 生效。</li><li>vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。</li><li>vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常</li></ul><h2 id="1-32-script-setup-是干啥的？"><a href="#1-32-script-setup-是干啥的？" class="headerlink" title="1.32 script setup 是干啥的？"></a>1.32 script setup 是干啥的？</h2><p>scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：</p><ul><li>属性和方法无需返回，可以直接使用。</li><li>引入组件的时候，会自动注册，无需通过 components 手动注册。</li><li>使用 defineProps 接收父组件传递的值。</li><li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。</li><li>默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。</li></ul><h2 id="1-33-vue常用的修饰符"><a href="#1-33-vue常用的修饰符" class="headerlink" title="1.33 vue常用的修饰符"></a>1.33 vue常用的修饰符</h2><ul><li>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</li><li>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；作用是阻止默认事件（例如a标签的跳转</li><li>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</li><li>.self ：只会触发自己范围内的事件，不包含子元素；</li><li>.once ：只会触发一次。</li><li>.trim修饰符的作用是把v-model绑定的值的首尾空格给去掉。在实际开发中我们一般用于搜索框的内容修饰，过滤掉用户多输入前后空格导致内容查不出来的情况。</li><li>.left，.right，.middle这三个修饰符是鼠标的左中右按键触发的事件.</li></ul><h2 id="1-34-vue2-0-和-vue3-0-有什么区别？-双向绑定更新"><a href="#1-34-vue2-0-和-vue3-0-有什么区别？-双向绑定更新" class="headerlink" title="1.34 vue2.0 和 vue3.0 有什么区别？ 双向绑定更新"></a>1.34 vue2.0 和 vue3.0 有什么区别？ 双向绑定更新</h2><p>vue2 的双向数据绑定是利⽤ES5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持 结合 发布订阅模式的⽅式来实现的。</p><p>vue3 中使⽤了 ES6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。</p><p>这⾥是相⽐于vue2版本，使⽤proxy的优势如下</p><ol><li><p>defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</p></li><li><p>监听数组，不⽤再去单独的对数组做特异性操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美⽀持对数组的监听。</p></li></ol><p><strong>获取props</strong></p><p>vue2在script代码块可以直接获取props，vue3通过setup指令传递</p><p><strong>API不同</strong></p><p>Vue2使⽤的是选项类型API（Options API），Vue3使⽤的是合成型API（Composition API）</p><p><strong>建立数据data</strong></p><p>vue2是把数据放入data中，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造得时候触发。</p><p><strong>生命周期不同</strong></p><table><thead><tr><th>vue2</th><th>vue3</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup() 开始创建组件之前，创建的是data和method</td></tr><tr><td>created</td><td>setup()</td></tr><tr><td>beforeMount</td><td>onBeforeMount 组件挂载到节点上之前执行的函数</td></tr><tr><td>mounted</td><td>onMounted 组件挂载完成后执行的函数</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate 组件更新之前执行的函数</td></tr><tr><td>updated</td><td>onUpdated 组件更新完成之后执行的函数</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount 组件挂载到节点上之前执行的函数</td></tr><tr><td>destroyed</td><td>onUnmounted 组件卸载之前执行的函数</td></tr><tr><td>activated</td><td>onActivated 组件卸载完成后执行的函数</td></tr><tr><td>deactivated</td><td>onDeactivated</td></tr></tbody></table><p><strong>关于v-if和v-for的优先级:</strong></p><p>vue2 在一个元素上同时使用 v-if 和 v-for  v-for会优先执行</p><p>vue3 v-if 总会优先于  v-for生效</p><p><strong>vue2和vue3的diff算法</strong></p><p><strong>vue2</strong></p><p>vue2 diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点 不同的地方，最后用patch记录的消息去局部更新Dom。</p><p>vue2 diff算法会比较每一个vnode,而对于一些不参与更新的元素，进行比较是有 点消耗性能的。</p><p><strong>vue3</strong></p><p>vue3 diff算法在初始化的时候会给每个虚拟节点添加一个patchFlags，patchFlags 就是优化的标识。</p><p>只会比较patchFlags发生变化的vnode,进行更新视图，对于没有变化的元素做静 态标记，在渲染的时候直接复用。</p><h2 id="1-35-reactive与ref的区别？"><a href="#1-35-reactive与ref的区别？" class="headerlink" title="1.35 reactive与ref的区别？"></a>1.35 reactive与ref的区别？</h2><p>Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。</p><p>ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。</p><p>reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。</p><h2 id="1-36-route-和-router-的区别？"><a href="#1-36-route-和-router-的区别？" class="headerlink" title="1.36 $route 和 $router 的区别？"></a>1.36 $route 和 $router 的区别？</h2><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p><p>$router 是“路由实例”想要导航到不同URL 对象包括了路由的跳转方法，钩子函数等。</p><h2 id="1-37-v-on可以监听多个方法吗？"><a href="#1-37-v-on可以监听多个方法吗？" class="headerlink" title="1.37 v-on可以监听多个方法吗？"></a>1.37 v-on可以监听多个方法吗？</h2><p>可以一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p><p><code>&lt;a&gt;</code>doSomething <code>&lt;/a&gt;</code></p><p>在method方法里面分别写两个事件；</p><p>&lt;button @click&#x3D;”a(),b()”&gt;点我ab&lt;&#x2F;button&gt;</p><h2 id="1-38-v-model的使用？"><a href="#1-38-v-model的使用？" class="headerlink" title="1.38 v-model的使用？"></a>1.38 v-model的使用？</h2><p>v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.</p><p>V-model的原理：</p><ul><li><p>v-bind绑定一个value属性</p></li><li><p>v-on指令给当前元素绑定input事件</p></li></ul><p>可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体</p><p>组件上的双向绑定（原理）</p><p>v-model绑定在组件上的时候做了以下步骤</p><ul><li>在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性</li><li>子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。</li><li>子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值</li><li>v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上</li></ul><h2 id="1-39-vue遇到的坑，如何解决的？"><a href="#1-39-vue遇到的坑，如何解决的？" class="headerlink" title="1.39 vue遇到的坑，如何解决的？"></a>1.39 vue遇到的坑，如何解决的？</h2><ul><li>用webpack打包后访问index.html出现资源加载404问题，解决：开发环境的static文件夹是基于根目录的，所以直接用‘&#x2F;’ 。</li><li>vue中，假如，你引入某个样式，然后这个样式里面有引用到图片，如果你的文件中没有这个图片，这时候，即使你没有引用这个图片对应的类名，但是只要你有引入这个css文件，他找不到相应路径图片也会报错！！！</li><li>用for循环出来的列表，在设置列表中的元素的动态属性时，需要加bind属性“：”，不然动态属性设置不出来</li><li>在vue中的html中的img中的src不可以直接设置为变量，在data里面直接引路径，只能通过import的形式引入,值得注意的是，引用这个方式的时候src是变量需要加“：”，不然会报错！！！！！</li><li>在中使用v-for&#x3D;”(item ,index) in list”进行循环时，需要注意加：:key&#x3D;“index”,不然会出现警告！</li><li>父组件ajax异步更新数据，子组件props获取不到</li></ul><p>应用场景</p><p>当父组件  axjos  获取数据，子组件使用  props  接收数据时，执行  mounted  的时候  axjos  还没有返回数据，而且  mounted 只执行一次，这时   props  中接收的数据为空</p><p>解决方案：在对应组件中判断数据的长度</p><h2 id="1-40-说说vue中的diff算法？"><a href="#1-40-说说vue中的diff算法？" class="headerlink" title="1.40 说说vue中的diff算法？"></a>1.40 说说vue中的diff算法？</h2><p>diff算法 当data发生改变 会根据新的数据生成一个新的虚拟dom ，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法。</p><p>Vue2 是全量 Diff（当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。）；Vue3 是静态标记 + 非全量 Diff（Vue 3在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。）</p><p>使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作</p><h2 id="1-41-vue中怎么设置全局变量和全局组件？"><a href="#1-41-vue中怎么设置全局变量和全局组件？" class="headerlink" title="1.41 vue中怎么设置全局变量和全局组件？"></a>1.41 vue中怎么设置全局变量和全局组件？</h2><p>在main.js中</p><p>app.config.globalProperties.$key &#x3D; ‘’ &#x2F;&#x2F;定义全局变量</p><p>import {getCurrentInstance} from ‘vue’;</p><p>  setup(){</p><p>    const { proxy } &#x3D; getCurrentInstance();</p><p>    console.log(proxy.$key);</p><p>  }</p><h2 id="1-45-vue中给对象添加新属性时，界面不刷新怎么办"><a href="#1-45-vue中给对象添加新属性时，界面不刷新怎么办" class="headerlink" title="1.45 vue中给对象添加新属性时，界面不刷新怎么办?"></a>1.45 vue中给对象添加新属性时，界面不刷新怎么办?</h2><p>vue2的响应式原理使用的是对象代理去实现的,对象代理中有一个get和set方法,当我们访问对象的时候就会触发get方法,当我们对对象中的值进行修改时会触发set方法。但是当我们给对象添加一个新的属性时对象代理是检测不到的,所以就会出现直接给对象添加属性响应式不生效的问题。</p><p>所以在vue中可以使用this.$set(对象名,‘属性名’,属性值)的方法去给对象添加属性,或者使用Vue.set(对象名,‘属性名’,属性值)的方法进行添加,添加之后的属性就带有响应式了</p><h2 id="1-46-vuex中的辅助函数怎么使用？"><a href="#1-46-vuex中的辅助函数怎么使用？" class="headerlink" title="1.46 vuex中的辅助函数怎么使用？"></a>1.46 vuex中的辅助函数怎么使用？</h2><p>vuex的辅助函数有4个</p><ul><li>mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。</li><li>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他</li><li>mapMutations 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.$store.commit(‘montify’)</li><li>mapActions在组件中使用 this.$store.dispatch(‘prodect’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用</li></ul><h2 id="1-47-刷新浏览器后，Vuex的数据是否存在？如何解决？"><a href="#1-47-刷新浏览器后，Vuex的数据是否存在？如何解决？" class="headerlink" title="1.47 刷新浏览器后，Vuex的数据是否存在？如何解决？"></a>1.47 刷新浏览器后，Vuex的数据是否存在？如何解决？</h2><p>原因：因为 store 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。</p><p>localStorage 或者就是sessionStorage</p><p>下载持久化存储插件。比如使用：vuex-along 的实质也是将 vuex 中的数据存放到 localStorage 或者 sessionStroage 中，只不过这个存取过程组件会帮我们完成，我们只需要用vuex的读取数据方式操作就可以了</p><h2 id="x20-1-48-vue路由跳转传参的方式有哪些？"><a href="#x20-1-48-vue路由跳转传参的方式有哪些？" class="headerlink" title="&#x20;1.48 vue路由跳转传参的方式有哪些？"></a>&#x20;1.48 vue路由跳转传参的方式有哪些？</h2><p><strong>params传参(显示参数)</strong></p><ul><li>在url中会显示出传参的值，刷新页面不会失去拿到的参数，使用该方式传值的时候，需要子路由提前配置好参数</li></ul><p><strong>params传参(不显示参数)</strong></p><ul><li>在url中不会显示出传参的值，但刷新页面会失去拿到的参数，使用该方式 传值 的时候，需要子路由提前配置好name参数</li></ul><p><strong>query 传参</strong></p><ul><li>query 传过去的参数会拼接在地址栏中（?name&#x3D;xx），刷新页面数据不会丢失，使用path和name都可以</li></ul><p><strong>VUE几种路由跳转几种方式的区别</strong></p><ul><li>this.$router.push：跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面</li><li>this.$router.replace：跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)</li><li>this.$router.go(n)：向前或者向后跳转n个页面，n可为正整数或负整数</li></ul><h2 id="1-50-单页面应用和多页面应用区别及优缺点？"><a href="#1-50-单页面应用和多页面应用区别及优缺点？" class="headerlink" title="1.50 单页面应用和多页面应用区别及优缺点？"></a>1.50 单页面应用和多页面应用区别及优缺点？</h2><p><strong>单页面</strong>：顾名思义，只有一个页面。一般是一个主页和多个路由页面组成。</p><p>优点：</p><ul><li>公共资源不重新加载，局部加载，服务器压力小</li><li>切换速度快，用户体验好</li><li>前后端分离</li></ul><p>缺点：</p><ul><li>不利于SEO（可以优化：比如路由懒加载等）</li><li>初次加载时耗时多</li><li>开发难度较大（相对多页面）</li></ul><p><strong>多页面</strong>（Multi Page Application——MPA）：有多个HTML页面，跳转的时候是从一个html页面跳到另一个页面。</p><p>优点：</p><ul><li>利于SEO。</li><li>更容易扩展。</li><li>更易数据分析。</li></ul><p>缺点：</p><ul><li>开发成本高。</li><li>服务器压力大。</li><li>用户体验相对较差。</li></ul><h2 id="1-51-EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"><a href="#1-51-EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？" class="headerlink" title="1.51 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"></a>1.51 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？</h2><ul><li><p>添加Bus.$off来关闭</p><p>beforeDestroy () {</p><p>bus.$off(‘get’, this.myhandle)</p><p>}</p></li><li><p>如果想要用bus 来进行页面组件之间的数据传递，需要注意亮点，组件emit事件应在beforeDestory声明周期内。其次，组件B内的$on记得要销毁。&#x20;</p></li></ul><h2 id="1-52-自定义指令详解"><a href="#1-52-自定义指令详解" class="headerlink" title="1.52 自定义指令详解"></a>1.52 自定义指令详解</h2><p>为什么需要自定义指令：因为vue是MVVM模式，只需要关注于数据和业务逻辑，不需要关注DOM的操作，但是有时候面对一些特殊的业务需求时，需要进行DOM的操作，这个时候就需要进行自定义指令。</p><p>自定义局部指令:在options api选项中的directives中设置。局部自定义指令是一个对象，对象的属性是自定义指令的名称，对象中属性的值是自定义指令的钩子函数对象</p><p>自定义全局指令:在app的directive方法。参数一（name）：自定义指令的名称。参数二（hooks）：自定义指令的钩子函数对象</p><h2 id="1-53-slot是什么？有什么作用？原理是什么？"><a href="#1-53-slot是什么？有什么作用？原理是什么？" class="headerlink" title="1.53 slot是什么？有什么作用？原理是什么？"></a>1.53 slot是什么？有什么作用？原理是什么？</h2><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p><p><strong>slot又分三类，默认插槽，具名插槽和作用域插槽。</strong></p><ul><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p><strong>实现原理：</strong></p><p>当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default具名插槽为vm.$slot.xxx，xxx 为插槽名</p><p>当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽</p><h2 id="1-54-nextTick的使用"><a href="#1-54-nextTick的使用" class="headerlink" title="1.54 $nextTick的使用"></a>1.54 $nextTick的使用</h2><p>用法：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><p><strong>$nextTick() 的应用场景</strong></p><p>在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 $nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p><p>mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题</p><p>在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 $nextTick() 的回调函数中。</p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="1-1-虚拟dom和真实dom"><a href="#1-1-虚拟dom和真实dom" class="headerlink" title="1.1 虚拟dom和真实dom"></a>1.1 虚拟dom和真实dom</h2><p><strong>什么是虚拟dom？</strong></p><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom操作，从而 提高性能。</p><ol><li>用 JavaScript 对象结构表示 DOM 树的结构</li><li>用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。</li><li>用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的DOM 树上，视图就更新了。</li></ol><p><strong>虚拟dom和real dom区别 性能差异</strong></p><p>减少DOM的操作：虚拟dom可以将多次操作合并为一次操作，减少DOM操作的次数</p><table><thead><tr><th><strong>Real DOM</strong></th><th><strong>Virtual DOM</strong></th></tr></thead><tbody><tr><td>更新缓慢</td><td>更新更快</td></tr><tr><td>可以直接更新 HTML</td><td>无法直接更新 HTML</td></tr><tr><td>如果元素更新，则创建新DOM</td><td>如果元素更新，则更新 JSX</td></tr><tr><td>DOM操作代价很高</td><td>DOM 操作非常简单</td></tr><tr><td>消耗的内存较多</td><td>很少的内存消耗</td></tr></tbody></table><h2 id="1-2-react组件间通信"><a href="#1-2-react组件间通信" class="headerlink" title="1.2 react组件间通信"></a>1.2 <strong>react组件间通信</strong></h2><ul><li><p>父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯</p></li><li><p>子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</p></li><li><p>兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</p></li><li><p>跨层级通信: Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言</p></li><li><p>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信</p></li><li><p>全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态</p></li></ul><h2 id="1-3-redux的原理"><a href="#1-3-redux的原理" class="headerlink" title="1.3 redux的原理"></a>1.3 <strong>redux的原理</strong></h2><p><strong>Redux</strong>：Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为</p><p><strong>数据流</strong></p><ol><li><p>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</p></li><li><p>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</p></li><li><p>State一旦有变化，Store就会调用监听函数，来更新View</p></li></ol><p><strong>Redux遵循的三个原则是什么</strong></p><ol><li><p>单一事实来源：整个应用的状态存储在单个 store 中的对象&#x2F;状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。</p></li><li><p>状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像state 是数据的最小表示一样，该操作是对数据更改的最小表示。</p></li><li><p>使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</p></li></ol><p><strong>单一事实来源怎么理解？</strong></p><p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p><p><strong>组件组成</strong></p><ol><li><strong>Action</strong> – 这是一个用来描述发生了什么事情的对象</li><li><strong>Reducer</strong> – 这是一个确定状态将如何变化的地方</li><li><strong>Store</strong> – 整个程序的状态&#x2F;对象树保存在Store中</li><li><strong>View</strong> – 只显示 Store 提供的数据</li></ol><p><strong>如何在</strong> <strong>Redux</strong> <strong>中定义</strong> <strong>Action？</strong></p><p>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建</p><p><strong>解释</strong> <strong>Reducer</strong> <strong>的作用</strong></p><p>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。</p><p><strong>Store</strong> <strong>在</strong> <strong>Redux</strong> <strong>中的意义是什么？</strong></p><p>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态&#x2F;对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</p><p><strong>Redux</strong> <strong>有哪些优点？</strong></p><ul><li>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题</li><li>可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构</li><li>服务器端渲染 - 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验</li><li>开发人员工具 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情</li><li>社区和生态系统 - Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用</li><li>易于测试 - Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立</li><li>组织 - Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单</li></ul><h2 id="1-4-React组件生命周期的阶段是什么？"><a href="#1-4-React组件生命周期的阶段是什么？" class="headerlink" title="1.4 React组件生命周期的阶段是什么？"></a>1.4 <strong>React组件生命周期的阶段是什么？</strong></h2><ol><li><p>初始渲染阶段：这是组件即将开始其生命之旅并进入 DOM 的阶段。</p></li><li><p>更新阶段：一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。</p></li><li><p>卸载阶段：这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。</p></li></ol><h2 id="1-5-详细解释React-组件的生命周期方法"><a href="#1-5-详细解释React-组件的生命周期方法" class="headerlink" title="1.5 详细解释React 组件的生命周期方法"></a>1.5 <strong>详细解释React 组件的生命周期方法</strong></h2><p><strong>挂载阶段:</strong></p><ul><li><p>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</p></li><li><p>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState) ,这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps</p></li><li><p>render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</p></li><li><p>componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅</p></li></ul><p><strong>更新阶段:</strong></p><ul><li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li><li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState) ,有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能</li><li>render: 更新阶段也会触发此生命周期</li><li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState) ,这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</li><li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot) ,该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态</li></ul><p><strong>卸载阶段:</strong></p><ul><li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</li></ul><p><strong>扩展：</strong></p><p>React 16之后有三个生命周期被废弃(但并未删除)</p><ul><li><p>componentWillMount</p></li><li><p>componentWillReceiveProps</p></li><li><p>componentWillUpdate</p></li></ul><p>官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们</p><h2 id="1-6-router"><a href="#1-6-router" class="headerlink" title="1.6 router"></a>1.6 router</h2><ol><li>什么是React 路由？</li></ol><p>React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。</p><ol start="2"><li>为什么需要 React 中的路由？</li></ol><p>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路</p><p>由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个</p><p>Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</p><ol start="3"><li>为什么React Router v4中使用 switch 关键字 ？</li></ol><p>虽然 <div> 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路</p><p>线时，可以使用 “switch” 关键字。使用时， <switch> 标记会按顺序将已定义的 URL 与已定义的</p><p>路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。</p><ol start="4"><li>列出 React Router 的优点</li></ol><p>​4.1 就像 React 基于组件一样，在 React Router v4 中，API 是 ‘All About Components’。可以将Router 可视化为单个根组件（），其中我们将特定的子路由（）包起来。</p><p>​4.2 无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 组件中。</p><p>​4.3 包是分开的：共有三个包，分别用于 Web、Native 和 Core。这使我们应用更加紧凑。基于类似的编码风格很容易进行切换。</p><h2 id="1-7-React-的-refs-有什么了解？"><a href="#1-7-React-的-refs-有什么了解？" class="headerlink" title="1.7 React 的 refs 有什么了解？"></a>1.7 React <strong>的</strong> <strong>refs</strong> 有什么了解？</h2><p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ReferenceDemo extends React.Component&#123;</span><br><span class="line">    display() &#123;</span><br><span class="line">        const name = this.inputDemo.value;</span><br><span class="line">        document.getElementById(&#x27;disp&#x27;).innerHTML = name;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            Name: &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.inputDemo = input&#125; /&gt;</span><br><span class="line">            &lt;button name=&quot;Click&quot; onClick=&#123;this.display&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">            &lt;h2&gt;Hello &lt;span id=&quot;disp&quot;&gt;&lt;/span&gt; !!!&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-列出一些应该使用-Refs-的情况"><a href="#1-8-列出一些应该使用-Refs-的情况" class="headerlink" title="1.8 列出一些应该使用 Refs 的情况"></a>1.8 列出一些应该使用 Refs 的情况</h2><p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p><p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用event.preventDefault</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230810214434062.png" alt="image-20230810214434062"></p><h2 id="1-9-redux-saga和mobx的比较"><a href="#1-9-redux-saga和mobx的比较" class="headerlink" title="1.9 redux-saga和mobx的比较"></a>1.9 redux-saga和mobx的比较</h2><ol><li><strong>状态管理</strong></li></ol><ul><li><p>redux-sage 是 redux 的一个异步处理的中间件。</p></li><li><p>mobx 是数据管理库，和 redux 一样。</p></li></ul><ol start="2"><li><strong>设计思想</strong></li></ol><ul><li><p>redux-sage 属于 flux 体系， 函数式编程思想。</p></li><li><p>mobx 不属于 flux 体系，面向对象编程和响应式编程。</p></li></ul><ol start="3"><li><strong>主要特点</strong></li></ol><ul><li><p>redux-sage 因为是中间件，更关注异步处理的，通过 Generator 函数来将异步变为同步，使代码可读性高，结构清晰。action 也不是 action creator 而是 pure action，在 Generator 函数中通过 call 或者 put 方法直接声明式调用，并自带一些方法，如 takeEvery，takeLast，race等，控制多个异步操作，让多个异步更简单。</p></li><li><p>mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。</p></li></ul><ol start="4"><li><strong>数据可变性</strong></li></ol><ul><li><p>redux-sage 强调 state 不可变，不能直接操作 state，通过 action 和 reducer 在原来的 state 的基础上返回一个新的 state 达到改变 state 的目的。</p></li><li><p>mobx 直接在方法中更改 state，同时所有使用的 state 都发生变化，不生成新的 state。</p></li></ul><ol start="5"><li><strong>写法难易度</strong></li></ol><ul><li><p>redux-sage 比 redux 在 action 和 reducer 上要简单一些。需要用 dispatch 触发 state 的改变，需要 mapStateToProps 订阅 state。</p></li><li><p>mobx 在非严格模式下不用 action 和 reducer，在严格模式下需要在 action 中修改 state，并且自动触发相关依赖的更新。</p></li></ul><ol start="6"><li><strong>使用场景</strong></li></ol><ul><li><p>redux-sage 很好的解决了 redux 关于异步处理时的复杂度和代码冗余的问题，数据流向比较好追踪。但是 redux 的学习成本比 较高，代码比较冗余，不是特别需要状态管理，最好用别的方式代替。</p></li><li><p>mobx 学习成本低，能快速上手，代码比较简洁。但是可能因为代码编写的原因和数据更新时相对黑盒，导致数据流向不利于追踪。</p></li></ul><h2 id="1-10-简述一下-React-的源码实现"><a href="#1-10-简述一下-React-的源码实现" class="headerlink" title="1.10 简述一下 React 的源码实现"></a>1.10 简述一下 <strong>React</strong> 的源码实现</h2><ol><li><p>React 的实现主要分为 Component 和 Element ；</p></li><li><p>Component 属于 React 实例，在创建实例的过程中会在实例中注册 state 和 props 属性，还会依次调用内置的生命周期函数；</p></li><li><p>Component 中有一个 render 函数， render 函数要求返回一个 Element 对象（或 null ）；</p></li><li><p>Element 对象分为原生 Element 对象和组件式对象，原生 Element + 组件式对象会被一起解析成虚拟 DOM 树，并且内部使用的 state 和 props 也以 AST 的形式注入到这棵虚拟 DOM 树之中；</p></li><li><p>在渲染虚拟 DOM 树的前后，会触发 React Component 的一些生命周期钩子函数，比如componentWillMount 和 componentDidMount ，在虚拟 DOM 树解析完成后将被渲染成真实DOM 树；</p></li><li><p>调用 setState 时，会调用更新函数更新 Component 的 state ，并且触发内部的一个updater ，调用 render 生成新的虚拟 DOM 树，利用 diff 算法与旧的虚拟 DOM 树进行比对，比对以后利用最优的方案进行 DOM 节点的更新，这也是 React 单向数据流的原理（与 Vue 的MVVM 不同之处）。</p></li></ol><h2 id="1-11-setState到底是异步还是同步"><a href="#1-11-setState到底是异步还是同步" class="headerlink" title="1.11 setState到底是异步还是同步"></a>1.11 setState到底是异步还是同步</h2><p>有时表现出异步,有时表现出同步</p><ol><li><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</p></li><li><p>setState 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback)中的 callback 拿到更新后的结果。</p></li><li><p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p></li></ol><h2 id="1-12-redux异步中间件之间的优劣"><a href="#1-12-redux异步中间件之间的优劣" class="headerlink" title="1.12  redux异步中间件之间的优劣?"></a>1.12  redux异步中间件之间的优劣?</h2><p><strong>redux-thunk优点:</strong></p><ul><li><p>体积小: redux-thunk的实现方式很简单,只有不到20行代码</p></li><li><p>使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单</p></li></ul><p><strong>redux-thunk缺陷:</strong></p><ul><li><p>样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的</p></li><li><p>耦合严重: 异步操作与redux的action偶合在一起,不方便管理</p></li><li><p>功能孱弱: 有一些实际开发中常用的功能需要自己进行封装</p></li></ul><p><strong>redux-saga优点:</strong></p><ul><li><p>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中</p></li><li><p>action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function</p></li><li><p>异常处理: 受益于 generator function 的 saga 实现，代码异常&#x2F;请求失败 都可以直接通过try&#x2F;catch 语法直接捕获处理</p></li><li><p>功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用</p></li><li><p>灵活: redux-saga可以将多个Saga可以串行&#x2F;并行组合起来,形成一个非常实用的异步flow</p></li><li><p>易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等</p></li></ul><p><strong>redux-saga缺陷:</strong></p><ul><li><p>额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想</p></li><li><p>体积庞大: 体积略大,代码近2000行，min版25KB左右</p></li><li><p>功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码</p></li><li><p>ts支持不友好: yield无法返回TS类型</p></li></ul><p><strong>redux-observable优点:</strong></p><ul><li><p>功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理</p></li><li><p>背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着</p></li><li><p>rxjs的升级redux-observable也会变得更强大</p></li></ul><p><strong>redux-observable缺陷:</strong></p><ul><li><p>学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库</p></li><li><p>社区一般: redux-observable的下载量只有redux-saga的1&#x2F;5,社区也不够活跃,在复杂异步流中间件</p></li><li><p>这个层面redux-saga仍处于领导地位</p></li></ul><h2 id="1-13-state-和-props-区别是啥？"><a href="#1-13-state-和-props-区别是啥？" class="headerlink" title="1.13 state 和 props 区别是啥？"></a>1.13 state <strong>和</strong> props 区别是啥？</h2><p>props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</p><ul><li>state 是组件自己管理数据，控制自己的状态，可变</li><li>props 是外部传入的数据参数，不可变；</li><li>没有state的叫做无状态组件，有state的叫做有状态组件；</li><li>多用 props，少用 state，也就是多写无状态组件。</li></ul><h2 id="1-14-当调用setState时，React-render-是如何工作的？"><a href="#1-14-当调用setState时，React-render-是如何工作的？" class="headerlink" title="1.14  当调用setState时，React render 是如何工作的？"></a>1.14  当调用setState时，React render 是如何工作的？</h2><ul><li><p>虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下React 是没有优化的。</p></li><li><p>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</p></li></ul><h2 id="1-15-hooks"><a href="#1-15-hooks" class="headerlink" title="1.15 hooks"></a>1.15 hooks</h2><h3 id="Hooks简介"><a href="#Hooks简介" class="headerlink" title="Hooks简介"></a>Hooks简介</h3><p>React的组件创建方式，一种是类组件，一种是纯函数组件</p><ul><li>纯函数组件没有状态</li><li>纯函数组件没有生命周期</li><li>纯函数组件没有this</li></ul><p><strong>使用Hooks的优点：</strong></p><ul><li>告别难以理解的Class( this 和 生命周期 的痛点)</li><li>解决业务逻辑难以拆分的问题</li><li>使状态逻辑复用变得简单可行</li><li>函数组件从设计思想上来看更加契合React的理念</li></ul><p><strong>Hooks并非万能</strong>:</p><ul><li>Hooks暂时还不能完全的为函数组件补齐类组件地能力（如生命周期的getSnapshotBeforeUpdate、componentDidCatch方法暂时还未实现）</li><li>将类组件的复杂变成函数组件的轻量，可能使用者并不能很好地消化这种复杂</li><li>Hooks在使用层面有着严格地规则约束</li></ul><h3 id="Hook函数（9种）"><a href="#Hook函数（9种）" class="headerlink" title="Hook函数（9种）"></a>Hook函数（9种）</h3><ol><li>useState()：状态钩子</li><li>useContext()：共享状态钩子</li><li>useEffect()：副作用钩子</li><li>useReducer()：Action钩子</li><li>userRefef()：Ref Hook可以<strong>在函数组件中存储、查找组件内的标签或任意其它数据</strong></li><li>useMemo()： 主要<strong>用来解决使用React hooks产生的无用渲染的性能问题</strong></li><li>useCallback()： 主要<strong>是为了性能的优化</strong></li><li>useLayoutEffect() ：和useEffect相同，<strong>都是用来执行副作用，但是它会在所有的DOM变更之后同步调用effect</strong>。useLayoutEffect和useEffect最大的区别就是一个是同步，一个是异步。</li><li>useImperativeHandle()： 可以<strong>在使用 ref 时自定义暴露给父组件的实例值。</strong></li></ol><h3 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h3><p><strong>自定义 Hooks：是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook</strong></p><p><strong>自定义Hooks：可以封装状态，能够更好的实现状态共享</strong></p><h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><h2 id="1-1-前端为什么要进行打包和构建"><a href="#1-1-前端为什么要进行打包和构建" class="headerlink" title="1.1 前端为什么要进行打包和构建"></a>1.1 前端为什么要进行打包和构建</h2><ol><li>体积更小（Tree-Shaking、压缩、合并），加载更快</li><li>编译高级语言和语法（TS，ES6+，模块化，scss）</li><li>兼容性和错误检查（Polyfill、postcss、eslint)</li><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ol><h2 id="1-2-如何提高webpack的构建速度"><a href="#1-2-如何提高webpack的构建速度" class="headerlink" title="1.2 如何提高webpack的构建速度"></a>1.2 如何提高webpack的构建速度</h2><ol><li>优化babel-loader 开启缓存</li><li>使用module中的Noparse，不去解析属性值代表的库的依赖（需要在webpack.config.js的module节点添加noParse配置，使用|分割）</li><li>可以使用webpack内置插件lgnorePlugin插件（作用：忽略第三方包指定目录，让这些指定目录不要被打包进去）</li><li>使用happyPack多进程打包（需要下载）</li><li>使用parallelUgligyPlugin多进程压缩js（默认使用uglifyJs来压缩代码，单进程）</li></ol><h2 id="1-3-代码分割的本质是什么？"><a href="#1-3-代码分割的本质是什么？" class="headerlink" title="1.3 代码分割的本质是什么？"></a>1.3 代码分割的本质是什么？</h2><ol><li>代码分割的本质就是在源代码直接上线和达成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</li><li>源码直接上线：虽然过程可控，但是http请求多，性能开销大。</li><li>打包成唯一脚本：服务器压力小，但是页面空白期长，用户体验不好。</li></ol><h2 id="1-4webpack的基本功能有哪些？"><a href="#1-4webpack的基本功能有哪些？" class="headerlink" title="1.4webpack的基本功能有哪些？"></a>1.4webpack的基本功能有哪些？</h2><table><thead><tr><th align="left">名称</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">代码转换</td><td align="left">typescript编译成JavaScript、scss编辑成css</td></tr><tr><td align="left">文件优化</td><td align="left">压缩JavaScript、css、html、压缩合并图片</td></tr><tr><td align="left">代码分割</td><td align="left">提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</td></tr><tr><td align="left">模块合并</td><td align="left">采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</td></tr><tr><td align="left">自动刷新</td><td align="left">监听本地源代码的变化，自动构建，刷新浏览器</td></tr><tr><td align="left">代码校验</td><td align="left">在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</td></tr><tr><td align="left">自动发布</td><td align="left">更新完代码后，自动构建出线上发布代码并传输给发布系统</td></tr></tbody></table><h2 id="1-5-文件指纹是什么？"><a href="#1-5-文件指纹是什么？" class="headerlink" title="1.5 文件指纹是什么？"></a>1.5 文件指纹是什么？</h2><p> 文件指纹是打包之后的文件后缀名。</p><p>        chunkhash：和webpack打包的chunk有关，不同的entry会生出不同的chunkhash。</p><p>                js后缀名：filename:’[name][chunkhash:8].js’,</p><p>        contenthash：根据文件内容来定义hash，文件内容不变，则其不变。</p><p>                css后缀名：filename:’[name][contenthash:8].css’,</p><p>        hash：和整个项目构建有关，只要项目文件有修改，整个构建的hash值就会修改。</p><p>                img后缀名：name:’[name][hash:8].[ext]’</p><h2 id="x20-1-6-为什么说vite比webpack更快？"><a href="#x20-1-6-为什么说vite比webpack更快？" class="headerlink" title="&#x20;1.6 为什么说vite比webpack更快？"></a>&#x20;1.6 为什么说vite比webpack更快？</h2><ol><li>webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。</li><li>vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。</li><li>vite在启动的时候不需要打包，意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。</li><li>&#x20;当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。</li><li>&#x20;在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。</li><li>&#x20;当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS&#x20;</li></ol><h2 id="1-7-vite工作原理"><a href="#1-7-vite工作原理" class="headerlink" title="1.7 vite工作原理"></a>1.7 vite工作原理</h2><p>vite是一种现代化的前端开发工具，其工作原理主要分为以下几个步骤</p><ol><li>基于ESM构建：Vite作为一款基于ESM的前端构建工具，通过ES模块提供的动态导入功能来实现快速的开发和构建。</li><li>零配置开发：Vite允许开发者在不需要任何配置的情况下启动一个服务器进行开发，通过对文件的即时编译和缓存，来提高开发效率。</li><li>基于浏览器原生的ESM加载：Vite将所有文件视为ES模块，并且在开发时会直接从源代码加载模块，而不是打包后的文件，从而可以避免打包的过程带来的性能损失。</li><li>按需编译和缓存：Vite会按需编译和缓存依赖项，只有当需要更新时才会进行重新编译，缓存让开发者可以忽略无关的代码变化。</li><li>插件化架构：Vite的插件化架构可以方便地扩展其功能，例如使用插件来处理CSS、处理图片、压缩源代码等等。</li></ol><h2 id="x20-1-8-vite核心原理"><a href="#x20-1-8-vite核心原理" class="headerlink" title="&#x20;1.8 vite核心原理"></a>&#x20;1.8 vite核心原理</h2><ul><li>Vite其核心原理是利用浏览器现在已经支持ES6的import，碰见import就会发送一个HTTP请求去加载文件。</li><li>Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出许多！</li></ul><p><strong>特点：</strong></p><ol><li>快速的冷启动：基于Esbuild的依赖进行预编译优化 （Esbuild 打包速度太快了，比类似的工具快10~100倍 ）</li><li>增加缓存策略：源码模块使用协商缓存，依赖模块使用强缓；因此一旦被缓存它们将不需要再次请求</li><li>&#x20;HMR（热更新）：当修改代码时，HMR 能够在不刷新页面的情况下，把页面中发生变化的模块，替换成新的模块，同时不影响其他模块的正常运作</li><li>&#x20;基于 Rollup 打包：生产环境下由于esbuild对css和代码分割并使用Rollup进行打包</li><li>高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载&#x20;</li></ol><h2 id="1-9-Vite-冷启动为什么快"><a href="#1-9-Vite-冷启动为什么快" class="headerlink" title="1.9 Vite 冷启动为什么快"></a>1.9 Vite 冷启动为什么快</h2><p>vite 运行 Dev 命令后只做了两件事情</p><ol><li>启动本地服务器并注册了一些中间件</li><li>使用 ESbuild 预构建模块</li></ol><h2 id="1-10-vite生产环境缺点"><a href="#1-10-vite生产环境缺点" class="headerlink" title="1.10 vite生产环境缺点"></a>1.10 vite生产环境缺点</h2><ol><li><p>Vite 在是直接把转化后的 es module 的JavaScript，扔给浏览器，让浏览器根据依赖关系，自己去加载依赖</p></li><li><p>那有人就会说了，那放到 生产环境 时，是不是可以不打包，直接在开个 Vite 服务就行，反正浏览器会自己去根据依赖关系去自己加载依赖。答案是不行的，为啥呢：</p><p>1、你代码是放在服务器的，过多的浏览器加载依赖肯定会引起更多的网络请求</p><p>2、为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割、CSS处理，这些优化操作，目前 esbuild 还不怎么完善&#x20;</p></li></ol><h2 id="x20-1-11-vite和webpack优缺点对比"><a href="#x20-1-11-vite和webpack优缺点对比" class="headerlink" title="&#x20;1.11 vite和webpack优缺点对比"></a>&#x20;1.11 vite和webpack优缺点对比</h2><ul><li>更快的启动时间和更新速度</li><li>更好的开发体验：自动打开浏览器、自动刷新页面 配置简单。</li><li>不需要过多的配置就可以搭建基本的开发环境 更少的依赖。</li><li>借助原生的ES模块</li><li>避免了过多的额外依赖</li></ul><p>&#x20;<strong>缺点：</strong></p><ul><li>vite的构建技术主要用于中小型项目，对于大型项目的支持不如webpack&#x20;</li><li>vite主要是针对vue3的单页面应用，对于多页面应用、ssr应用、自定义流程应用不如webpack&#x20;</li><li>开发环境首屏加载慢，懒加载慢&#x20;</li><li>vite由于基于原生ES模块，不支持commonJs；webpack关注兼容性，vite关注浏览器端的开发体验，vite的生态还不如webpack</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智慧园区后台</title>
      <link href="/posts/883eae6.html"/>
      <url>/posts/883eae6.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h1 id="vue-admin"><a href="#vue-admin" class="headerlink" title="vue-admin"></a>vue-admin</h1><p>场景： 二次迭代 </p><p><a href="https://gitee.com/panjiachen/vue-admin-template?_from=gitee_search">vue-admin-template</a>  下载项目 找到核心内容 （自己分到的业务模块）</p><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p>固定的抽象模式  语义化  + 增加可维护性</p><ol><li>src - 业务代码 最终浏览器中运行 （目录划分相似 语义化 模块化 - 维护方便）</li><li>src之外 - 开发阶段配置文件</li></ol><h1 id="关键文件"><a href="#关键文件" class="headerlink" title="关键文件"></a>关键文件</h1><ol><li><p><strong>package.json  包管理文件</strong></p><ol><li>scripts  可执行的命令 可以自定义 </li><li>dependencies  生产依赖  这里面的包参与业务开发最终打包上线  npm i axios 参与打包  运行浏览器</li><li>devDependencies 开发依赖 开发阶段生效 不参与打包  npm i sass -D 不参与打包  开发阶段生效<br>团队开发模式下 整个团队要保证每个人在本地依赖的包都是一样的</li></ol></li><li><p><strong>main.js</strong><br>不写业务代码  全局初始化的事情 初始化三方组件&#x2F;样式初始化&#x2F;store&#x2F;router</p><p>全局注册elementui 挂载vuerouter 挂载vuex 渲染app根组件</p></li><li><p>组件化的开发模式  组件树</p></li><li><p><strong>vueRouter</strong></p><ol><li>如果左侧菜单只有一项  如何配置</li><li>如果左侧菜单有嵌套  如何配置</li></ol></li><li><p><strong>vuex</strong></p><p>解决的问题：把应用中很多地方都会用到的状态统一管理<br>模块化的开发模式：1. 定义模块（state - mutation - action） 2. 把子模块在modules选项中注册好<br>使用vuex中的数据或者方法：加上模块名</p><ol><li>模块化  namespaced  modules: {子模块}</li><li>和数据相关的所有操作都放到vuex中维护 + 组件只做一个事儿 触发action</li></ol></li></ol><h1 id="request-js-apis"><a href="#request-js-apis" class="headerlink" title="request.js + apis"></a>request.js + apis</h1><ol><li>request 产生一个实例对象给每一个api函数使用  一对多的关系  request配置一次  所有的api函数都会跟着生效</li><li>asiox基础封装<ol><li>实例化  axios.create({}) baseURL + timeout</li><li>请求拦截器 拦截请求处理请求参数再交给后端  headers中注入token</li><li>响应拦截器 拦截返回数据做处理再交给客户端  401  return response.data  401状态 数据剥离</li></ol></li><li>拓展<ol><li>axios.create() 可以执行多次</li><li>拦截器可以有多个（串联参数的模式 前一个拦截器处理完 会把处理之后的数据 下发给下一个拦截器继续处理）</li><li>拦截器函数中千万别弄丢 return</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 1. 通用配置</span></span><br><span class="line"><span class="comment">// 2. 定制化配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用配置</span></span><br><span class="line"><span class="comment">// 1. axios实例化  axios.create() 基地址配置 baseURL + 超时时间 timeout（100ms）</span></span><br><span class="line"><span class="comment">// 拓展：create方法可以调用多次 每次执行都会生成一个独一无二的实例</span></span><br><span class="line"><span class="comment">// export default const a = asiox.create(&#123; baseURL: &#x27;a.com&#x27; &#125;)</span></span><br><span class="line"><span class="comment">// export default const b = asiox.create(&#123; baseURL: &#x27;b.com&#x27; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求拦截器  请求头中添加token数据  接口鉴权  统一配置</span></span><br><span class="line"><span class="comment">// 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端</span></span><br><span class="line"><span class="comment">// 拓展：可以添加多个请求拦截器</span></span><br><span class="line"><span class="comment">// 客户端请求 - 拦截器1(处理参数) - 拦截器2 - 后端 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 响应拦截器 数据剥离 res.data / 401错误处理 / 前端自定义错误处理？ </span></span><br><span class="line"><span class="comment">// 后端 - 响应拦截器 - 客户端</span></span><br><span class="line"><span class="comment">// 成功回调 200-300</span></span><br><span class="line"><span class="comment">// 失败回调 不在这个之间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果后端不管接口成功还是失败统一返回200？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api-hmzs.itheima.net/v1&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span> <span class="comment">// request timeout</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一般项目中多数的接口使用的配置是相似的，所以需要统一配置一次</span><br><span class="line"><span class="number">2.</span> 请求拦截器主要做的事情是在请求发送之前，针对请求参数对象做一些事情（比如添加鉴权<span class="title class_">Token</span>）</span><br><span class="line"><span class="number">3.</span> 响应拦截器主要做的事情是在响应数据返回到业务方之前，针对响应对象做一些事情（比如简化data，错误处理等）</span><br></pre></td></tr></table></figure><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><ol><li><p>业务模式</p><ol><li><p>表单基础校验</p></li><li><p>表单统一校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 按照业务要求编写校验规则对象（rules）</span><br><span class="line">2. el-form组件绑定表单对象（model）和规则对象（rules）</span><br><span class="line">3. el-form-item组件通过prop属性指定要使用的校验规则</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line"> 基础校验</span><br><span class="line">el-form  :model=&quot;表单对象&quot;  :rules=&quot;规则对象&quot;</span><br><span class="line">el-form-item  prop属性指定一下要使用哪条规则</span><br><span class="line">el-input v-model双向绑定</span><br><span class="line"></span><br><span class="line">统一校验</span><br><span class="line">1. 获取表单的实例对象</span><br><span class="line">2. 调用validate方法</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>后续的业务处理（调用接口 - token - 存入token - 跳转首页 - 提示用户）</p></li></ol></li><li><p>表单校验</p><ol><li>先通过 devtools查看双向啊绑定是否成功</li><li>对照接口文档查看接口参数是否一致（拼写+类型）</li><li>校验时机实时校验和统一校验都需要</li></ol></li><li><p>token管理</p><blockquote><p>业务背景：Token的有效期会持续一段时间，在这段时间内没有必要重复请求token，但是Vuex本身是基于内存的管理方式，<strong>刷新浏览器Token会丢失</strong>，为了避免丢失需要配置持久化进行缓存<br>基础思路：</p><ol><li>存Token数据时，一份存入vuex，一份存入cookie</li><li>vuex中初始化Token时，优先从本地cookie取，取不到再初始化为空串儿</li></ol></blockquote><ol><li>多模块共享  - vuex维护</li><li>管理方式 vuex + cookie(localstorage)</li></ol><h2 id="为什么要使用Vuex-Cookies"><a href="#为什么要使用Vuex-Cookies" class="headerlink" title="为什么要使用Vuex+Cookies"></a>为什么要使用Vuex+Cookies</h2><blockquote><p>俩种存储方式的优势都想要</p><ol><li>vuex  基于内存  存取快  但是刷新就丢失</li><li>ls&#x2F;cookie  基于磁盘  存取速度稍慢  刷新不丢失(持久化)</li></ol><p>因为我们既可以享受vuex速度优势封装优势 同时保持持久化</p></blockquote><h2 id="cookie-vs-ls"><a href="#cookie-vs-ls" class="headerlink" title="cookie  vs  ls"></a>cookie  vs  ls</h2><ol><li>存数据的空间大小</li></ol><p>​     ls  5M    cookie kb</p><ol start="2"><li>是否允许后端操作</li></ol><p>​     ls 纯前端操作   cookie 前端可操作 后端也可操作(占多数)</p><ol start="3"><li>是否跟随接口发送</li></ol><p>​      cookie</p></li></ol><h1 id="token持久化"><a href="#token持久化" class="headerlink" title="token持久化"></a>token持久化</h1><ol><li><p>为什么要进行持久化<br>基于vuex的存储页面刷新token丢失</p></li><li><p>如何来做</p><ol><li>在获取到token之后 一式两份  vuex + cookie(ls)</li><li>Vuex初始化state的时候 优先从本地取 取不到才初始化为空</li></ol></li><li><p>vuex vs cookie<br>vuex - 基于内存  快 刷新就丢<br>cookie - 基于磁盘 稍慢 持久化</p></li></ol><h1 id="请求头添加token（请求拦截器）"><a href="#请求头添加token（请求拦截器）" class="headerlink" title="请求头添加token（请求拦截器）"></a>请求头添加token（请求拦截器）</h1><ol><li><p>为什么要做<br>接口鉴权 </p></li><li><p>怎么做<br>请求拦截器中统一配置  headers.Authorization &#x3D; token(格式以后端要求的为主)</p></li></ol><h1 id="记住我优化"><a href="#记住我优化" class="headerlink" title="记住我优化"></a>记住我优化</h1><ol><li>基础实现逻辑<br>如果当前用户选中了记住，在登录时把用户的信息存入本地 在组件初始化的时候去取数据 回填<br>  如果当前没有选中，在登录时把数据清空</li></ol><h1 id="接口错误统一处理"><a href="#接口错误统一处理" class="headerlink" title="接口错误统一处理"></a>接口错误统一处理</h1><ol><li><p>为什么统一处理<br>很多个接口都需要做这个事儿<br>  而且报错的提示位置和字段和后端协商好的</p></li><li><p>如何来做<br>axios响应拦截器来做 判断错误信息存在 弹框提示</p></li></ol><h1 id="token是否存在控制路由权限跳转"><a href="#token是否存在控制路由权限跳转" class="headerlink" title="token是否存在控制路由权限跳转"></a>token是否存在控制路由权限跳转</h1><ol><li>根据流程图 -&gt; js分支语句</li><li>permission.js <ol><li>权限相关的事儿都放到这里 模块化的思想</li><li>路由权限前置守卫</li><li>main.js引入立刻执行</li></ol></li></ol><h1 id="数据基础渲染"><a href="#数据基础渲染" class="headerlink" title="数据基础渲染"></a>数据基础渲染</h1><ol><li>基础实现逻辑<ol><li>准备静态模版（elementUI）</li><li>解决初始报错 在data中把模版绑定的数据都声明一遍</li><li>封装接口（url&#x2F; method &#x2F; 参数[名称 + 类型 + 参数数量]）</li><li>组件中封装一个独立的方法 在方法中调用接口函数 （复用的好处 调用之前做一些额外的参数处理）</li><li>选择一个合适生命周期钩子函数调用独立的方法 （created &#x2F; mounted 都可以）</li><li>使用数据渲染模版 （数据驱动视图）</li></ol></li></ol><h1 id="列表基础渲染"><a href="#列表基础渲染" class="headerlink" title="列表基础渲染"></a>列表基础渲染</h1><ol><li><p>实现步骤</p><ol><li>按照接口文档请求列表接口封装一下（url&#x2F;method&#x2F;参数）[拼写&#x2F;类型]</li><li>data准备响应式的数据（以后端接口实际返回为主）</li><li>在methods封装一个方法（参数的二次处理 + 调用接口 + 数据赋值）</li><li>生命周期钩子函数调用这个方法（created &#x2F; mounted）</li><li>把响应式数据绑定组件身上（文档组件要求通过什么属性绑定就通过生命属性）</li></ol></li><li><p>分页功能</p><ol><li><p>分页的逻辑<br>页数 &#x3D; 总条数 &#x2F; 单页的条数</p></li><li><p>组件分好页<br>传入总数  :total&#x3D;”100”<br>单页条数  :pageSize&#x3D;”2” 默认10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">   1. 页数分出来 （页数 = 总条数 / 每页条数）</span><br><span class="line">   2. 点击每页的时候获取当前页的数据重新渲染到table上</span><br><span class="line">--&gt;</span><br><span class="line">&lt;el-pagination</span><br><span class="line">  layout=&quot;total, prev, pager, next&quot;</span><br><span class="line">  :page-size=&quot;params.pageSize&quot;</span><br><span class="line">  :total=&quot;total&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击分页交互的实现</p><ol><li><p>点击时拿到当前点击的页数（父组件从子组件获取内部的数据 子传父）<br>@current-change&#x3D;”pageChange”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pageChange</span>(<span class="params">page</span>) &#123; </span><br><span class="line">   <span class="comment">// console.log(page) // 回调参数 拿到的是当前页</span></span><br><span class="line">   <span class="comment">// 把点击的页数赋值给请求参数页数  </span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line">   <span class="comment">// 使用最新的请求参数获取列表数据</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getCardList</span>()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用当前的页数去后端要当前页的数据重新渲染到table</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h1 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h1><!-- 搜索区域 --><pre><code>思路分析：把各种搜索条件当作请求参数发给后端 后端会根据字段对数据库数据做过滤筛选拿到符合条件返回  1. 表单组件的双向绑定收集到当前的请求数据        2. 把收集到的表单参数发送接口给后端那符合条件的数据        3. 把拿到的数据关系显示在列表中</code></pre><p>下拉组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-select v-model=&quot;params.cardStatus&quot;&gt;</span><br><span class="line">     &lt;!-- </span><br><span class="line">        el-select: 双向绑定收集当前选中的数据</span><br><span class="line">        el-option： 下拉框中的每一项</span><br><span class="line">         label（中文显示）</span><br><span class="line">         value （选中之后赋值给v-model的数据将来传给后端）</span><br><span class="line">    --&gt;</span><br><span class="line">   &lt;el-option</span><br><span class="line">     v-for=&quot;item in cardStatusList&quot;</span><br><span class="line">     :key=&quot;item.id&quot;</span><br><span class="line">     :value=&quot;item.id&quot;</span><br><span class="line">     :label=&quot;item.name&quot;</span><br><span class="line">   /&gt;</span><br><span class="line"> &lt;/el-select&gt;</span><br></pre></td></tr></table></figure><h1 id="状态适配"><a href="#状态适配" class="headerlink" title="状态适配"></a>状态适配</h1><ol><li><p>场景<br>后端返回的数据无法直接显示到页面中 0&#x2F;1 男女</p></li><li><p>转化的状态码数量只有两个<br>解决方案：三元表达式  status &#x3D;&#x3D;&#x3D; 0? ‘女’ ：’男’</p><p>转化的状态码比较多<br>解决方案：映射的方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">status</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAP</span> = &#123;</span><br><span class="line">   <span class="number">0</span>:<span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">   <span class="number">1</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">MAP</span>[status]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h1><pre><code>1. 步骤   1. 点击跳转到新的路由页面/在当前页面打开一个弹框   2. 准备表单项（通常只要有表单就会有校验 单独校验 + 统一校验）   3. 收集表单数据（打开devtools 检测双向绑定是否ok）   4. 提交 (接口字段不多不少 字段名称完全对应 类型完全匹配)   5. 后续的逻辑处理 （提供用户 + 重新拉取列表 + 表单的重置 + 路由的重置）</code></pre><h1 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h1><ol><li><p>简单校验<br>使用elementUI默认的配置项就可以完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">  el-form  :model  :rules</span><br><span class="line">  el-form-item  prop指定要用哪条规则</span><br><span class="line">  el-input v-model双向绑定</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>自定义校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">validateMobile</span> = (<span class="params">rule,value,cb</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 默认的配置 声明式配置</span></span><br><span class="line">      <span class="comment">// 自定义校验逻辑 命令式的校验 写的式逻辑代码</span></span><br><span class="line">      <span class="comment">// value: 输入框的数据 校验的那个数据</span></span><br><span class="line">      <span class="comment">// cb：校验放行函数 不管在通过还是未通过都需要调用它</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  validator： validateMobile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对某些字段单独校验</p><ol><li>场景：默认的表单校验管控不到 出现在自定义组件中 上传</li><li>调用单独校验实例方法  this.$refs.form.validateField(‘校验的字段’)</li></ol></li><li><p>表单功能的时候要提前做数据验证 devtools 双向绑定是否生效 生效之后再调用接口</p></li></ol><h1 id="梳理新增和编辑"><a href="#梳理新增和编辑" class="headerlink" title="梳理新增和编辑"></a>梳理新增和编辑</h1><ol><li><p>新增 点击新增按钮 - 跳转到新增路由 - 准备表单- 二次参数处理 - 提交新增接口 - 后续处理（提示&#x2F;回跳）</p></li><li><p>编辑 点击编辑按钮 - 携带id跳转到新增路由 - 准备表单（回填） - 表单校验 - 二次参数处理 - 提交的更新接口 - 提示回跳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">  scope 作用域插槽</span><br><span class="line">  scope.row  -&gt; 当前行的数据对象</span><br><span class="line"> </span><br><span class="line">  如果我们只是想使用插槽渲染模板 #default</span><br><span class="line">  如果我们除了想要使用插槽渲染模板 而且还想要拿到它内部的数据 #default=&quot;scope&quot;</span><br><span class="line">  scope 类似于函数的形参</span><br><span class="line">  组件内部会把当前行数数据对象当成一个实参传到scope的位置</span><br><span class="line">  </span><br><span class="line">  在内部传递实参的时候 实参的格式</span><br><span class="line">  &#123;</span><br><span class="line">   row: 当前行的对象数据</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  因为本来传下来的就是一个对象 所以通过解构赋值的方式去取row参数 #default=&quot;&#123;row&#125;&quot;</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;el-button size=&quot;mini&quot; type=&quot;text&quot; @click=&quot;editCard(scope.row.id)&quot;&gt;编辑&lt;/el-button&gt;</span><br></pre></td></tr></table></figure></li></ol><p>重点：</p><ol><li><p>新增和编辑状态 始终用的就是 id 有id代表当前是编辑状态 没有id代表就是新增状态</p><ol><li>有id 才获取详情接口</li><li>有id 调用更新接口 没有id 调用新增接口</li><li>有id 显示编辑 没有id 显示新增</li></ol></li><li><p>点击确定调用接口时区分状态之外 还需区分参数</p><ol><li>如果是新增接口调用  没有任何id</li><li>如果是更新接口调用  请求参数中附加id[相关id数据在数据回填的时候加进去] 通知后端要更新谁</li></ol></li></ol><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><ol><li><p>上传的流程<br>点击上传按钮 -&gt; el-upload [打开本地文件选择框 + 上传前的文件校验] -&gt; File -&gt;<br>new FormData()[接口要求传递一个formdata类型的数据] -&gt; 往formData的对象中append字段<br>-&gt; append(‘file’,file) append(‘type’,’business…’) -&gt; 使用完整的formData对象提交接口完成    上传</p></li><li><p>细节问题</p><ol><li>el-upload<ol><li>非常简单  不需要做任何的自定义配置 默认的配置项完成上传就行了</li><li>需要自定义场景  :http-request&#x3D;’function’</li><li>如果添加了上传前的校验 流程：先执行上传前的校验函数 函数返回值为true 再执行upload上传函数</li><li>函数参数 ：上传前的函数 file对象 [size &#x2F; type做校验] 上传函数  res对象 { file：File }</li></ol></li><li>上传接口接口参数<ol><li>常规的接口  contentType  application&#x2F;json</li><li>上传接口    contentType  application&#x2F;form-data</li></ol></li><li>前后端校验逻辑要保持一致<br>文件大小  小于5m  &#x2F; 文件类型 jpeg  前端要以这个为主<br>[因为接口不只是可以通过浏览器提交 也可以通过其他方式提交 基于界面操作类校验会失败]</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> :http-request=&quot;uploadRequest&quot; 自定义上传</span><br><span class="line">  action 本来是一个用来配置默认上传的接口地址</span><br><span class="line">  因为我们覆盖了  所以用一个 # 占个位置 消除必填警告</span><br><span class="line">  input type=&quot;file&quot; 本身具备选择文件的能力</span><br><span class="line">  覆盖原因：默认的配置上传不够灵活 仅支持一些简单的上传 </span><br><span class="line"></span><br><span class="line">  如果想要完全自定义上传 http-request</span><br><span class="line">  在选择文件之后 自动执行upload函数 并且把一个对象传给我们</span><br><span class="line">  对象中有一个file属性 就是我们要上传的对象</span><br><span class="line">      </span><br><span class="line">  上传前校验：</span><br><span class="line">    1. 上传图片之前加一层校验 目的为了限制用户上传的文件类型和大小</span><br><span class="line">    2. 如果我们添加了beforeUpload这个属性方法 这个函数中必须return的数据为true</span><br><span class="line">       才会继续执行 upload 方法 如果校验不通过 暂停执行 不会走上传逻辑</span><br><span class="line">    3. file对象中两个属性</span><br><span class="line">       size: 文件大小 / 1024/1024 = M</span><br><span class="line">       type: 文件类型  image/文件类型</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=&quot;营业执照&quot;&gt;</span><br><span class="line">    &lt;el-upload</span><br><span class="line">      action=&quot;#&quot;</span><br><span class="line">      :http-request=&quot;uploadRequest&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">      &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">    &lt;/el-upload&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- </span><br><span class="line">    上传实现流程：</span><br><span class="line">      1. el-upload 打开本地文件  并且校验这个文件是否符合要求 - File</span><br><span class="line">      2. :http-request = &#x27;upload&#x27;</span><br><span class="line">      3. 按照接口的要求格式 得到类型为FormData对象 new FormData()</span><br><span class="line">      4. 按照要求往 formData中添加字段数据 fd.append(&#x27;字段名&#x27;,&#x27;字段值&#x27;)</span><br><span class="line">      5. 调用上传接口</span><br><span class="line">      6. 拿到返回的文件地址和其有用的信息id 存入data中的响应式数据的位置 将来提交表单</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure><h1 id="表单校验-1"><a href="#表单校验-1" class="headerlink" title="表单校验"></a>表单校验</h1><ol><li>基础校验  [按照配置]</li><li>统一校验  [validate 把所有需要校验的表单项都校验一便 把校验的结果布尔值返回valid]</li><li>自定义校验规则 [{ validator:校验方法 rule value cb } 不管是成功还是失败都必须调用cb]</li><li>单独校验某个表单字段<ol><li>场景：表单中有一些特殊的字段  没有直接和el-form表单系统进行绑定  有值之后不会通知校验系统</li><li>解决办法：手动触发校验逻辑 调用el-form组件实例对象的单独校验方法 validateField(‘prop指定的那        个规则’)</li></ol></li></ol><h1 id="vue2的响应式缺点"><a href="#vue2的响应式缺点" class="headerlink" title="vue2的响应式缺点"></a>vue2的响应式缺点</h1><p>对象的属性动态添加 不是响应式的<br>Object.defineProperty<br>解决办法：<br>  this.$set(要修改的对象,要添加的属性名，新属性的值)</p><p>特俗情况： v-model  视图修改的时候同样可以被收集到本来不存在的属性身上</p><h1 id="下拉列表的数据"><a href="#下拉列表的数据" class="headerlink" title="下拉列表的数据"></a>下拉列表的数据</h1><ol><li>单独有一个下拉列表接口</li><li>没有单独下拉 复用table表格的列表接口（不需要判断状态 没有状态的所有数据）</li></ol><p>知道一个事情：业务数据是由状态的 而且状态可以通过用户操作进行切换</p><h1 id="表单的清空"><a href="#表单的清空" class="headerlink" title="表单的清空"></a>表单的清空</h1><ol><li><p>调用表单组件的实例方法 resetFields</p></li><li><p>手动做数据的清除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">form</span> = &#123;</span><br><span class="line">   name= <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="网络请求的优化"><a href="#网络请求的优化" class="headerlink" title="网络请求的优化"></a>网络请求的优化</h1><ol><li>场景: 限制了请求个数 保证只有打开时才请求</li><li>怎么做到？<ol><li>判断第一个参数row是否能在第二个参数rows中找到 如果能找到代表打开了</li><li>find 通过匹配找到符合条件的第一项 然后把找到的项返回</li><li>findIndex 通过匹配找到符合条件的第一项 然后把找到项的下标值返回 splice(index,1)</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有展开时获取数据并绑定</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">expandHandle</span>(<span class="params">row, rows</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;展开或关闭&#x27;, row, rows) 点击行row.id  rows数组对象</span></span><br><span class="line">  <span class="comment">// row: 当前行的对象  rows数组对象</span></span><br><span class="line">  <span class="comment">// 1. 先拿到当前行的数据</span></span><br><span class="line">  <span class="comment">// 2. 使用当前行的企业数据，获取下面的合同列表数据</span></span><br><span class="line">  <span class="comment">// 3. 把拿到的合同列表存入企业对象中 但是row里面没有存放的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化网络请求 只在打开时才去触发 核心：拿到当前是打开的条件 做判断</span></span><br><span class="line">    <span class="comment">// 判断条件：第一个row是否能在第二个rows中找到 如果找到了 代表打开了 如果找不到 代表收起了</span></span><br><span class="line">    <span class="comment">// find findIndex</span></span><br><span class="line">  <span class="keyword">const</span> isExpend = rows.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === row.<span class="property">id</span>)</span><br><span class="line">  <span class="keyword">if</span> (isExpend) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了这一项，才回去调用接口</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getRentListAPI</span>(row.<span class="property">id</span>)</span><br><span class="line">    <span class="comment">// eslint-disable-next-line require-atomic-updates</span></span><br><span class="line">    row.<span class="property">rentList</span> = res.<span class="property">data</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="带有模板的状态格式化"><a href="#带有模板的状态格式化" class="headerlink" title="带有模板的状态格式化"></a>带有模板的状态格式化</h1><ol><li><p>直接可以把后端的数据渲染出来 prop指定要渲染的字段</p></li><li><p>不能直接渲染  需要格式化  格式化出来的内容一九是一个文本  string</p><ol><li>：formatter&#x3D;”formatStatus” 不需要手动传参 自动传入</li><li>插槽 + 插值表达式  [渲染出来的是函数的返回值]</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">default</span>=<span class="string">&quot;&#123;row&#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; formatStatus(row.status) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>&#x2F;&#x2F; 格式化status<br>   formatStatus(type) {<br>  const TYPEMAP &#x3D; {<br>       0: ‘待生效’,<br>    1: ‘生效中’,<br>       2: ‘已到期’,<br>       3: ‘已退租’<br>     }<br>     return TYPEMAP[type]<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 不能直接渲染 格式化出来的是一个模板</span><br><span class="line"></span><br><span class="line">   插槽 + 插值表达式 [渲染出来的是函数的返回值]</span><br><span class="line"></span><br><span class="line">   ```html</span><br><span class="line">   &lt;template default=&quot;&#123;row&#125;&quot;&gt;</span><br><span class="line">       &lt;el-tag&gt; &#123;&#123; formatStatus(row.status) &#125;&#125; &lt;/el-tag&gt;</span><br><span class="line">   &lt;/template&gt;</span><br></pre></td></tr></table></figure><p>​      </p><h1 id="对象动态添加响应式属性"><a href="#对象动态添加响应式属性" class="headerlink" title="对象动态添加响应式属性"></a>对象动态添加响应式属性</h1><ol><li><p>vue2 Object.defineProperty  无法监听到对象属性的添加 &#x2F; 数组通过下标直接修改 也监听不到</p></li><li><p>Vue.set &#x2F; this.$set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">form</span>,<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>) <span class="comment">// 就会变成响应式</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">list</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;new data&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h1 id="后端返回的数据字段不够-需要前端自定义字段"><a href="#后端返回的数据字段不够-需要前端自定义字段" class="headerlink" title="后端返回的数据字段不够 需要前端自定义字段"></a>后端返回的数据字段不够 需要前端自定义字段</h1><p>  默认的返回的企业列表数据中没有一个存放合同列表的数据的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">list</span> = res.<span class="property">data</span>.<span class="property">rows</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">rendList</span>: []  <span class="comment">// 通过映射自定义添加字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="word-文档的预览"><a href="#word-文档的预览" class="headerlink" title="word 文档的预览"></a>word 文档的预览</h1><p>解决方案：通过一个固定的预览地址 拼接 自己的合同url地址 然后通过a链接在新窗口打开</p><p>拼接方式：prewViewURL?src&#x3D;url</p><h1 id="业务数据状态变化"><a href="#业务数据状态变化" class="headerlink" title="业务数据状态变化"></a>业务数据状态变化</h1><p>合同列表</p><ol><li>当前时间还没有合同的起止时间 未开始</li><li>当前时间已经超过了合同的起止时间 已结束</li><li>当前时间正好式合同期限内，且用户没有退租 生效中</li></ol><p>不同的业务数据状态影响显示及操作区域按钮的控制</p><p>实际开发时如何判断某块业务已经跑通了：接口通了并且对应的状态已经确认被修改了</p><h1 id="excel导出"><a href="#excel导出" class="headerlink" title="excel导出"></a>excel导出</h1><ol><li><p>实际开发过程中的导出</p><ol><li><p>前端主导（xlsx）</p><p>流程：调用列表接口把要导出的数据拿到 -&gt; 数据的二次转化  -&gt;  [excel 工作簿 - 工作表 - 单元格数据] - 使用xlsx创建一个工作簿 - 使用xlsx方法创建一个工作表 - 把工作表添加到工作簿 – [使用中文替换中文表头] 调用xlsx的导出方法</p><p>工作中遇到了需求，参考代码 换接口 数据二次处理 处理表头</p></li><li><p>后端主导（最常见）</p><p>流程：前端直接调用导出接口 - 后端会把数据转换成excel文件流当成返回值返回 - 直接触发浏览器的下载功能</p></li></ol></li><li><p>两种方案的本质区别：</p><p>把数据转化成excel的过程发生在哪里？如果发生在浏览器 前端主导 如果发生在后端服务器 后端主导</p><p>前端主导 - 处理数据量不能太大</p><p>后端主导 - 适合处理量大或量小都可</p></li></ol><h1 id="账单支付金额的接口计算"><a href="#账单支付金额的接口计算" class="headerlink" title="账单支付金额的接口计算"></a>账单支付金额的接口计算</h1><p>思想：</p><p>​    操作表现流程：选中了楼宇 + 选中时间  &#x3D;&gt; 调用接口  -&gt; 计算之后的数据 -&gt; 显示到input框内</p><pre><code>1. 通过事件分别监听一下楼宇什么时候选中 时间什么时候选中  [通过事件绑定回调函数 两个组件分别绑定同一个回调函数]   2. 在事件的回调中判断一下接口必须传参是否都具备了 [非空判断]   3. 如果接口参数都不是空  正常发接口请求  获取计算金额   4. 通过 v-model 进行正常的回填  [通过属性控制它不可编辑]</code></pre><h1 id="tab切换类交互"><a href="#tab切换类交互" class="headerlink" title="tab切换类交互"></a>tab切换类交互</h1><ol><li>场景：角色列表切换  &#x2F; 菜单列表切换  &#x2F; tabs组件点击切换</li><li>通用实现方法<ol><li>点击谁把谁index&#x2F;id（唯一的标识）记录下来</li><li>准备一个激活的类名样式 active </li><li>通过vue中的动态类名:class &#x3D; {acitve: index(当前项index) &#x3D;&#x3D;&#x3D; curIndex（激活记录下标） }</li></ol></li></ol><h1 id="树状组件"><a href="#树状组件" class="headerlink" title="树状组件"></a>树状组件</h1><ol><li><p>树:嵌套的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;第一项&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="string">&#x27;1-1&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&#x27;第二项&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">id</span>:<span class="string">&#x27;1-1-1&#x27;</span>,</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;第三项&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>如何把一个平铺的数组处理成树形的数组？<br>大多是情况下 都需要前端自己处理 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeList = [</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">   <span class="attr">title</span>:<span class="string">&#x27;第一项&#x27;</span>,</span><br><span class="line">   <span class="attr">pid</span>: <span class="literal">null</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">id</span>:<span class="string">&#x27;1-1&#x27;</span>,</span><br><span class="line">   <span class="attr">title</span>:<span class="string">&#x27;第二项&#x27;</span>,</span><br><span class="line">   <span class="attr">pid</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">id</span>:<span class="string">&#x27;1-1-1&#x27;</span>,</span><br><span class="line">   <span class="attr">title</span>:<span class="string">&#x27;第三项&#x27;</span>，</span><br><span class="line">   <span class="attr">pid</span>:<span class="string">&#x27;1-1&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h1 id="前端同步异步的问题"><a href="#前端同步异步的问题" class="headerlink" title="前端同步异步的问题"></a>前端同步异步的问题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getRoleList</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getTreeList</span>()</span><br><span class="line">  <span class="comment">// 初始化的时候使用第一项的roleId进行高亮处理</span></span><br><span class="line">  <span class="comment">// 这个方法调用初始化时同步调用 而它依赖的roleList treeList都是通过异步获取的</span></span><br><span class="line">  <span class="comment">// 为了保证数据已经准备好了 模拟同步 必须保证上面的俩个异步返回数据之后才调用方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setTreeByPerms</span>(<span class="variable language_">this</span>.<span class="property">roleList</span>[<span class="number">0</span>].<span class="property">roleId</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RBAC指的是什么？"><a href="#RBAC指的是什么？" class="headerlink" title="RBAC指的是什么？"></a>RBAC指的是什么？</h1><p>基于角色的权限控制思想<br>员工 - 角色 - 权限点<br>先把权限点交给某个角色 然后再把角色交给某个员工 这个员工自动有了角色下所有的权限点</p><h1 id="前端菜单路由权限控制"><a href="#前端菜单路由权限控制" class="headerlink" title="前端菜单路由权限控制"></a>前端菜单路由权限控制</h1><p><img src="https://bu.dusays.com/2023/09/04/64f5e46ce1093.png" alt="74.png"></p><ol><li>权限数据的生成（RBAC）<ol><li>新增一个角色 给角色配置权限数据</li><li>新增一个员工 给员工分配这个角色 员工就有了当前角色下所有的权限数据</li></ol></li><li>完整的实现流程<ol><li><p>调用接口获取当前员工的权限数据  permission [‘park:building:add_edit’]</p><ol><li>在Vuex中编写逻辑，user&#x2F;state里存放个人用户信息 </li><li>action里调用时，把permissions目标数据return出去 给另一个js模块使用</li><li>permission文件中触发action，获取用户信息（有token时）</li></ol></li><li><p>对权限数据做格式化处理 产生两个权限数据  一级路由权限数组 + 二级路由权限数组</p></li><li><p>把路由表拆分成两部分 动态路由表[需要加权限控制] + 静态路由表[不需要加权限控制]</p><ol><li>拆分动态路由表导出使用 asyncRoutes</li><li>初始化时候只处理静态路由表  routes: […routes]</li></ol></li><li><p>以一级和二级权限数组作为对主动态路由表做过滤筛选处理 -&gt; 有资格加入到路由系统中的动态路由表</p><ol><li>使用一级权限点过滤一级路由 使用二级权限点过滤二级路由 最终得到显示左侧的路由表</li><li>调用函数获取最终的动态路由</li></ol></li><li><p>调用router的addRoute方法把动态路由表依次添加到路由系统中 访问url可以渲染对应的组件</p></li><li><p>使用动态路由表数据通过存入Vuex然后利用它响应式的特性 渲染到左侧菜单中</p><ol><li>vuex新增一个模块，menu模块，先以静态的路由表作为初始值</li><li>在得到过滤之后的动态路由表之后，和之前的静态做一个结合</li><li>在sidebar组件中结合v-for指令做使用Vuex中的数据做渲染</li></ol></li><li><p>解决切换用户有缓存的bug 方案：在用户退出登录时</p><ol><li><p>调用清空路由的reset方法</p></li><li><p>手动把Vuex中的数据也清空</p></li><li><p>用户信息也清空</p></li></ol></li></ol></li><li>每一个独立的小功能封装成一个独立的小函数 维护方便</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">profile</span>.<span class="property">id</span>) &#123;</span><br><span class="line">       <span class="comment">// 1. 调用action函数获取用户权限数据</span></span><br><span class="line">       <span class="keyword">const</span> permissions = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getProfile&#x27;</span>)</span><br><span class="line">       <span class="comment">// 2. 把后端的权限数组格式化成我们自己的俩个权限数据</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前的权限数据为:&#x27;</span>, permissions)</span><br><span class="line">       <span class="keyword">const</span> firstRoutePerms = <span class="title function_">getFirstRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一级路由权限&#x27;</span>, firstRoutePerms)</span><br><span class="line">       <span class="keyword">const</span> secondRoutePerms = <span class="title function_">getSecondRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;二级路由权限&#x27;</span>, secondRoutePerms)</span><br><span class="line">       <span class="comment">// 3. 根据权限标识过滤路由表 最终得到显示到左侧的路由表</span></span><br><span class="line">       <span class="keyword">const</span> routes = <span class="title function_">getRoutes</span>(firstRoutePerms, secondRoutePerms, asyncRoutes)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最终路由表&#x27;</span>, routes)</span><br><span class="line">       <span class="comment">// 4. addRoute动态添加 (当浏览器中访问路由的路径 显示渲染出来对应的组件)</span></span><br><span class="line">       routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> router.<span class="title function_">addRoute</span>(route))</span><br><span class="line">       <span class="comment">// 5. 存入Vuex渲染左侧菜单</span></span><br><span class="line">       store.<span class="title function_">commit</span>(<span class="string">&#x27;menu/setMenuList&#x27;</span>, routes)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧园区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue原理</title>
      <link href="/posts/f82ea27.html"/>
      <url>/posts/f82ea27.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Vue原理"><a href="#一、Vue原理" class="headerlink" title="一、Vue原理"></a>一、Vue原理</h2><ul><li>响应式系统<ul><li>学习<code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</li></ul></li><li>vue中选项方法<ul><li>学习watch选项 $watch方法 computed选项 $set方法 $nextTick $mount方法的封装</li></ul></li><li>template 编译过程<ul><li>学习<code>Vue</code>内部是怎么把<code>template</code>模板编译成虚拟<code>DOM</code>,从而渲染出真实<code>DOM</code></li></ul></li><li>虚拟 dom 生成与更新<ul><li>学习什么是虚拟 DOM，以及<code>Vue</code>中的<code>DOM-Diff</code>原理</li></ul></li></ul><h2 id="二、Vue2-学习路线图"><a href="#二、Vue2-学习路线图" class="headerlink" title="二、Vue2 学习路线图"></a>二、Vue2 学习路线图</h2><p>下面这张流程图中表示了vue的关键部分的执行过程，和核心函数。我们可以根据这样一个过程来自己实现一个vue框架。</p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://bu.dusays.com/2023/08/20/64e1c9eb42347.png" alt="image-20230704110034877-8439636.png"></h6><p>通过梳理Vue初始化的过程，我们发现实现一个类似于Vue的框架主要需要实现这几部分 响应式系统框架、虚拟dom编译渲染机制 MVVM更新机制，接下来我们先从最基本的响应式系统开始，自己动手写一个Vue的简单框架</p><p>【思考】Vue在初始化的过程中主要经历的哪些步骤</p><p>【回答】</p><p>1、初始化Vue构造函数，挂载属性 方法</p><p>2、模板编译成render函数</p><p>3、通过Watcher收集依赖</p><p>4、diff更新dom</p><p>5、渲染dom</p><p>【补充】vue是一个标准的MVVM框架么？</p><p>Vue 并不完全是一个MVVM框架MVVM只能数据驱动视图，视图更改数据，而不能通过其他方式操作数据。在vue中我们也可以自己手动修改数据，所以vue并不是一个完全意义上的MVVM框架。</p><h2 id="三、Vue2-响应式原理"><a href="#三、Vue2-响应式原理" class="headerlink" title="三、Vue2 响应式原理"></a>三、Vue2 响应式原理</h2><p>从这一小节开始我们带着大家实现一个Vue框架</p><p>我们先来看看面试宝典中的关于Vue响应式的八股文 （P143-4）</p><p><img src="https://bu.dusays.com/2023/08/20/64e1cb8bedb70.png" alt="image-20230712205031984.png"></p><p>相信绝大多数的同学看到这个八股文都会感觉头大。学完今天的内容，我们都会对怎么回答vue的响应式原理有了自己的理解。</p><p>下面我们一起来揭秘vue的响应式原理到底是怎么实现的！</p><h3 id="1、章节概述"><a href="#1、章节概述" class="headerlink" title="1、章节概述"></a>1、章节概述</h3><p>我们首先实现学习路线中第一条分支，从状态初始化到数据响应式的过程</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e7ec1b1.png" alt="image-20230712205309319.png"></p><p>所谓数据响应式就是<strong>能够使数据变化可以被检测并对这种变化做出响应的机制</strong>。MVVM框架中要解决的一个核心问题是连接数据层和视图层，通过<strong>数据驱动</strong>应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9dc7f684.png" alt="data.png"></p><p>Vue 的响应式原理依赖于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>，Vue通过设定对象属性的 setter&#x2F;getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。</p><p>所以在vue中的数据响应式原理主要是给data绑定一个观察着 observe 让数据变成可观察的，我们首先来看源码然后自己尝试手写一个observe</p><h3 id="2、环境准备"><a href="#2、环境准备" class="headerlink" title="2、环境准备"></a>2、环境准备</h3><p>在这一小节中我们开始自己实现一个Vue框架，通过Vue源码我们了解到Vue使用的rollup构建工具进行打包</p><p><strong>&#x2F;package.json</strong></p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9dd5dfad.png" alt="image-20230419133024189.png"></p><p>这里我们也使用Rollup实现项目打包，我们之前有学习过脚手架工具webpack，Rollup和webpack的区别在于项目类代码中有大量的代码拆分，构建项目类型的应用显然webpack更为合适，如果想要构建js类库将多个模块打包成一个大的文件rollpu更加合适，同时rollup中提供的tree-shake可以帮助我们自动删除冗余代码</p><table><thead><tr><th><strong>Webpack</strong></th><th><strong>Rollup</strong></th></tr></thead><tbody><tr><td>vue-cli, create-react-app 各类应用脚手架</td><td>react，vue，three.js，<a href="https://so.csdn.net/so/search?q=D3&spm=1001.2101.3001.7020">D3</a>，moment</td></tr></tbody></table><h4 id="1、源码工程的初始化"><a href="#1、源码工程的初始化" class="headerlink" title="1、源码工程的初始化"></a>1、源码工程的初始化</h4><h5 id="1、新建项目文件夹，在文件夹下初始化工程"><a href="#1、新建项目文件夹，在文件夹下初始化工程" class="headerlink" title="1、新建项目文件夹，在文件夹下初始化工程"></a>1、新建项目文件夹，在文件夹下初始化工程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9df6c2cb.png" alt="image-20230419134428522.png"></p><p>获得package.json</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e037863.png" alt="image-20230419134457299.png"></p><h5 id="2、安装Rollup打包依赖"><a href="#2、安装Rollup打包依赖" class="headerlink" title="2、安装Rollup打包依赖"></a>2、安装Rollup打包依赖</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1，安装 rollup：用于 Vue 源码的打包构建</span><br><span class="line">npm install rollup</span><br><span class="line"></span><br><span class="line">// 2，使用 babel：需要安装核心模块 @babel/core；</span><br><span class="line">npm install @babel/core</span><br><span class="line"></span><br><span class="line">// 3，rollup 与 babel 关联</span><br><span class="line">npm install rollup-plugin-babel</span><br><span class="line"></span><br><span class="line">// 4，浏览器兼容：将 ES6 语法转译为 ES5</span><br><span class="line">npm install @babel/preset-env</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ==&gt; 合并写法：一次性安装开发环境所需的全部依赖</span><br><span class="line">npm install rollup @babel/core rollup-plugin-babel @babel/preset-env -D</span><br></pre></td></tr></table></figure><h5 id="3、创建Vue-js文件"><a href="#3、创建Vue-js文件" class="headerlink" title="3、创建Vue.js文件"></a>3、创建Vue.js文件</h5><p>创建打包入口：src&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js Vue 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Vue 函数，提供外部使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9dfc043b.png" alt="image-20230419135420661.png"></p><h5 id="4、创建-Rollup-配置文件"><a href="#4、创建-Rollup-配置文件" class="headerlink" title="4、创建 Rollup 配置文件"></a>4、创建 Rollup 配置文件</h5><p>rollup 默认配置文件：项目根目录下<code>rollup.config.js</code>文件</p><p>创建 rollup.config.js，完成 rollup、<a href="https://so.csdn.net/so/search?q=babel&spm=1001.2101.3001.7020">babel</a> 相关配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-babel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 rollup 配置对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 打包入口</span></span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,   </span><br><span class="line">  <span class="comment">// 打包出口：可定义为数组，输出多种构件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;                </span><br><span class="line">    <span class="comment">// 打包输出文件</span></span><br><span class="line">    <span class="attr">file</span>: <span class="string">&#x27;dist/vue.js&#x27;</span>,   </span><br><span class="line">    <span class="comment">// 打包格式（可选项）：iife（立即执行函数）、esm（ES6 模块）、cjs（Node 规范）、umd（支持 amd + cjs）</span></span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,         </span><br><span class="line">    <span class="comment">// 使用 umd 打包需要指定导出的模块名，Vue 模块将会绑定到 window 上；</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span>,          </span><br><span class="line">    <span class="comment">// 开启 sourcemap 源码映射，打包时会生成 .map 文件；作用：浏览器调试ES5代码时，可定位到ES6源代码所在行；</span></span><br><span class="line">    <span class="attr">sourcemap</span>: <span class="literal">true</span>,      </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用 Rollup 插件转译代码</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="comment">// 忽略 node_modules 目录下所有文件（**：所有文件夹下的所有文件）</span></span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&#x27;node_modules/**&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、创建-rollup-构建脚本"><a href="#5、创建-rollup-构建脚本" class="headerlink" title="5、创建 rollup 构建脚本"></a>5、创建 rollup 构建脚本</h5><p>执行 Rollup 打包构建 Vue，创建 rollup-script 构建脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">.........</span><br><span class="line">  <span class="comment">// ollup 命令：默认会去找 node_module/bin/rollup；</span></span><br><span class="line"><span class="comment">// - -c：config 选项，使用配置文件，默认找 rollup.config.js；</span></span><br><span class="line"><span class="comment">// - -w：watch 选项，监听文件变化；当文件发生变化时重新打包；</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rollup -c -w&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">.........</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>dev 脚本解释：</p><ul><li>rollup 命令：默认会去找 node_module&#x2F;bin&#x2F;rollup；</li><li>-c：config 选项，使用配置文件，默认找 rollup.config.js；</li><li>-w：watch 选项，监听文件变化；当文件发生变化时重新打包；</li></ul><h5 id="6、打包构建-Vue"><a href="#6、打包构建-Vue" class="headerlink" title="6、打包构建 Vue"></a>6、打包构建 Vue</h5><p>执行构建脚本 npm run dev</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9de75622.png" alt="image-20230419135603333.png"></p><p>将 <code>src/index.js</code> 输出至 <code>dist/vue.js</code> 其中，<code>vue.js.map</code> 为 sourcemap 源码映射文件</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e1a53ce.png" alt="image-20230419135710522.png"></p><h5 id="7、创建-Html-引入-Vue"><a href="#7、创建-Html-引入-Vue" class="headerlink" title="7、创建 Html 引入 Vue"></a>7、创建 Html 引入 Vue</h5><p>创建 <code>dist/index.html</code> 引入 <code>dist/vue.js</code>，打印输出 Vue：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 vue.js，将会绑定到 window--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vue</span>) </span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开<code>index.html</code>，查看控制台输出，此时一个<code>Vue</code>的构建环境就搭建完成了</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e008d28.png" alt="image-20230419135928971.png"></p><h3 id="3、Vue函数的封装"><a href="#3、Vue函数的封装" class="headerlink" title="3、Vue函数的封装"></a>3、Vue函数的封装</h3><p>【目标】封装一个 Vue 函数并且在 index.html 中引入</p><p>【前置知识】</p><p>在js中函数和class都可以new，如下：有啥区别呢 ？</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e5aa25b.png" alt="Snipaste_2023-08-20_16-04-06.png"></p><p>class <strong>类是用于创建对象的模板。</strong></p><p>我们使用 class 关键字来创建一个类，类体在一对大括号 <strong>{}</strong> 中，我们可以在大括号 <strong>{}</strong> 中定义类成员的位置，如方法或构造函数。</p><p>每个类中包含了一个特殊的方法 **constructor()**，它是类的构造函数，这种方法用于创建和初始化一个由 <strong>class</strong> 创建的对象。</p><p>创建一个类的语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>在js中除了class函数也可以new，函数本身就是对象，在js中每定义一个函数都会同时生成一个以这个函数体为构造函数的对象，不信你试试</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e6d4278.png" alt="image-20230704111250514.png"></p><p>可以通过对象来new出一个新的对象。定义 function Vue(options){} 时， 实际上生成了一个Function类型（预定义类型）的对象，对象名叫Vue，对象的构造函数就是这个函数的体。如下</p><p>我们在初始化<code>Vue</code>项目的时候使用到<code>new</code>关键字，这里的vue是使用函数定义的。目的是提升vue的灵活性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = options.<span class="property">name</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = options.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【思考】为什么vue使用函数定义而其他的watcher observer使用class定义？</p><p>【回答】核心目的：提升Vue的灵活性：</p><p>1、class的所有方法都是不可枚举的，而function声明的函数是可以枚举的。用户可以根据需要定制重写（重载）vue提供的成员方法</p><p>2、function 既能当常规函数来用，又能当做函数的属性来用，又能当类来用。相对class更加灵活。</p><p>3、对于内部定义的不希望修改的方法，通过class来定义，另外class声明的函数会有变量提升。</p><p>下面我们实例化一个Vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时在 vm 实例上就具有了 name 和 data 属性</p><p>接下来我们在<code>src/index.js</code>中定义这个类并导出。在构造函数中获取传入的<code>options</code>并挂载到<code>vue</code>实例上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vue构造器执行&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  vm.<span class="property">$options</span> = options        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在 <strong>dist&#x2F;index.html</strong>中实例化一个Vue对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 vue.js，将会绑定到 window--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">a</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">b</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">c</span>: <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&quot;hello world!&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e0cb735.png" alt="image-20230505142517798.png"></p><p>此时我们访问<code>Vue</code>对象中data里面定义的数据不能直接访问，必须通过<code>vue.data.xxx</code>访问，实际在<code>Vue</code>项目中<code>data</code>里面定义的数据是可以直击访问的，所以我们需要给<code>data</code>中的数据添加一个代理实现数据的直接访问。</p><h3 id="4、核心函数-Object-defineProperty-的介绍和简单响应式的实现"><a href="#4、核心函数-Object-defineProperty-的介绍和简单响应式的实现" class="headerlink" title="4、核心函数 Object.defineProperty 的介绍和简单响应式的实现"></a>4、核心函数 Object.defineProperty 的介绍和简单响应式的实现</h3><p>【目标】能够了解Object.defineProperty的用法，并且实现一个简单的响应式</p><p>为了实现vue中的数据代理，我们需要首先了解一下vue中的响应式核心方法Object.defineProperty</p><p>Object.defineProperty 在 vue2 中起到了非常重要的作用，通过Object.defineProperty实现了数据的代理，数据响应式原理，以及vue中的一些重要成员方法。下面我们学习Object.defineProperty的基本概念和用法。</p><p>语法：**<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty(obj, prop, descriptor)</a>**<br>其中：<strong>obj</strong>要在其上定义属性的对象。<strong>prop</strong>要定义或修改的属性的名称。<strong>descriptor</strong>将被定义或修改的属性描述符。</p><p>参数：    1、obj : 第一个参数就是要在哪个对象身上添加或者修改属性</p><p>​2、prop : 第二个参数就是添加或修改的属性名</p><p>​3、desc ： 配置项，一般是一个对象 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">desc 的详细配置</span><br><span class="line">writable：是否可重写</span><br><span class="line">value：  当前值 </span><br><span class="line">enumerable： 是否可以遍历</span><br><span class="line">configurable： 是否可再次修改配置项</span><br><span class="line">get：     读取时内部调用的函数</span><br><span class="line">set：        写入时内部调用的函数</span><br><span class="line"></span><br><span class="line">当数据调用的时候触发get 方法，当数据修改的时候触发set方法</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 通过 Object.defineProperty 设置的属性默认是不可修改，不可枚举，不可配置</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以枚举</span></span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span> <span class="comment">// 是否可以修改</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【思考】什么是响应式？</p><p>【回答】对外界的变化做出反应</p><p>【思考】数据响应式的核心思想是什么？</p><p>【回答】将数据变成可观察的</p><p>下面我们来实现一个简单的数据响应式过程，在 dist 下新建一个 **defineproperty.html **</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 定义数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 实现数据的渲染</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3. 当视图改变数据改变</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4. 当数据改变驱动视图更新</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">value</span>: <span class="string">&#x27;hello kilito&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">dir</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        data.<span class="property">value</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="property">value</span> = data.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 这里的value的作用是形成闭包，拓展函数体内部变量的作用域</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, prop, value, cb</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生获取&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> value</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生了修改！&#x27;</span>, val)</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 将数据修改之后的值 val 在get中返回</span></span></span><br><span class="line"><span class="language-javascript">                value = val</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">cb</span>(val)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineReactive</span>(data, <span class="string">&#x27;value&#x27;</span>, data[<span class="string">&#x27;value&#x27;</span>], update)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// data.value = &#x27;123&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 数据发生了修改！ 123</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#x27;123&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 视图发生了改变 123</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e6bd2fe.png" alt="Snipaste_2023-08-20_16-04-59.png"></p><p>【思考】数据获取的时候触发的哪个方法，数据修改的时候触发的哪个方法？</p><p>【回答】获取触发get 修改触发set</p><p>【思考】上面这段代码实现了什么呢？</p><p>【回答】实现了数据的双向绑定，数据改变视图改变，视图改变数据也改变</p><p>【思考】定义defineReactive函数的时候，里面第三个参数value的作用？</p><p>【回答】在函数体内部形成闭包结构，用开来拓展函数内部变量的作用域</p><h3 id="5、通过data代理，实现数据的访问"><a href="#5、通过data代理，实现数据的访问" class="headerlink" title="5、通过data代理，实现数据的访问"></a>5、通过data代理，实现数据的访问</h3><p>【目标】实现data的代理可以直接通过vm实例获取data中定义的数据</p><p>【思考】在 vue 中的数据是存放在 data 中为什么可以通过 vm.XXX 直接访问数据呢？</p><p>【回答】通过数据代理实现数据的访问</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e26c0fb.png" alt="image-20230704114327873.png"></p><p>此时我们想获取数据 a 需要通过 Vue.$options.data.a ，但是在 vue 中只需要 this.a 就可以获取到 a 的值，这是怎么实现的呢？</p><p>在 Vue 中，可以在外部直接通过vm实例进行数据访问和操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">         <span class="attr">b</span>: &#123;</span><br><span class="line">          <span class="attr">c</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">message</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>当前代码中，外部通过vue实例只能拿到 <code>vue.$options</code>，想要拿到<code>data</code>需要 <code>vue.$options.data</code>，要想实现<code>vue.message</code>和<code>vue.$options.data.message</code>等效，就需要想办法将<code>vue</code>实例操作“代理”到<code>$options.data</code>上；这样，就实现了 Vue 的数据代理我们来观察一下vue的实例，在实例上有一个_data属性 还有我们定义的变量。</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c861f0ef8.png" alt="image-20230704115013875.png"></p><p>首先，先做一次代理，将<code>data</code>挂载到 vue._data下（因为Object.defineProperty的第一个参数必须为一的对象，我们，第一层代理更加方便我们在实现属性的追加），这样 vue 实例就能够在外部通过<code>vue._data.message</code>获取到<code>data.message</code>；</p><p>之后，再做一次代理，将 vue 实例操作 vue.message 代理到 vue.<em>data 上，这样，外部就可以直接通过vue.message 获取到 data.message；</em></p><p>Vue 状态初始化阶段，通过 observe() 实现数据响应式之后，通过 Object.defineProperty 对 _data 中的数据操作进行劫持；将 vue.xxx 在 vue 实例上的取值操作，代理到 vue._data.xxx 上，这样可以简化书写。</p><p>下面我们开始实现数据的代理</p><p><code>data</code>挂载到 vue._data下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vue构造函数执行&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">  vm.<span class="property">$options</span> = options</span><br><span class="line">    <span class="comment">// options.data 可能是对象也可能是函数</span></span><br><span class="line">  vm.<span class="property">_data</span> = <span class="title function_">typeof</span>(options.<span class="property">data</span>) === <span class="string">&#x27;function&#x27;</span> ? options.<span class="title function_">data</span>() : options.<span class="property">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将vue实例操作vue.message代理到vue._data上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据代理 实现非侵入的数据修改</span></span><br><span class="line"><span class="comment">// 定义代理方法</span></span><br><span class="line"><span class="comment">// 将vue实例上的操作，代理到 vue._data上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_proxy</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        set (val) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_data</span>[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在Vue的构造器中使用proxy方法代理数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vue构造函数执行&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    vm.<span class="property">$options</span> = options</span><br><span class="line">    vm.<span class="property">_data</span> = <span class="title function_">typeof</span>(options.<span class="property">data</span>) === <span class="string">&#x27;function&#x27;</span> ? options.<span class="title function_">data</span>() : options.<span class="property">data</span></span><br><span class="line">    _proxy.<span class="title function_">call</span>(vm,vm.<span class="property">_data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再访问vue对象中的数据，就不需要.data了，观察打印结果：当从vue实例取值时，就会被代理到vm._data取值；</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c81d1b531.png" alt="Snipaste_2023-08-20_15-54-59.png"></p><p>【总结】vue中实现数据直接访问的实现步骤</p><p>1、将 data 暴露在 vue._ <em>data 实例属性上<br>2、利用 Object.defineProperty 将 vue.xxx 操作代理到 vue.</em> _data 上</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS设计模式"><a href="#JS设计模式" class="headerlink" title="JS设计模式"></a>JS设计模式</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">传送门:wiki-设计模式</a></p><p><a href="https://www.ituring.com.cn/book/1632">传送门:JavaScript设计模式与开发实践</a></p></blockquote><p>设计模式的指的是：在<strong>面向对象软件</strong>设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。</p><p>目前说到设计模式，一般指的是《设计模式：可复用面向对象软件的基础》一书中提到的<strong>23种</strong>常见的软件开发设计模式。</p><p>JavaScript中不需要生搬硬套这些模式，咱们结合实际前端开发中的具体应用场景，来看看有哪些常用的设计模式</p><p>这一节咱们会学习:</p><ol><li>JS中的常用设计模式</li><li>设计模式在开发&#x2F;框架中的应用场景</li></ol><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>在JavaScript中，工厂模式的表现形式就是一个<strong>直接调用即可返回新对象的函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数并实例化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;柯基&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ToyFactory</span>(<span class="params">name,price</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> toy1 = <span class="title class_">ToyFactory</span>(<span class="string">&#x27;布娃娃&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> toy2 = <span class="title class_">ToyFactory</span>(<span class="string">&#x27;玩具车&#x27;</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ol><li><p>Vue2-&gt;Vue3: </p><ol><li>启用了<code>new Vue</code>,改成了工厂函数<code>createApp</code>-<a href="https://v3-migration.vuejs.org/zh/breaking-changes/global-api.html">传送门</a></li><li><em><strong>任何全局改变 Vue 行为的 API(vue2) 现在都会移动到应用实例上(vue3)</strong></em></li><li>就不会出现,Vue2中多个Vue实例共享,相同的全局设置,可以<strong>实现隔离</strong></li><li>避免vue2中全局设置的东西，比如组件，影响后续实例</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#app1</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#app2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>vue2-全局注册组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">    实例1 组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">my-title</span>&gt;</span><span class="tag">&lt;/<span class="name">my-title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">    实例2</span><br><span class="line">    <span class="tag">&lt;<span class="name">my-title</span>&gt;</span><span class="tag">&lt;/<span class="name">my-title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.7.9/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 全局注册组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-title&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 组件的结构</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">template</span>: <span class="string">&#x27;&lt;h2 style=&quot;color:orange&quot;&gt;标题组件&lt;/h2&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app1 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app1&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app2 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app2&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>axios.create:</p><ol><li>基于传入的配置创建一个新的<code>axios</code>实例,<a href="https://www.axios-http.cn/docs/instance">传送门</a></li><li>项目中有2个请求基地址如何设置?</li><li>创建出多个请求不同的对象，比如设置多个基地址</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 基于不同基地址创建多个 请求对象</span></span><br><span class="line"><span class="keyword">const</span> request1 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;基地址1&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> request2 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;基地址2&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> request3 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;基地址3&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过对应的请求对象,调用接口即可</span></span><br><span class="line"><span class="title function_">request1</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;基地址1的接口&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">request2</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;基地址2的接口&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">request3</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;基地址3的接口&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>小结:</p><ol><li>工厂模式:JS中的表现形式,<strong>返回新对象的函数(方法)</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>日常开发中,有2个很经典的场景</p><ol><li><code>vue3</code>中创建实例的api改为<code>createApp</code>,<code>vue2</code>中是<code>new Vue</code><ol><li>Vue3中,没有影响所有Vue实例的api了,全都变成了影响某个app对象的api,比如<code>Vue.component--&gt;app.component</code></li></ol></li><li><code>axios.create</code>基于传入的配置,创建一个新的请求对象,可以用来设置多个基地址</li></ol></li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>单例模式指的是，在使用这个模式时，单例对象整个系统需要保证只有一个存在。</strong></p><p><strong>需求:</strong></p><ol><li>通过静态方法<code>getInstance</code>获取<strong>唯一实例</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1===s2)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义类</li><li>私有静态属性:<code>#instance</code></li><li>提供静态方法<code>getInstance</code>:<ol><li>调用时判断<code>#instance</code>是否存在:</li><li>存在:直接返回</li><li>不存在:实例化,保存,并返回</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">   <span class="comment">// 私有属性，保存唯一实例</span></span><br><span class="line">   <span class="keyword">static</span> #instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取单例的方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(this) // SingleTon类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">SingleTon</span>.#instance === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 内部可以调用构造函数</span></span><br><span class="line">      <span class="title class_">SingleTon</span>.#instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SingleTon</span>.#instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1===s2)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>实际应用:</strong></p><ol><li>vant组件库中的弹框组件,保证弹框是单例<ol><li>toast组件:<a href="https://gitee.com/vant-contrib/vant/blob/main/packages/vant/src/toast/index.ts">传送门</a></li><li>notify组件:<a href="https://gitee.com/vant-contrib/vant/blob/main/packages/vant/src/notify/index.ts">传送门</a></li><li>如果弹框对象<ol><li>不存在,–&gt;创建一个新的</li><li>存在,直接用</li></ol></li></ol></li><li>vue中注册插件,用到了单例的思想(只能注册一次)<ol><li>vue2:<a href="https://gitee.com/vuejs/vue/blob/main/src/core/global-api/use.ts">传送门</a></li><li>vue3:<a href="https://gitee.com/vuejs/core/blob/main/packages/runtime-core/src/apiCreateApp.ts#L256">传送门</a></li></ol></li></ol><p><strong>小结:</strong></p><ol><li><p>单例模式:</p><ol><li>保证,应用程序中,某个对象,只能有一个</li></ol></li><li><p>自己实现:</p><ol><li>getInstance方法,<ol><li>实例存在-&gt;返回</li><li>实例不存在-&gt;创建,保存-&gt;返回</li></ol></li></ol></li><li><p>应用场景:</p><ol><li>我在看源码的时候,发现,vant的toast和notify组件都用到了单例<ol><li>多次弹框,不会创建多个弹框,复用唯一的弹框对象</li></ol></li><li>vue中注册插件,vue3和vue2都会判断插件是否已经注册,已注册,直接提示用户</li></ol></li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在对象之间定义一个<strong>一对多</strong>的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p><strong>举个例子:</strong></p><ol><li><code>dom</code>事件绑定，比如</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load触发1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load触发2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load触发3&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Vue的生命周期钩子:</p><ol><li>vue框架,提供给开发者,在Vue实例特定时期,添加自定义逻辑的,一种机制.</li><li>一共有：<ol><li>beforeCreated </li><li>created</li><li>beforeMount </li><li>Mounted </li><li>beforeUpdate </li><li>Updated </li><li>beforeDestory </li><li>destoryed</li><li>缓存组件（keep-alive）：activated  deactivated</li></ol></li></ol></li><li><p>Vue的响应式原理:</p><ol><li><p><a href="https://v2.cn.vuejs.org/v2/guide/reactivity.html">传送门</a></p></li><li><p><strong>自己描述：响应式原理</strong></p><ol><li><p>创建Vue实例时，会通过Object.definedProperty将data中的数据的每个属性都转为get和set</p></li><li><p>就可以监测到对数据的，取值get和赋值set</p></li><li><p>只要数据发生了变更，就会去通知所有使用数据为止，更新</p><ol><li>页面</li><li>侦听器</li><li>…</li></ol><p><img src="https://bu.dusays.com/2023/08/19/64e0ac0f284d5.png" alt="vue响应式原理.png"></p></li></ol></li><li><p>自己描述2-涉及到虚拟dom：</p><ol><li>可能被追问：<ol><li>为什么需要使用<strong>虚拟dom</strong>？ 虚拟dom内存中，速度快</li><li>新旧dom比较，如何比较的？ <ol><li><strong>diff算法</strong> 找不同</li><li>vue中同级比较<ol><li>有id，id不同，直接不同</li><li>没有id，比元素，在比属性</li></ol></li></ol></li><li>vue的diff算法和react的diff算法有什么区别？</li></ol></li></ol><p><img src="https://bu.dusays.com/2023/08/19/64e0ac9e5e0c8.png" alt="vue响应式原理2.png"></p></li><li><p>自己回答：</p><ol><li>vue2中使用的是 Object.definedProperty，动态新增的属性，没有响应式，this.$set</li><li>vue3中是Proxy<ol><li>没有这个问题，Proxy可以检测到所有属性的改变</li><li>vue3中只用了 Proxy 吗？不是，引用了<code>Object.definedProperty</code></li></ol></li></ol></li></ol></li></ol><h3 id="发布订阅模式01-应用场景"><a href="#发布订阅模式01-应用场景" class="headerlink" title="发布订阅模式01-应用场景"></a>发布订阅模式01-应用场景</h3><p>发布订阅模式可以实现的效果类似观察者模式,但是两者略有差异,一句话描述:一个有中间商(<strong>发布订阅模式</strong>)一个没中间商(<strong>观察者模式</strong>)</p><p><img src="https://bu.dusays.com/2023/08/19/64e0ca7198385.png" alt="image-20230626153656768.png"></p><p><img src="https://bu.dusays.com/2023/08/19/64e0ca7198385.png" alt="image-20230706002933258.png"></p><p><strong>应用场景:</strong></p><ol><li><code>vue2</code>中的<code>EventBus</code>:<a href="https://v2.cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6">传送门</a></li><li><code>vue3</code>中因为移除了实例上对应方法，可以使用替代方案:<a href="https://v3-migration.vuejs.org/zh/breaking-changes/events-api.html">传送门</a><ol><li>官方推荐,用插件</li><li>微微一笑:直接写</li></ol></li></ol><h3 id="发布订阅模式02-自己写一个事件总线"><a href="#发布订阅模式02-自己写一个事件总线" class="headerlink" title="发布订阅模式02-自己写一个事件总线"></a>发布订阅模式02-自己写一个事件总线</h3><p><strong>需求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> <span class="title class_">HMEmitter</span>()</span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">bus.$on(<span class="string">&#x27;事件名1&#x27;</span>,回调函数)</span><br><span class="line">bus.$on(<span class="string">&#x27;事件名1&#x27;</span>,回调函数)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">bus.$emit(<span class="string">&#x27;事件名&#x27;</span>,参数<span class="number">1</span>,...,参数n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">bus.$off(<span class="string">&#x27;事件名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性事件</span></span><br><span class="line">bus.$once(<span class="string">&#x27;事件名&#x27;</span>,回调函数)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义类</li><li>私有属性:<code>#handlers=&#123;事件1:[f1,f2],事件2:[f3,f4]&#125;</code></li><li>实例方法:<ol><li>$on(事件名,回调函数):注册事件</li><li>$emit(事件名,参数列表):触发事件</li><li>$off(事件名):移除事件</li><li>$once(事件名,回调函数):注册一次性事件</li></ol></li></ol><p><strong>基础模板:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>自己实现事件总线<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;on&quot;</span>&gt;</span>注册事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;emit&quot;</span>&gt;</span>触发事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span>移除事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;once-on&quot;</span>&gt;</span>一次性事件注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;once-emit&quot;</span>&gt;</span>一次性事件触发<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">class</span> <span class="title class_">HMEmmiter</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 逻辑略</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 简化 querySelector调用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">qs</span>(<span class="params">selector</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 注册事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.on&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 触发事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.emit&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 移除事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.off&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 一次性事件注册</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.once-on&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 一次性事件触发</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.once-emit&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HMEmmiter</span> &#123;</span><br><span class="line">  #handlers = &#123;&#125;</span><br><span class="line">  <span class="comment">// 注册事件</span></span><br><span class="line">  $on(event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.#handlers[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#handlers[event] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册继续push</span></span><br><span class="line">    <span class="variable language_">this</span>.#handlers[event].<span class="title function_">push</span>(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  $emit(event, ...args) &#123;</span><br><span class="line">      <span class="comment">// 取出保存的时间 []</span></span><br><span class="line">    <span class="keyword">const</span> funcs = <span class="variable language_">this</span>.#handlers[event] || []</span><br><span class="line">      <span class="comment">// 挨个触发，并传入参数</span></span><br><span class="line">    funcs.<span class="title function_">forEach</span>(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">func</span>(...args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  $off(event) &#123;</span><br><span class="line">      <span class="comment">// event 对应的回调函数数组设置空即可</span></span><br><span class="line">    <span class="variable language_">this</span>.#handlers[event] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一次性事件:注册了以后，只能触发一次</span></span><br><span class="line">  $once(event, callback) &#123;</span><br><span class="line">      <span class="comment">// 触发之后，清空，移除</span></span><br><span class="line">    <span class="variable language_">this</span>.$on(event, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 callback</span></span><br><span class="line">      <span class="title function_">callback</span>(...args)</span><br><span class="line">        <span class="comment">// 移除注册的event事件</span></span><br><span class="line">      <span class="variable language_">this</span>.$off(event)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过<strong>克隆原型</strong>的方式来创建出一个与原型一样（共享一套数据&#x2F;方法）的对象。在<code>JavaScript</code>中,<code>Object.create</code>就是实现原型模式的内置<code>api</code></p><p><strong>应用场景:</strong></p><p><code>vue2</code>中重写数组方法:</p><ol><li>调用方法时(<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>)可以触发视图更新:<a href="https://v2.cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95">传送门</a></li><li>源代码:<a href="https://gitee.com/vuejs/vue/blob/main/src/core/observer/array.ts">传送门</a>&#96;</li><li>测试一下:</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>原型模式<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.7.9/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">foods</span>: [<span class="string">&#x27;西瓜&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">foods</span>.<span class="property">push</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/19/64e0bad8f3abf.png" alt="原型模式.png"></p><p><strong>自己描述:</strong></p><ol><li>vue2中数组重写了7个方法,内部基于数组的原型<code>Array.prototype</code>创建了一个新对象</li><li><code>Object.create</code>浅拷贝</li><li>内部<ol><li>调用数组的原方法,获取结果并返回—方法的功能和之前一致</li><li>通知了所有的观察者去更新视图</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">arr</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="property">arr</span>.<span class="property">push</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>原型模式,基于某个对象,创建一个新的对象,JS中,通过Object.create即可实现,Vue中重写数组方法就是这么做的 ↑</li></ol><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式指的是<strong>拦截和控制</strong>与目标对象的交互,在<code>JavaScript</code>中通过<code>Proxy</code>,即可实现对象的代理,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">传送门</a></p><p><strong>核心语法:</strong></p><ol><li>初始对象可以直接修改任意属性</li><li>通过<code>Proxy</code>生成代理对象，限制访问</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前obj对象的name和age属性可以被随意修改</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Proxy创建代理对象 </span></span><br><span class="line"><span class="comment">// 最大的特点就是，无论操作的属性，在对象上是否存在 都会触发 get set</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// []语法进行对象的取值和赋值</span></span><br><span class="line">    <span class="comment">// target: 源对象</span></span><br><span class="line">    <span class="comment">// key： 属性名</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get触发&#x27;</span>)</span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 结合Reflect的静态方法替换[]语法</span></span><br><span class="line">    <span class="comment">// target: 源对象</span></span><br><span class="line">    <span class="comment">// key： 属性名</span></span><br><span class="line">    <span class="comment">// value：设置的值</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set触发&#x27;</span>)</span><br><span class="line">   <span class="comment">// target[key]=value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 代理对象属性赋值，触发set</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;rose&#x27;</span></span><br><span class="line"><span class="comment">// 代理对象属性取值，触发get</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p><strong>需求:</strong></p><p>基于上一份代码实现:</p><ol><li>属性取值和赋值时,如果属性不存在,报错</li><li>修改name时,只能设置字符串,否则报错</li></ol><p><strong>关键步骤:</strong></p><ol><li>在<code>get</code>中添加取值判断逻辑</li><li>在<code>set</code>中添加赋值判断逻辑</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前obj对象的name和age属性可以被随意修改</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Proxy创建代理对象 </span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// []语法进行对象的取值和赋值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target[key]) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;属性不存在&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target[key])&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;属性不存在&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断类型</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        target[key]=value</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;name属性只能设置字符串&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 代理对象属性赋值，触发set</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;rose&#x27;</span></span><br><span class="line"><span class="comment">// 不存在friend 报错</span></span><br><span class="line">objProxy.<span class="property">friend</span> = <span class="string">&#x27;rose&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>实际应用:</strong></p><p><code>Vue3</code>的响应式原理-<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue">传送门</a></p><ol><li><p>通过<code>Proxy</code>创建响应式对象</p></li><li><p><code>getter/setter</code>用于<code>ref</code></p></li><li><p>Vue2考虑兼容,用的是兼容性好的<code>Object.defineProperty</code>,但是无法跟踪动态增加的属性</p></li><li><p><code>Vue3</code>中用了<code>Proxy</code>,他对于动态增加的属性,也可以检测到,但是Vue3中也用了<code>Object.defineProperty</code></p><ol><li><p><code>reactive</code>用的是<code>Proxy</code></p><ol><li>注意点:解构之后会丢失响应性,需要用<code>toRefs</code></li></ol></li><li><p><code>ref</code>用的是<code>Object.defineProperty</code></p></li></ol></li><li><p>观察者模式–&gt;虚拟dom-&gt;diff算法</p></li></ol><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示.简而言之就是:<strong>遍历</strong></p><p>遍历作为日常开发中的<strong>高频</strong>操作,JavaScript中有大量的默认实现:<strong>比如</strong></p><ol><li><code>Array.prototype.forEach</code>:遍历数组</li><li><code>NodeList.prototype.forEach</code>:遍历<code>dom</code>,<code>document.querySelectorAll</code></li><li><code>for in</code></li><li><code>for of</code></li></ol><p><strong>面试题</strong>:</p><ol><li><p><code>for in</code> 和<code>for of</code> 的区别?</p><ol><li><p><strong><code>for...in</code></strong> <strong>语句</strong>以任意顺序迭代一个对象的除<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a>属性，包括继承的可枚举属性。</p><ol><li>对象默认的属性以及动态增加的属性都是<strong>可枚举</strong>属性</li><li>遍历出来的是<strong>属性名</strong></li><li>继承而来的属性也会遍历</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 原型上默认的属性和方法,都是不可枚举(for in不出来)</span></span><br><span class="line">    <span class="comment">// 动态添加的,默认是可枚举(可以for in出来)</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;奔跑&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">swim</span> = <span class="string">&#x27;游泳&#x27;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="string">&#x27;小鸡&#x27;</span>, <span class="string">&#x27;小鸭&#x27;</span>, <span class="string">&#x27;小鱼&#x27;</span>]</span><br><span class="line">        <span class="comment">// 遍历的是key,继承而来的属性也可以遍历出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;key:&#x27;</span>, key) <span class="comment">// key: 0  key: 1  key: 2  key: swim  key: run  </span></span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 遍历的值,继承而来的遍历不出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iterator:&#x27;</span>, iterator) <span class="comment">// key: 小鸡 key: 小鸭 key: 小鱼</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>for...of</code>语句</strong>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">可迭代对象</a>（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a> 对象等等）上创建一个迭代循环</p><ol><li>for of不会遍历<strong>继承</strong>而来的属性</li><li>遍历出来的是<strong>属性值</strong></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;小鸡&#x27;</span>, <span class="string">&#x27;小鸭&#x27;</span>, <span class="string">&#x27;小鱼&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 obj可以 for of for of出来的是他内部的 数组</span></span><br><span class="line"><span class="comment">// 自定义 forof执行的行为</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: <span class="string">&#x27;rose&#x27;</span>,</span><br><span class="line">  <span class="attr">skill</span>: <span class="string">&#x27;jump together&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;沙县&#x27;</span>, <span class="string">&#x27;猪脚饭&#x27;</span>, <span class="string">&#x27;手撕鸡&#x27;</span>],</span><br><span class="line">  <span class="comment">// 属性名表达式</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// console.log(this)</span></span><br><span class="line">    <span class="comment">// 返回一个对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">foods</span>[index++]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历的值,继承而来的遍历不出来</span></span><br><span class="line"><span class="comment">// for (const iterator of arr) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;iterator:&#x27;, iterator)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for of 并不能遍历所有的东西,比如 object无法遍历</span></span><br><span class="line"><span class="comment">// 直接遍历对象: obj is not iterable,obj不可迭代</span></span><br><span class="line"><span class="comment">// [Symbol.iterator] 添加之后,可以迭代,要求返回特定格式的对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iterator:&#x27;</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可迭代协议和迭代器协议:</strong></p><ol><li><p>可迭代协议:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">传送门</a></p><ol><li>给对象增加属方法<code> [Symbol.iterator]()&#123;&#125;</code></li><li>返回一个符合迭代器协议的对象</li></ol></li><li><p>迭代器协议:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">传送门</a></p><ol><li>next方法,返回对象:<ol><li><code>&#123;done:true&#125;</code>,迭代结束</li><li><code>&#123;done:false,value:&#39;xx&#39;&#125;</code>,获取解析并接续迭代</li></ol></li></ol></li><li><p>面试问及:</p><ol><li>for of可以遍历一部分的类型,比如数组,map</li><li>对象无法遍历,因为对象没有实现 可迭代协议,迭代器协议</li><li>可迭代协议,迭代器协议,约定了:<ol><li>可迭代协议:对象上要有一个指定属性的函数,返回 满足迭代器要求的对象</li><li>迭代器协议: <code>next</code>方法,返回<code>&#123;done:true&#125;,&#123;done:false,value:&#39;x&#39;&#125;</code></li><li>我自己尝试写过一下,但是仅针对语法</li><li>可以和面试官讨论一下,可以用在哪?</li></ol></li></ol></li><li><p>直接打印对象,看到<strong>Symbol(Symbol.iterator)</strong>,说明可以使用<code>for of</code></p></li></ol><h2 id="JS调用栈"><a href="#JS调用栈" class="headerlink" title="JS调用栈"></a>JS调用栈</h2><ol><li>执行上下文和调用栈</li><li>栈溢出</li></ol><h3 id="执行上下文和调用栈"><a href="#执行上下文和调用栈" class="headerlink" title="执行上下文和调用栈"></a>执行上下文和调用栈</h3><p><a href="https://262.ecma-international.org/6.0/">执行上下文</a>:是指在代码执行时，JavaScript引擎创建的一种数据结构，它包含了函数执行时的状态信息，例如变量、函数参数、函数返回值等。</p><p>在以下三种情况下会创建执行上下文</p><ol><li><p>JavaScript执行全局代码时，创建<strong>全局执行上下文</strong></p></li><li><p>调用函数时，创建<strong>函数执行上下文</strong></p></li><li><p>使用 eval 函数时，创建<strong>执行上下文</strong></p><ol><li>给他一个字符串,解析为js并执行</li></ol></li></ol><p>我们通过调试工具确认一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funA</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funcB</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="title function_">funA</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> res + c</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="title function_">funcB</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 执行函数时，创建对应执行上下文，内部保存变量，代码等一系列执行函数需要的东西</span></span><br><span class="line"><span class="comment">// 进入JS调用堆栈，执行 ==&gt; 执行完毕之后 =&gt; 出栈</span></span><br><span class="line"><span class="comment">// 所有代码执行完毕为止</span></span><br></pre></td></tr></table></figure><p><strong>调用栈:</strong></p><ol><li>执行上下文会存在JS调用栈中,栈的结构特点是:<strong>先进后出</strong></li></ol><p><img src="https://bu.dusays.com/2023/08/19/64e0ca6fa8242.png" alt="image-20230706133635838.png"></p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈的容量是有限的,如果内部的内容一直得不到释放,就会出现栈溢出,比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈溢出，JS调用栈有容量大小，太大了，会溢出</span></span><br><span class="line"><span class="comment">// JS调用堆栈装满了之后，就会出现</span></span><br><span class="line"><span class="comment">// Maximum call stack size exceeded</span></span><br><span class="line"><span class="comment">// 日常开发常见的：</span></span><br><span class="line"><span class="comment">// 1. 死递归</span></span><br><span class="line"><span class="comment">// 2. 导航守卫</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  i++</span><br><span class="line">  <span class="title function_">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/19/64e0ca7057592.png" alt="image-20230708104801552.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><img src="https://bu.dusays.com/2023/08/19/64e0a7aa72c29.png" alt="设计模式1.png"><br><img src="https://bu.dusays.com/2023/08/19/64e0de1ab6975.png" alt="设计模式2.png"><br><img src="https://bu.dusays.com/2023/08/19/64e0de18eb2b5.png" alt="设计模式3.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://wangdoc.com/es6/">阮一峰-《ECMAScript 6 教程》</a></li><li><a href="https://www.ituring.com.cn/book/2472">图灵社区-JavaScript高级程序设计</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原理二</title>
      <link href="/posts/882eae5.html"/>
      <url>/posts/882eae5.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>Currying 又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p> 柯里化 作为一种高阶技术, 可以提升函数的复用性和灵活性。</p><h3 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h3><p>函数柯里化 (Currying) 是一种<strong>将多个参数的函数转换为单个参数函数</strong>的技术</p><p>转换完毕之后的函数:<strong>只传递函数的一部分参数来调用，让他返回一个新的函数去处理剩下的参数。</strong></p><p><strong>例子:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整函数 sum</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写为 可以实现如下效果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>))<span class="comment">// </span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><code>sum</code>改为接收一个参数，返回一个新函数</li><li>新函数内部将<strong>参数1</strong>，<strong>参数2</strong>累加并返回</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化面试题-全局变量"><a href="#柯里化面试题-全局变量" class="headerlink" title="柯里化面试题-全局变量"></a>柯里化面试题-全局变量</h3><p>柯里化在面试的时候一般以笔试题出现,比如</p><p><strong>需求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改写函数sum实现:参数传递到5个即可实现累加</span></span><br><span class="line"><span class="comment">// sum(1)(2)(3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3,4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4,5)</span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>接收不定长参数</li><li>存储已传递的参数</li><li>判断长度<ol><li>满足5:累加</li><li>不满足:继续返回<strong>函数本身</strong></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存参数</span></span><br><span class="line"><span class="keyword">let</span> nums = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currySum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 将传入的参数 保存到数组中</span></span><br><span class="line">  nums.<span class="title function_">push</span>(...args)</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curv</span>) =&gt;</span> prev + curv, <span class="number">0</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currySum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化面试题-使用闭包"><a href="#柯里化面试题-使用闭包" class="headerlink" title="柯里化面试题-使用闭包"></a>柯里化面试题-使用闭包</h3><p><strong>需求:</strong></p><ol><li>使用<strong>闭包</strong>将上一节代码中的全局变量,保护起来</li><li>支持自定义累加的参数个数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMaker</span>(<span class="params">length</span>)&#123;</span><br><span class="line">    <span class="comment">// 逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支持5个累加</span></span><br><span class="line"><span class="keyword">const</span> sum5 = <span class="title function_">sumMaker</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 支持7个累加</span></span><br><span class="line"><span class="keyword">const</span> sum7 = <span class="title function_">sumMaker</span>(<span class="number">7</span>)</span><br><span class="line"><span class="title function_">sum7</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义外层函数:<ol><li>定义参数<code>length</code></li><li>将全局变量迁移到函数内</li></ol></li><li>定义内层函数:<ol><li>参数长度判断,使用传入的参数<code>length</code></li><li>直接复用上一节的逻辑,并返回</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMaker</span>(<span class="params">length</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> nums = []</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="comment">// 将传递的参数保存到数组中</span></span><br><span class="line">    nums.<span class="title function_">push</span>(...args)</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">        <span class="comment">// 累加 并返回</span></span><br><span class="line">      <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curv</span>) =&gt;</span> prev + curv, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> inner</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持5个累加</span></span><br><span class="line"><span class="keyword">const</span> sum5 = <span class="title function_">sumMaker</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum5</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 支持7个累加</span></span><br><span class="line"><span class="keyword">const</span> sum7 = <span class="title function_">sumMaker</span>(<span class="number">7</span>)</span><br><span class="line"><span class="title function_">sum7</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h3 id="柯里化实际应用-类型判断"><a href="#柯里化实际应用-类型判断" class="headerlink" title="柯里化实际应用-类型判断"></a>柯里化实际应用-类型判断</h3><p>通过<strong>参数复用</strong>,实现一个<strong>类型判断生成器函数</strong></p><p><strong>需求:</strong></p><ol><li>将下列4个类型判断函数,改写为通过函数<code>typeOfTest</code>动态生成</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有如下4个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUndefined</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFunction</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为通过 typeOfTest 生成:</span></span><br><span class="line"><span class="keyword">const</span> typeOfTest =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="comment">// 参数 和 逻辑略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isUndefined = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;number&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isString = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过 isUndefined,isNumber,isString,isFunction 来判断类型:</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">isUndefined</span>(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isNumber</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">isString</span>(<span class="string">&#x27;memeda&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isFunction</span>(<span class="function">() =&gt;</span> &#123; &#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><code>typeOfTest</code>接收参数<code>type</code>用来接收判断的类型</li><li>内部返回新函数,接收需要判断的值,并基于<code>type</code>进行判断</li><li>使用箭头函数改写为最简形式~~<a href="https://github.com/axios/axios/blob/v1.x/lib/utils.js#L20">传送门</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">typeOfTest</span> = type =&gt; <span class="function"><span class="params">thing</span> =&gt;</span> <span class="keyword">typeof</span> thing === type  </span><br></pre></td></tr></table></figure><h3 id="柯里化实际应用-固定参数"><a href="#柯里化实际应用-固定参数" class="headerlink" title="柯里化实际应用-固定参数"></a>柯里化实际应用-固定参数</h3><p>依旧是一个<strong>参数复用</strong>的实际应用</p><p><strong>需求:</strong></p><ol><li>将如下3个请求的函数(都是<strong>post</strong>请求),变为通过<code>axiosPost</code>函数动态生成</li><li>实现函数<code>axiosPost</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将如下3个请求,改写为调用 axiosPost函数即可实现</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;url1&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;url3&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">axiosPost</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 参数,逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axiosPost</span>(<span class="string">&#x27;url1&#x27;</span>, data1)</span><br><span class="line"><span class="title function_">axiosPost</span>(<span class="string">&#x27;url2&#x27;</span>, data2)</span><br><span class="line"><span class="title function_">axiosPost</span>(<span class="string">&#x27;url3&#x27;</span>, data3)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>函数内部固定请求方法,post</li><li>函数内部调用<code>axios</code>发请求即可</li><li><code>axios</code>内部就是这样实现的<a href="https://github.com/axios/axios/blob/v1.x/dist/axios.js#L2667">传送门:</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">axiosPost</span> = (<span class="params">url, data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    url, data,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结:</p><ol><li><p>函数柯里化是一种函数式编程思想:<strong>将多个参数的函数转换为单个参数函数,调用时返回新的函数接收剩余参数</strong></p></li><li><p>常见面试题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改写函数sum实现:参数传递到5个即可实现累加</span></span><br><span class="line"><span class="comment">// sum(1)(2)(3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3,4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4,5)</span></span><br></pre></td></tr></table></figure></li><li><p>常见应用:固定参数,比如<code>axios</code>中的:</p><ol><li><a href="https://github.com/axios/axios/blob/v1.x/lib/utils.js#L20">类型判断函数</a></li><li><a href="https://github.com/axios/axios/blob/v1.x/dist/axios.js#L2667">get,post,put等别名方法</a></li></ol></li></ol><h2 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h2><ol><li>实现Promise的核心用法</li><li>Promise的静态方法</li><li>实现Promise的静态方法</li></ol><p>首先明确Promise的核心用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// reject(&#x27;error&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法的参数1: 状态为成功的回调函数</span></span><br><span class="line"><span class="comment">// then方法的参数2: 状态为失败的回调函数</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手写Promise-构造函数"><a href="#手写Promise-构造函数" class="headerlink" title="手写Promise-构造函数"></a>手写Promise-构造函数</h3><p><strong>需求:</strong></p><ol><li>实现MyPromise类，可以用如下的方式实例化</li><li>实例化时传入回调函数<ol><li>回调函数立刻执行</li><li>回调函数接收函数<code>resolve</code>和<code>reject</code></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve() </span></span><br><span class="line">  <span class="comment">// reject() </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义类<code>MyPromise</code></li><li>实现构造函数，接收<code>executor</code>–传入的回调函数</li><li>构造函数中定义<code>resolve</code>和<code>reject</code>并传入<code>executor</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 构造函数 </span></span><br><span class="line">  <span class="comment">// executor 执行器，实例化时立刻调用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 3. 定义 resolve reject 传入executor</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve-call&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject-call&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/17/64de3335713d9.png" alt="promise1.png"></p><h3 id="手写Promise-状态、成功or失败原因"><a href="#手写Promise-状态、成功or失败原因" class="headerlink" title="手写Promise-状态、成功or失败原因"></a>手写Promise-状态、成功or失败原因</h3><p><strong>需求:</strong></p><ol><li><code>MyPromise</code>增加<code>state</code>属性，只能是如下3个值<ol><li><code>pending</code>:待定，默认状态</li><li><code>fulfilled</code>:已兑现，操作成功</li><li><code>rejected</code>:已拒绝，操作失败</li></ol></li><li><code>MyPromise</code>增加<code>result</code>属性，记录成功&#x2F;失败原因</li><li>调用<code>resolve</code>或<code>reject</code>,修改状态,并记录成功&#x2F;失败原因</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;成功结果&#x27;)</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;失败原因&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义常量保存状态，避免<strong>硬编码</strong></li><li><code>MyPromise</code>中定义<ol><li>属性:<code>state</code>保存状态，<code>result</code>成功&#x2F;失败原因</li><li>修改<code>state</code>的私有方法，修改状态并记录<code>result</code></li><li>注意:<code>state</code>只有在<code>pending</code>时，才可以修改，且不可逆</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义常量保存状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 定义属性 state（状态） reason（成功/失败原因）</span></span><br><span class="line">  state = <span class="variable constant_">PENDING</span>  <span class="comment">// 默认状态</span></span><br><span class="line">  result = <span class="literal">undefined</span>  <span class="comment">// 成功或失败的原因 默认不知道</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 3. 实现 resolve和reject内部逻辑</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// if(this.state !== PENDING) &#123;</span></span><br><span class="line">        <span class="comment">//     return 如果状态不是等待，后面不执行 状态确定就不能改变</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// this.state = FULFILLED</span></span><br><span class="line">        <span class="comment">// this.result = result</span></span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 提取resolve和reject内部公共逻辑</span></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/17/64de3335a27f7.png" alt="promise2.png"></p><h3 id="手写Promise-then方法的核心功能"><a href="#手写Promise-then方法的核心功能" class="headerlink" title="手写Promise-then方法的核心功能"></a>手写Promise-then方法的核心功能</h3><p><strong>需求:</strong></p><ol><li>then方法的回调函数1: 状态变为<code>fulfilled</code>时触发，并获取成功结果</li><li>then方法的回调函数2: 状态变为<code>rejected</code>时触发，并获取失败原因</li><li>then方法的回调函数1或2没有传递的特殊情况处理，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#%E5%8F%82%E6%95%B0">参考:then方法的参数</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;成功结果&#x27;)</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;失败原因&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>增加<code>then</code>方法，根据不同的状态执行对应的回调函数，并传入<code>result</code><ol><li>参数1:成功的回调函数</li><li>参数2:失败的回调函数</li></ol></li><li>没有传递<code>onFulfilled</code>,<code>onRejected</code>时，设置默认值(参考文档)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 增加then方法，根据不同的状态执行对应的回调函数</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 处理未传入回调函数的特殊情况</span></span><br><span class="line">      <span class="comment">// 如果不是函数，设置为一个 接受一个参数，直接返回该参数的函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line">      <span class="comment">// 不是函数，设置一个为 接收一个参数，使用 throw 抛出的函数</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 根据状态，调用不同的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功的状态</span></span><br><span class="line">        <span class="comment">// 调用对应的回调函数，并传递结果</span></span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/17/64de33344950c.png" alt="promise3.png"></p><h3 id="手写Promise-then方法支持异步和多次调用（非链式）"><a href="#手写Promise-then方法支持异步和多次调用（非链式）" class="headerlink" title="手写Promise-then方法支持异步和多次调用（非链式）"></a>手写Promise-then方法支持异步和多次调用（非链式）</h3><p><strong>需求:</strong></p><ol><li>实例化传入的回调函数,内部支持异步操作</li><li>then方法支持多次调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;成功结果&#x27;)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;失败原因&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success1:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error1:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success2:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error2:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success3:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error3:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义属性,保存传入的回调函数:[]</li><li>调用<code>then</code>方法并且状态为<code>pending</code>时保存传入的成功&#x2F;失败回调函数</li><li>调用<code>resolve</code>和<code>reject</code>时执行上一步保存的回调函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 1. 添加handlers属性保存then方法添加的回调函数</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="comment">// 调用保存在handlers中的回调函数</span></span><br><span class="line">      <span class="comment">// 从开头部分取出回调函数执行</span></span><br><span class="line">      <span class="comment">// while(this.handlers.length &gt; 0) &#123;</span></span><br><span class="line">      <span class="comment">//    通过解构获取对应的回调函数</span></span><br><span class="line">      <span class="comment">//    const &#123; onFulfilled &#125; = this.handlers.shift()</span></span><br><span class="line">      <span class="comment">//    onFulfilled(this.result)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 4. 调用runHandlers 执行回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="comment">// 4. 调用runHandlers 执行回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 抽取方法 执行 fulfilled/rejected状态时的回调函数</span></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">          <span class="comment">// 成功</span></span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 失败</span></span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 状态为 pending 时,状态还没改变，回调函数还不能执行，将回调函数添加到数组中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        onFulfilled, onRejected</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-链式编程-成功状态-普通返回值"><a href="#手写Promise-链式编程-成功状态-普通返回值" class="headerlink" title="手写Promise-链式编程-成功状态+普通返回值"></a>手写Promise-链式编程-成功状态+普通返回值</h3><p><strong>需求:</strong></p><ol><li><code>then</code>的链式编程</li><li>目前只考虑<code>resolve</code>内部返回普通值的情况</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>调整<code>then</code>方法，返回一个新的<code>MyPromise</code>对象</li><li>内部获取<code>onFulfilled</code>的执行结果,传入<code>resolve</code>方法继续执行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="comment">// 1. 创建并返回新的Promise对象</span></span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">          <span class="comment">// 成功状态</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        <span class="comment">// 2. 继续调用resolve方法 then方法返回的Promise对象的resolve</span></span><br><span class="line">        <span class="comment">// 传递成功的结果给下一个 then</span></span><br><span class="line">        <span class="title function_">resolve</span>(res)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/18/64df4c7cc60ec.png" alt="promise4.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7da4b18.png" alt="promise5.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7569adf.png" alt="promise6.png"></p><h3 id="手写Promise-链式编程-成功状态-返回Promise"><a href="#手写Promise-链式编程-成功状态-返回Promise" class="headerlink" title="手写Promise-链式编程-成功状态+返回Promise"></a>手写Promise-链式编程-成功状态+返回Promise</h3><p><strong>需求:</strong></p><ol><li><code>then</code>的链式编程</li><li>目前考虑<code>resolve</code>内部返回<code>MyPromise</code>的情况</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>内部获取<code>onFulfilled</code>的执行结果:</li><li>如果是<code>MyPromise</code>实例，继续<code>then</code>下去并传入<code>resolve</code>和<code>reject</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        <span class="comment">// 1. 判断是否为MyPromise的实例</span></span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// 2. 继续调用then方法 传入 resolve 和 reject</span></span><br><span class="line">          res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/18/64df4c7a1e191.png" alt="promise7.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7b1b34c.png" alt="promise8.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7da8e76.png" alt="promise9.png"></p><h3 id="手写Promise-链式编程-失败状态"><a href="#手写Promise-链式编程-失败状态" class="headerlink" title="手写Promise-链式编程-失败状态"></a>手写Promise-链式编程-失败状态</h3><p><strong>需求:</strong></p><ol><li><code>then</code>的第二个回调函数，执行<code>reject</code>时的链式编程</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>参考<code>resolve</code>的逻辑</li><li>先实现功能,再抽取为函数直接调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">// const res = onFulfilled(this.result)</span></span><br><span class="line">        <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">        <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//   resolve(res)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 参考成功状态的逻辑实现 失败状态</span></span><br><span class="line">        <span class="comment">// const res = onRejected(this.result)</span></span><br><span class="line">        <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">        <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//   reject(res)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 抽取 then中的逻辑，并替换掉原本代码</span></span><br><span class="line">  #<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">     <span class="comment">// 调用回调函数 获取执行的结果</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>) </span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">        <span class="comment">// res 是promise对象 then 方法</span></span><br><span class="line">      res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-链式编程-支持异步"><a href="#手写Promise-链式编程-支持异步" class="headerlink" title="手写Promise-链式编程-支持异步"></a>手写Promise-链式编程-支持异步</h3><p><strong>需求:</strong></p><ol><li>执行异步操作时，支持链式编程</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">    .<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>then的内部将<code>resolve</code>,<code>reject</code>也推送到数组中</li><li>调整<code>runHandlers</code>函数，内部直接调用<code>runPromise</code>函数即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 2. 解构出resolve,reject执行和上一步一样的逻辑</span></span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 将 resolve和reject也推送到数组中</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected, resolve, reject</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-使用微任务"><a href="#手写Promise-使用微任务" class="headerlink" title="手写Promise-使用微任务"></a>手写Promise-使用微任务</h3><p><strong>需求:</strong></p><ol><li>如下代码打印结果为<code>1,2,4,3</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>使用<code>queueMicrotask</code>包裹<code>runPromise</code>的内部逻辑即可</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask">传送门:MDN-queueMicrotask</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">传送门:MDN-queueMicrotask使用指南</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 使用queueMicrotask 包裹内部逻辑即可</span></span><br><span class="line">  <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><p>手写<code>Promise</code>的核心代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存状态的常量 避免后续 硬编码（代码中写死某个值）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义类 后续new实例化</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">      <span class="comment">// 状态</span></span><br><span class="line">      state = <span class="variable constant_">PENDING</span></span><br><span class="line">      <span class="comment">// 成功、失败原因 结果</span></span><br><span class="line">      result = <span class="literal">undefined</span> <span class="comment">// 成功或失败的原因 默认不知道</span></span><br><span class="line">      <span class="comment">// 待执行的回调函数 异步的回调函数 [&#123; onFulfilled,onRejected,resolve,reject &#125;]</span></span><br><span class="line">      handlers = []</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造函数 resolve定义 reject定义 执行传入的回调函数</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;  <span class="comment">// 接收 new MyPromise((resolve,reject)=&gt; &#123;console.log(&#x27;立刻执行&#x27;)&#125; ) 传进来的回调函数，然后 resolve，reject 传给回调函数executor</span></span><br><span class="line">        <span class="comment">// 定义 resolve和reject</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 抽取封装 #changeState</span></span><br><span class="line">        <span class="comment">// if(this.state !== PENDING) &#123;</span></span><br><span class="line">        <span class="comment">//     return 如果状态不是等待，后面不执行 状态确定就不能改变</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// this.state = FULFILLED</span></span><br><span class="line">        <span class="comment">// this.result = result</span></span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 调用保存在handlers中的回调函数</span></span><br><span class="line">          <span class="comment">// 从开头部分取出回调函数执行</span></span><br><span class="line">          <span class="comment">// while(this.handlers.length &gt; 0) &#123;</span></span><br><span class="line">          <span class="comment">//    通过解构获取对应的回调函数</span></span><br><span class="line">          <span class="comment">//    const &#123; onFulfilled &#125; = this.handlers.shift()</span></span><br><span class="line">          <span class="comment">//    onFulfilled(this.result)</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 调用runHandlers 执行回调函数</span></span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收传入的执行器，接收定义的resolve和reject</span></span><br><span class="line">        <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据状态执行回调函数的 私有方法</span></span><br><span class="line">      <span class="comment">// 执行回调函数，取出数组中的回调函数，执行到没有为止 用shift()开头弹出</span></span><br><span class="line">      #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 循环执行到数组长度为0为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 2. 解构出resolve,reject执行和上一步一样的逻辑</span></span><br><span class="line">          <span class="keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;  <span class="comment">// this.state = &#x27;fulfilled&#x27;硬编码</span></span><br><span class="line">          <span class="comment">// 成功 执行 和 then 中类似的逻辑</span></span><br><span class="line">          <span class="comment">// 获取结果，根据是否为Promise以及状态调用对应的逻辑</span></span><br><span class="line">          <span class="comment">// onFulfilled(this.result)</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line">            <span class="comment">// onRejected(this.result)</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//提取resolve，reject内部公共逻辑  修改状态的（pending时才可以修改，执行到没有为止） 私有方法</span></span><br><span class="line">      #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// then方法，接收成功和失败的回调函数 根据不同的状态执行对应的回调函数</span></span><br><span class="line">      <span class="comment">// 链式编程 promise对象.then(xxx).then(xxx)</span></span><br><span class="line">      <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled 和 onRejected 的非空判断</span></span><br><span class="line">        <span class="comment">// 处理未传入回调函数的特殊情况</span></span><br><span class="line">        <span class="comment">// 如果不是函数，设置为一个 接受一个参数，直接返回该参数的函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">        <span class="comment">// 不是函数，设置一个为 接收一个参数，使用 throw 抛出的函数</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证链式编程，返回Promise</span></span><br><span class="line">        <span class="comment">// 创建一个新的Promise对象 并返回</span></span><br><span class="line">        <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//  根据状态，调用不同的回调函数</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="comment">// const res = onFulfilled(this.result)</span></span><br><span class="line">            <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">            <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//   resolve(res)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 抽取封装逻辑</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">             <span class="comment">//  参考成功状态的逻辑实现 失败状态</span></span><br><span class="line">             <span class="comment">// const res = onRejected(this.result)</span></span><br><span class="line">             <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">             <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">             <span class="comment">// &#125; else &#123;</span></span><br><span class="line">             <span class="comment">//   reject(res)</span></span><br><span class="line">             <span class="comment">// &#125;</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 状态为 pending 时,状态还没改变，回调函数还不能执行，将回调函数添加到数组中</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">              <span class="comment">//  将 resolve和reject也推送到数组中</span></span><br><span class="line">              onFulfilled, onRejected, resolve, reject</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> p2</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 满足执行条件，执行回调函数的 私有方法</span></span><br><span class="line">      #<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用微任务队列</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 调用回调函数 获取执行的结果</span></span><br><span class="line">          <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">          <span class="comment">// 判断是否为MyPromise的实例</span></span><br><span class="line">          <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">            <span class="comment">// res 是Promise对象 then 方法</span></span><br><span class="line">            <span class="comment">// 继续调用then方法 传入 resolve 和 reject</span></span><br><span class="line">            res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是普通的值，直接resolve</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/18/64df78c8b6ed3.png" alt="promise10.png"><br><img src="https://bu.dusays.com/2023/08/18/64df78c8e2db3.png" alt="promise11.png"></p><h3 id="手写Promise-实例方法catch"><a href="#手写Promise-实例方法catch" class="headerlink" title="手写Promise-实例方法catch"></a>手写Promise-实例方法catch</h3><p><strong>需求:</strong></p><ol><li>实现实例方法<code>catch</code>,可以实现如下调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">文档</a>,catch等同于:<code>then(undefined,onRjected)</code></li><li>直接添加<code>catch</code>方法，内部调用<code>then</code></li><li>使用<code>try-catch</code>包裹<code>runPromise</code>,出错时,调用<code>reject</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加catch方法，内部参考文档的方式调用then即可 </span></span><br><span class="line"><span class="comment">// 实例方法：catch 本质  then(undefined, onRjected)</span></span><br><span class="line"><span class="keyword">catch</span>(onRjected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRjected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数执行结果</span></span><br><span class="line">  #<span class="title function_">runPromise</span>(<span class="params">callBack, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，通过 reject 继续传递</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数 获取执行的结果</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">callBack</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// res是Promise对象 then方法</span></span><br><span class="line">          res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果是普通的值,直接resolve</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="手写Promise-实例方法finally"><a href="#手写Promise-实例方法finally" class="headerlink" title="手写Promise-实例方法finally"></a>手写Promise-实例方法finally</h3><p><strong>需求:</strong></p><ol><li>无论成功失败都会执行<code>finally</code>的回调函数</li><li>回调函数不接受任何参数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally执行啦&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally">文档</a>:finally方法类似于调用<code>then(onFinally,onFinally)</code>,且不接受任何回调函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例方法：finally</span></span><br><span class="line"><span class="title function_">finally</span>(<span class="params">onFinally</span>) &#123;</span><br><span class="line">    <span class="comment">// 将传入的回调函数，作为成功/失败的回调函数</span></span><br><span class="line">    <span class="comment">// 成功/失败都会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(onFinally,onFinally)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法resolve"><a href="#手写Promise-静态方法resolve" class="headerlink" title="手写Promise-静态方法resolve"></a>手写Promise-静态方法resolve</h3><p><strong>需求:</strong></p><ol><li>返回一个带有成功原因的<code>Promise</code>对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个值为2的Promise对象</span></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 直接返回传入的p</span></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>增加静态方法<code>resolve</code>，根据传入的值返回不同的结果即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 静态方法 resolve</span></span><br><span class="line">  <span class="comment">// 根据传入的值，返回不同的结果即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是Promise 返回Promise，后续即可链式调用</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果都不是的话，直接返回一个新的Promise对象 将value传递给resolve</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法reject"><a href="#手写Promise-静态方法reject" class="headerlink" title="手写Promise-静态方法reject"></a>手写Promise-静态方法reject</h3><p><strong>需求:</strong></p><ol><li>返回一个带有拒绝原因的<code>Promise</code>对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>添加静态方法内部返回有拒绝原因的<code>Promise</code>对象即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个两个方法在axios拦截器里可以发现到。</p><h3 id="手写Promise-静态方法race"><a href="#手写Promise-静态方法race" class="headerlink" title="手写Promise-静态方法race"></a>手写Promise-静态方法race</h3><p><strong>需求:</strong></p><ol><li>接收Promise数组<ol><li>第一个Promise成功或失败时，返回一个该Promise对象及原因</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">race</span>([promise1, promise2]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>,value)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>内部返回新的Promise对象:<ol><li>参数判断:<ol><li>不是数组:报错</li><li>是数组:挨个解析<ol><li>任意一个Promise对象成功或失败，直接resolve或reject即可</li></ol></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="comment">// race的后面需要 .then.catch</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验 传入的是数组才继续执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的promises是空数组，则返回的promise就将永远等待</span></span><br><span class="line">      promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Promise.resolve进行处理，只要有任何一个为 成功/拒绝 即可响应结果</span></span><br><span class="line">        <span class="comment">// MyPromise.resolve 传入的无论是不是Promise--&gt;都变成Promise</span></span><br><span class="line">        <span class="comment">// 如果不处理的话，传入普通的值，会直接报错</span></span><br><span class="line">        <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 参数错误</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法all"><a href="#手写Promise-静态方法all" class="headerlink" title="手写Promise-静态方法all"></a>手写Promise-静态方法all</h3><p><strong>需求:</strong></p><ol><li>接收Promise数组，<ol><li>所有Promise都成功时，返回一个成功的Promise对象及成功数组</li><li>任何一个Promise失败，返回一个失败的Promise对象及第一个失败原因</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><p>包裹一个新的Promise并返回，内部进行参数校验</p><ol><li><p>非数组:报错</p></li><li><p>数组:循环挨个解析</p><ol><li><p>长度为0:直接返回成功状态的Promise</p></li><li><p>长度不为0:挨个解析:forEach</p><ol><li><p>不是Promise对象:直接记录结果并判断是否解析完毕</p></li><li><p>是Promise对象:调用then</p><ol><li>成功:记录结果并判断是否解析完毕</li><li>失败:直接reject</li></ol></li></ol></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="comment">// 本质：外部可以 then catch</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 参数校验</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">       <span class="comment">// 是数组再继续执行</span></span><br><span class="line">       <span class="comment">// 存储结果</span></span><br><span class="line">       <span class="keyword">const</span> result = []</span><br><span class="line">       <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 记录结果的个数，判断是否完结</span></span><br><span class="line">       <span class="comment">// 如果长度为0 直接返回 fulfilled状态的Promise即可</span></span><br><span class="line">       <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">resolve</span>(promises)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 挨个处理</span></span><br><span class="line">       promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果是Promise</span></span><br><span class="line">           item.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">             count++</span><br><span class="line">             <span class="comment">// 这么做的目的是保证 结果的顺序 和 promise每一项的一致</span></span><br><span class="line">             result[index] = res</span><br><span class="line">             count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">           &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 任何一个失败 无视其他的promise直接 reject即可</span></span><br><span class="line">             <span class="title function_">reject</span>(err)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果不是Promise 原样添加在数组中</span></span><br><span class="line">           count++</span><br><span class="line">           result[index] = item</span><br><span class="line">           <span class="comment">// 全部处理完毕时，响应结果</span></span><br><span class="line">           count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">       <span class="comment">// 错误提示</span></span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法allSettled"><a href="#手写Promise-静态方法allSettled" class="headerlink" title="手写Promise-静态方法allSettled"></a>手写Promise-静态方法allSettled</h3><p><strong>需求:</strong></p><ol><li>传入Promise数组，当所有对象都已敲定时</li><li>返回一个新的Promise对象及以数组形式保存的结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取传入的Promise数组 的 敲定状态 和结果</span></span><br><span class="line"><span class="comment">// 包装到对象中 &#123; value：&#x27;成功的值&#x27; , reason: &#x27;失败原因&#x27; , status: &#x27;状态&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).</span><br><span class="line">  <span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(results) &#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>增加静态方法<code>allSettled</code></li><li>内部逻辑和<code>all</code>类似，需要特别注意的地方:<ol><li>成功和失败的原因都会通过对象记录起来</li><li>返回一个记录了成功<code>&#123;state:FULFILLED,value:&#39;xxx&#39;&#125;</code>失败<code>&#123;state:REJECTED,reason:&#39;xxx&#39;&#125;</code>的结果数组</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 参数校验</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">         <span class="keyword">let</span> result = []<span class="comment">// 结果数组</span></span><br><span class="line">         <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 计数器</span></span><br><span class="line">         <span class="comment">// 空数组直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(promises)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 挨个处理内部的Promise对象</span></span><br><span class="line">         promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="comment">// 使用resolve转为promise统一处理</span></span><br><span class="line">           <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 成功状态</span></span><br><span class="line">             count++</span><br><span class="line">             result[index] = &#123;</span><br><span class="line">               <span class="attr">state</span>: <span class="variable constant_">FULFILLED</span>,</span><br><span class="line">               value</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 处理完毕之后 resolve</span></span><br><span class="line">             count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">           &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 失败状态</span></span><br><span class="line">             count++</span><br><span class="line">             <span class="comment">// 失败状态 值为 reason</span></span><br><span class="line">             result[index] = &#123;</span><br><span class="line">               <span class="attr">state</span>: <span class="variable constant_">REJECTED</span>,</span><br><span class="line">               reason</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 成功和失败最终都对应到 resolve</span></span><br><span class="line">             count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 不是数组，报错</span></span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法any"><a href="#手写Promise-静态方法any" class="headerlink" title="手写Promise-静态方法any"></a>手写Promise-静态方法any</h3><p><strong>需求:</strong>-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any">传送门</a></p><ol><li>传入<code>Promise</code>数组，<ol><li>任何一个<code>Promise</code>对象敲定时，返回一个新的<code>Promise</code>对象，及对应的结果</li><li>所有Promise都被拒绝时，返回一个包含所有拒绝原因的<code>AggregateError</code>错误数组</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;success1&#x27;)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error3&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">any</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>类似于<code>all</code>核心区别<ol><li>数组长度为0，直接返回错误数组</li><li>任何一个成功，直接成功</li><li>通过数组记录失败原因，都失败时响应错误</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">      <span class="keyword">let</span> errors = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="comment">// AggregateError包含多个错误对象的 单个错误对象（错误对象容器）</span></span><br><span class="line">      <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(<span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 挨个处理</span></span><br><span class="line">      promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 只要一个成功 就成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(value)</span><br><span class="line">        &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          count++</span><br><span class="line">          errors.<span class="title function_">push</span>(reason)</span><br><span class="line">          <span class="comment">// 如果没有一个promise成功 就把所有的错误原因合并到一起 一起抛出</span></span><br><span class="line">          count++ === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(errors))</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 参数格式有误</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise需要掌握的点："><a href="#promise需要掌握的点：" class="headerlink" title="promise需要掌握的点："></a>promise需要掌握的点：</h3><ol><li><p>组织异步，回调函数 &#x3D;&gt; 链式编程</p></li><li><p>async await : await会等待后面Promise成功，并获取结果，try-catch捕获异常</p></li><li><p>多个异步管理：</p><ol><li><p>all ：都成功，第一个失败</p></li><li><p>race：第一个成功或失败</p></li><li><p>allSettled: 所有都敲定（成功&#x2F;失败），以对象数组的形式获取结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;成功原因&#x27;</span>,</span><br><span class="line">        <span class="attr">status</span>:<span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">reason</span>: <span class="string">&#x27;失败原因&#x27;</span></span><br><span class="line">        <span class="attr">status</span>:<span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>any : 第一个成功，或者都失败</p></li><li><p><strong>被追问</strong>：用在哪里：</p><ol><li><p>all：多个接口数据，获取完毕再渲染</p></li><li><p>race: 多个服务器的相同接口，都可以获取同一份数据，为了让用户尽可能的拿到结果，race调用相同的多个接口，只要拿到就渲染。</p><p>1.服务器1–新闻接口</p><p>2.服务器2–新闻接口</p><p>3.同时调用，哪个先获取到，就直接渲染</p></li><li><p>allSettled,any 了解过代码</p></li></ol></li></ol><p><strong>手写promise</strong></p><ol><li>构造函数：传入回调函数，并接收resolve和reject</li><li>状态和成功&#x2F;失败结果：<ol><li>定义常量保存状态，定义实例属性保存状态和结果</li><li>resolve和reject中修改状态记录结果</li></ol></li><li>then方法<ol><li>多次调用：用数组来保存回调函数</li><li>链式调用：内部返回Promise</li></ol></li><li>实例方法：<ol><li>catch: 本质就是 then(undefined,onRejected)</li><li>finally: 本质 then(onFinally,onFinally)</li></ol></li><li>静态方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 柯里化 </tag>
            
            <tag> 手写Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原理一</title>
      <link href="/posts/882eae.html"/>
      <url>/posts/882eae.html</url>
      
        <content type="html"><![CDATA[<h1 id="JS原理"><a href="#JS原理" class="headerlink" title="JS原理"></a>JS原理</h1><h3 id="知识点自测"><a href="#知识点自测" class="headerlink" title="知识点自测"></a>知识点自测</h3><div class="tabs" id="test"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test-1">call🍧</button><button type="button" class="tab " data-href="test-2">apply🍧</button><button type="button" class="tab " data-href="test-3">bind🍧</button><button type="button" class="tab " data-href="test-4">剩余参数🍧</button><button type="button" class="tab " data-href="test-5">Promise🍧</button><button type="button" class="tab " data-href="test-6">URLSearchParams🍧</button><button type="button" class="tab " data-href="test-7">Object.create🍧</button><button type="button" class="tab " data-href="test-8">Object.assign🍧</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><ol><li>函数的<code>call</code>方法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以指定的this调用函数，并通过 从第二个参数开始依次传递参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">name,drink</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 指向obj  &#123;name: &#x27;kilito&#x27;&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(drink)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call 参数1: this  </span></span><br><span class="line"><span class="comment">//      参数2: 2-n函数的参数</span></span><br><span class="line">func.<span class="title function_">call</span>(obj,<span class="string">&#x27;kilito&#x27;</span>,<span class="string">&#x27;咖啡&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-2"><ol start="2"><li>函数的<code>apply</code>方法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以指定的this调用函数，并通过 数组的形式 传递参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">name,drink</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 指向obj  &#123;name: &#x27;kilito&#x27;&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(drink)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apply 参数1: this</span></span><br><span class="line"><span class="comment">//       参数2: 以数组的形式传入参数</span></span><br><span class="line">func.<span class="title function_">apply</span>(obj,[<span class="string">&#x27;xiaoqing&#x27;</span>,<span class="string">&#x27;咖啡&#x27;</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-3"><ol start="3"><li>函数的<code>bind</code>方法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">food, drink</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// &#123;name: &#x27;kilito&#x27;&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(food)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(drink)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个绑定了this的新函数！</span></span><br><span class="line"><span class="keyword">const</span> bindFunc = func.<span class="title function_">bind</span>(obj, <span class="string">&#x27;花菜&#x27;</span>)</span><br><span class="line"><span class="title function_">bindFunc</span>(<span class="string">&#x27;可乐&#x27;</span>)</span><br><span class="line"><span class="comment">// const bindFunc = func.bind(obj)</span></span><br><span class="line"><span class="comment">// bindFunc(&#x27;花菜&#x27;,可乐&#x27;)</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-4"><ol start="4"><li>剩余参数-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args)<span class="comment">// 以数组的形式获取传入的所有参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(<span class="string">&#x27;西蓝花&#x27;</span>,<span class="string">&#x27;西葫芦&#x27;</span>,<span class="string">&#x27;西洋参&#x27;</span>,<span class="string">&#x27;西芹&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-5"><ol start="5"><li>Promise核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">`成功啦--<span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">`失败啦--<span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-6"><ol start="6"><li>URLSearchParams核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化时支持传入JS对象</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="comment">// toString方法 返回搜索参数组成的字符串，可直接使用在 URL 上。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-7"><ol start="7"><li>Object.create核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将传入的对象作为原型，创建一个新对象（浅拷贝）</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line">clone.<span class="property">name</span> = <span class="string">&#x27;itheima&#x27;</span></span><br><span class="line">clone.<span class="property">foods</span>.<span class="title function_">push</span>(<span class="string">&#x27;西北风&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clone.<span class="property">foods</span> === person.<span class="property">foods</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-8"><ol start="8"><li>Object.assign核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;rose&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1 目标对象</span></span><br><span class="line"><span class="comment">// 参数2 源对象</span></span><br><span class="line"><span class="comment">// 将源对象的自身属性复制到目标对象，并返回目标对象</span></span><br><span class="line"><span class="keyword">const</span> returnTarget = <span class="title class_">Object</span>.<span class="title function_">assign</span>(son, person)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnTarget === son)<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">name</span>)<span class="comment">// itheima</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">foods</span> === person.<span class="property">foods</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="xmind"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="xmind-1">this🍧</button><button type="button" class="tab " data-href="xmind-2">继承🍧</button><button type="button" class="tab " data-href="xmind-3">class🍧</button><button type="button" class="tab " data-href="xmind-4">fetch🍧</button><button type="button" class="tab " data-href="xmind-5">geneator🍧</button></ul><div class="tab-contents"><div class="tab-item-content active" id="xmind-1"><p><img src="https://bu.dusays.com/2023/08/17/64dda1ff4a71d.png" alt="xmthis.png"></p></div><div class="tab-item-content" id="xmind-2"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a4e42783.png" alt="xmjichen.png"></p></div><div class="tab-item-content" id="xmind-3"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a44529ff.png" alt="xmclass.png"></p></div><div class="tab-item-content" id="xmind-4"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a48a0993.png" alt="xmfetch.png"></p></div><div class="tab-item-content" id="xmind-5"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a435f5dc.png" alt="xmgeneator.png"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="JS中的this"><a href="#JS中的this" class="headerlink" title="JS中的this"></a>JS中的this</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">传送门：MDN-this</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">传送门：MDN-call</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">传送门：MDN-apply</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">传送门：MDN-bind</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">传送门：MDN-箭头函数</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/rest_parameters">传送门：MDN-剩余参数</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">传送门：MDN-Symbol</a></p></blockquote><h3 id="如何确认this指向："><a href="#如何确认this指向：" class="headerlink" title="如何确认this指向："></a>如何确认this指向：</h3><p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p><p><strong>谁调用就是谁，直接调用就是window</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例2</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// person</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// 直接调用就是 window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inner</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// person</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// window</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">sayHi</span>()</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h3 id="如何改变this指向"><a href="#如何改变this指向" class="headerlink" title="如何改变this指向"></a>如何改变this指向</h3><p>主要有2类改变函数内部<code>this</code>指向的方法：</p><ol><li><p>调用函数并传入具体的<code>this</code>:</p><ol><li><p><code>call</code>:</p><ol><li>参数1:<code>this</code>() （希望this指向谁就传哪个）</li><li>参数2-n:传递给函数的参数</li></ol></li><li><p><code>apply</code>-数组作为参数</p><ol><li>参数1:<code>this</code></li><li>参数2:以数组的形式,传递给函数的参数</li></ol></li></ol></li><li><p>创建绑定<code>this</code>的函数:</p><ol><li>bind:返回一个绑定了<code>this</code>的新函数</li><li>箭头函数:最近的this是谁,就是谁</li></ol></li></ol><p><strong>调用函数并传入具体的this：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcA</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;funcA-调用&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1:&#x27;</span>, p1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2:&#x27;</span>, p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call参数</span></span><br><span class="line"><span class="comment">// 参数1 this值 </span></span><br><span class="line"><span class="comment">// 参数2-参数n 挨个传入函数的参数  </span></span><br><span class="line">funcA.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// apply参数</span></span><br><span class="line"><span class="comment">// 参数1 this值</span></span><br><span class="line"><span class="comment">// 参数2 以数组的形式传入函数的参数</span></span><br><span class="line">funcA.<span class="title function_">apply</span>(obj, [<span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><strong>创建绑定this的函数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcB</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;funcB-调用&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1:&#x27;</span>, p1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2:&#x27;</span>, p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bind参数</span></span><br><span class="line"><span class="comment">// 参数1 this值</span></span><br><span class="line"><span class="comment">// 参数2-参数n 绑定的参数</span></span><br><span class="line"><span class="keyword">const</span> bindFuncB = funcB.<span class="title function_">bind</span>(person, <span class="number">123</span>)</span><br><span class="line"><span class="title function_">bindFuncB</span>(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// student</span></span><br><span class="line">    <span class="comment">// 箭头会从自己作用域链的上一层继承this</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inner</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inner-调用了&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// student 箭头函数中的this，指向所在作用域中的this 沿用上一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inner</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.<span class="title function_">sayHi</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="comment">// 这个大括号没有创建作用域</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// person</span></span><br><span class="line">    <span class="comment">// 箭头会从自己作用域链的上一层继承this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// person</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">     <span class="comment">// 易混淆情况（不要这样写）</span></span><br><span class="line">  <span class="attr">sayHello</span>:<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//person.sayHi()</span></span><br><span class="line">    person.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h3 id="手写call方法"><a href="#手写call方法" class="headerlink" title="手写call方法"></a>手写call方法</h3><p>这一节咱们来实现<code>myCall</code>方法，实际用法和<code>call</code>方法一致，核心步骤有4步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  实现myCall 可以实现如下的调用效果</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1：this</span></span><br><span class="line"><span class="comment">// 参数2-参数n：参数列表 </span></span><br><span class="line">func2.<span class="title function_">myCall</span>(obj2, <span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>如何定义<code>myCall</code>?</li><li>如何让函数内部的<code>this</code>为某个对象？</li><li>如何让<code>myCall</code>接收参数2-参数n?</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>调优<code>myCall</code>？<ol><li>添加到原型上，所有函数均可调用</li><li>通过给对象动态添加属性的方式来指定 this</li><li>…args 剩余参数 实现参数传递</li><li>通过 Symbo 解决了和默认属性重名的问题</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如何定义`myCall`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 如何让函数内部的`this`为某个对象                 // thisArg =&gt; &#123; name:&#x27;kilito&#x27; &#125;</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123; <span class="comment">// 1. 接收原函数的this要指向的对象 thisArg</span></span><br><span class="line">  <span class="comment">// this 是调用myCall的 函数</span></span><br><span class="line">  <span class="comment">// thisArg 指定的this</span></span><br><span class="line">  <span class="comment">// 2.为他添加一个自定义属性，让函数成为他的该属性  &#123; name:&#x27;kilito&#x27;,func: 原函数 &#125; </span></span><br><span class="line">  thisArg.<span class="property">func</span> = <span class="variable language_">this</span> <span class="comment">// 这个this 是原函数（谁调用，this就指向谁）</span></span><br><span class="line">  <span class="comment">// 3.调用并获取结果</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg.<span class="title function_">func</span>()</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">func</span></span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func.myCall(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 如何让`myCall`接收参数2-参数n</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123; <span class="comment">// ...args接受传过来的参数</span></span><br><span class="line">  thisArg.<span class="property">func</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用并获取结果</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg.<span class="title function_">func</span>(...args)  <span class="comment">// 使用展开运算符传入原函数</span></span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">func</span></span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func.myCall(obj,1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 使用`Symbol`调优`myCall`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用Symbol生成唯一标记，避免和原属性冲突</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  <span class="comment">// 给对象动态添加方法 指定为 this</span></span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">func2.<span class="title function_">myCall</span>(obj2, <span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// symbol</span></span><br><span class="line"><span class="comment">// 调用全局函数 Symbol 可以传入标记（可选）</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;kilito&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/16/64dcb002560a2.png" alt="手写call.png"></p><h3 id="手写apply方法"><a href="#手写apply方法" class="headerlink" title="手写apply方法"></a>手写apply方法</h3><p>这一节咱们来实现<code>myApply</code>方法，实际用法和<code>apply</code>方法一致，核心步骤依旧<code>4</code>步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  实现myApply 可以实现如下的调用效果</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1：this</span></span><br><span class="line"><span class="comment">// 参数2：数组形式传入的参数列表</span></span><br><span class="line">func2.<span class="title function_">myApply</span>(obj2, [<span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>如何定义<code>myApply</code>? 函数Function的原型上</li><li>如何让函数内部的<code>this</code>为某个对象？给对象动态增加方法,方法为原函数,通过对象调用即可</li><li>如何让<code>myApply</code>接收数组形式的参数列表? 定义一个参数接收数组即可 形参: args,调用时,…args</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>调优<code>myApply</code>？和原对象的属性重名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如何定义`myApply`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 如何让函数内部的`this`为某个对象</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// 为他添加一个自定义属性，让函数成为他的该属性</span></span><br><span class="line">  thisArg[<span class="string">&#x27;fn&#x27;</span>] = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用并获取结果</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[<span class="string">&#x27;fn&#x27;</span>]()</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[<span class="string">&#x27;fn&#x27;</span>]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 如何让`myApply`接收参数2-参数n</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  thisArg[<span class="string">&#x27;fn&#x27;</span>] = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用并获取结果</span></span><br><span class="line">  <span class="comment">// 用... 将args展开传入</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[<span class="string">&#x27;fn&#x27;</span>](...args)</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[<span class="string">&#x27;fn&#x27;</span>]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 使用`Symbol`调优`myApply`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用Symbol生成唯一标记，避免和原属性冲突</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">func2.<span class="title function_">myApply</span>(obj2, [<span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>])</span><br></pre></td></tr></table></figure><p>小结：手写apply方法</p><ol><li>如何定义<code>myApply</code>? 函数的原型上</li><li>如何让函数内部的<code>this</code>为某个对象？ 动态给对象添加方法,通过对象的方式调用方法</li><li>如何让<code>myApply</code>接收数组形式的参数列表?   形参: args,调用时,…args</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>调优<code>myApply</code>？避免和默认属性重名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写bind方法"><a href="#手写bind方法" class="headerlink" title="手写bind方法"></a>手写bind方法</h3><p>这一节咱们来实现<code>myBind</code>方法，实际用法和<code>bind</code>方法一致，核心步骤为2步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用bind获取绑定this的新函数，参数1为可乐</span></span><br><span class="line"><span class="keyword">const</span> bindFunc = func.<span class="title function_">bind</span>(obj, <span class="string">&#x27;可乐&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用函数，只需要传递参数2即可</span></span><br><span class="line"><span class="title function_">bindFunc</span>(<span class="string">&#x27;西蓝花炒蛋&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>如何返回一个绑定了<code>this</code>的函数？</li><li>如何实现绑定的参数，及传入的参数合并?</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 如何返回一个绑定了`this`的函数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// myBind函数调用时，this就是函数本身 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过call方法将传入的 thisArg 作为this进行调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">call</span>(thisArg)  <span class="comment">// this 指向 func</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 如何实现绑定的参数，及传入的参数合并</span></span><br><span class="line"><span class="comment">// ...args 接收绑定参数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...args2 接收调用时的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// thisArg 需要指定的this</span></span><br><span class="line">    <span class="comment">// args 调用myBind时传入的参数</span></span><br><span class="line">    <span class="comment">// args2 调用新函数时传入的参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">call</span>(thisArg, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用bind获取绑定this的新函数，参数1为可乐</span></span><br><span class="line"><span class="keyword">const</span> bindFunc = func.<span class="title function_">bind</span>(obj, <span class="string">&#x27;可乐&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用函数，只需要传递参数2即可</span></span><br><span class="line"><span class="title function_">bindFunc</span>(<span class="string">&#x27;西蓝花炒蛋&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/16/64dcb004b93cc.png" alt="手写bind.png"></p><p>小结：手写bind方法</p><ol><li>如何返回一个绑定了<code>this</code>的函数？</li><li>如何实现绑定的参数，及传入的参数合并?</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">call</span>(thisArg, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS继承-ES5"><a href="#JS继承-ES5" class="headerlink" title="JS继承-ES5"></a>JS继承-ES5</h2><blockquote><p>这一节咱们来学习如何在JS中实现<strong>继承</strong>，首先看看在ES6之前可以如何实现继承</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">传送门:继承与原型链</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">传送门:继承（计算机科学）</a></p><p><a href="https://www.ituring.com.cn/book/2472">传送门:JavaScript高级程序设计</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">传送门:MDN-Object.create</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">传送门:MDN-Object.assign</a></p></blockquote><p><strong>继承：</strong>继承可以使子类具有父类的各种属性和方法，而不需要再次编写相同的代码</p><p>这一节咱们会学习ES5中常见的继承写法(命令来源于 <strong>《JavaScript高级程序设计》</strong>)</p><ol><li>原型链实现继承</li><li>构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foods</span> = [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayFoods</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foods</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES5-原型链实现继承"><a href="#ES5-原型链实现继承" class="headerlink" title="ES5-原型链实现继承"></a>ES5-原型链实现继承</h3><p><strong>核心步骤：</strong>希望继承谁，就将谁作为原型</p><p><strong>缺点：</strong>父类中的引用数据类型，会被所有子类共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foods</span> = [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayFoods</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foods</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类的实例 作为子类的原型</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">s1.<span class="title function_">sayFoods</span>()<span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">s2.<span class="title function_">sayFoods</span>() <span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 引用数据类型是同一个</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">foods</span> === s2.<span class="property">foods</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s2.<span class="property">foods</span>.<span class="title function_">push</span>(<span class="string">&#x27;西葫芦&#x27;</span>)  <span class="comment">// 会影响到 s1</span></span><br><span class="line"></span><br><span class="line">s2.<span class="title function_">sayFoods</span>()<span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;, &#x27;西葫芦&#x27;]</span></span><br><span class="line">s1.<span class="title function_">sayFoods</span>()<span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;, &#x27;西葫芦&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="ES5-构造函数继承"><a href="#ES5-构造函数继承" class="headerlink" title="ES5-构造函数继承"></a>ES5-构造函数继承</h3><p><strong>核心步骤：</strong>在子类的构造函数中通过<code>call</code>或<code>apply</code>父类的构造函数</p><p><strong>缺点：</strong>子类没法使用父类原型上的属性&#x2F;方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name           <span class="comment">// 3. 给传入的 this 设置属性/方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好,我叫:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)  <span class="comment">// 2. this 指向 son 的实例化对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lucy&#x27;</span>)  <span class="comment">// 1. 调用子类构造函数</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;rose&#x27;</span>)</span><br><span class="line">s1.<span class="title function_">sayHi</span>() <span class="comment">// 报错 子类没法用到父类原型上的属性/方法</span></span><br></pre></td></tr></table></figure><h3 id="ES5-组合继承"><a href="#ES5-组合继承" class="headerlink" title="ES5-组合继承"></a>ES5-组合继承</h3><p>通过组合继承,结合原型链继承和构造函数继承2种方法的优点</p><p><strong>核心步骤：</strong></p><ol><li>通过原型链继承公共的属性和方法</li><li>通过构造函数继承实例独有的属性和方法</li></ol><p><strong>特点：</strong>调用了2次构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公共的属性和方法加父类原型上</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用父类构造函数传入this</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="comment">// 子类独有的属性和方法单独设置</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置子类的原型为 父类实例</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">// 调用子类的构造函数</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李雷&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用原型链上的 属性和方法 也可以使用 通过构造函数获取的父类的属性和方法</span></span><br></pre></td></tr></table></figure><h3 id="ES5-原型式继承"><a href="#ES5-原型式继承" class="headerlink" title="ES5-原型式继承"></a>ES5-原型式继承</h3><p>直接基于对象实现继承</p><p>**核心步骤:**对某个对象进行浅拷贝(工厂函数或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>),实现继承</p><p>**缺点:**父类中的引用数据类型，会被所有子类共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">friend</span>: [<span class="string">&#x27;rose&#x27;</span>, <span class="string">&#x27;ice&#x27;</span>, <span class="string">&#x27;robot&#x27;</span>],</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 Object.create替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数：返回一个新对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义构造函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 传入父类的对象，设置给构造函数的原型</span></span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="comment">// 返回了实例化对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son1 = <span class="title function_">objectFactory</span>(parent)</span><br><span class="line"><span class="keyword">const</span> son2 = <span class="title function_">objectFactory</span>(parent)</span><br><span class="line">son1.<span class="property">friend</span>.<span class="title function_">push</span>(<span class="string">&#x27;lucy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类中的引用数据类型，会被所有子类共享</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="property">friend</span>) <span class="comment">// [&#x27;rose&#x27;, &#x27;ice&#x27;, &#x27;robot&#x27;,&#x27;lucy&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son2.<span class="property">friend</span>) <span class="comment">// [&#x27;rose&#x27;, &#x27;ice&#x27;, &#x27;robot&#x27;,&#x27;lucy&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承，基于构造函数</span></span><br><span class="line"><span class="comment">// 原型继承，基于实例</span></span><br></pre></td></tr></table></figure><h3 id="ES5-寄生式继承"><a href="#ES5-寄生式继承" class="headerlink" title="ES5-寄生式继承"></a>ES5-寄生式继承</h3><p><strong>核心步骤:</strong></p><p>定义工厂函数,并在内部:</p><ol><li>对传入的对象进行浅拷贝(公共属性&#x2F;方法)</li><li>为浅拷贝对象增加属性&#x2F;方法(独有属性&#x2F;方法)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决引用类型共享问题</span></span><br><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;炒蛋&#x27;</span>, <span class="string">&#x27;花菜&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="comment">// Object.create基于原型创建新对象，对属性进行浅拷贝</span></span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(origin)</span><br><span class="line">  <span class="comment">// 为对象增加属性/方法</span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son1 = <span class="title function_">createAnother</span>(parent)</span><br><span class="line"><span class="keyword">const</span> son2 = <span class="title function_">createAnother</span>(parent)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create() 静态方法以一个现有对象作为原型，创建一个新对象。</span></span><br><span class="line"><span class="comment">// 基于一个对象作为原型，创建一个新对象</span></span><br><span class="line"><span class="comment">// 对传入的对象进行浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> father = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">foods</span>: [<span class="string">&#x27;西瓜&#x27;</span>, <span class="string">&#x27;西兰花&#x27;</span> ,<span class="string">&#x27;西葫芦&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newF = <span class="title class_">Object</span>.<span class="title function_">create</span>(father)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newF === father) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newF.<span class="property">foods</span> === father.<span class="property">foods</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>寄生式继承</p><ol><li><p>寄生式继承的核心步骤是?</p><ol><li><p>基于对象,创建新对象</p></li><li><p>增加新的<strong>属性和方法</strong></p></li></ol></li><li><p>寄生式继承和原型式原型式继承的区别是?</p><ol><li>创建出来的新对象,会额外的增加新的<strong>属性&#x2F;方法</strong></li></ol></li></ol><h3 id="ES5-寄生组合式继承"><a href="#ES5-寄生组合式继承" class="headerlink" title="ES5-寄生组合式继承"></a>ES5-寄生组合式继承</h3><p><strong>核心步骤:</strong></p><ol><li>通过构造函数来继承属性</li><li>通过原型链来继承方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承原型函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">son, parent</span>)&#123;</span><br><span class="line">    <span class="comment">//  基于父类的原型 创建新的对象</span></span><br><span class="line">    <span class="keyword">const</span> prototype = object.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 保证原型三角的关系</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = son</span><br><span class="line">    <span class="comment">// 设置给子类的类型</span></span><br><span class="line">    son.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foods</span> = [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]     <span class="comment">// 实例属性，写构造函数内</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;        <span class="comment">// 公共的方法写在原型上</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="string">`我喜欢吃,<span class="subst">$&#123;<span class="variable language_">this</span>.foods&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类借用父类的构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成原型继承</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Son</span>,<span class="title class_">Parent</span>)</span><br><span class="line"><span class="comment">// 可以继续在原型上添加属性/方法</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的年龄是&#x27;</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;rose&#x27;</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><h2 id="JS继承-ES6"><a href="#JS继承-ES6" class="headerlink" title="JS继承-ES6"></a>JS继承-ES6</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class">传送门:mdn类</a></p><p><a href="https://wangdoc.com/es6/class">传送门:阮一峰ES6-class</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">传送门:mdn-super</a></p></blockquote><p>ES6中推出了<code>class</code>类,是用来创建对象的模板.<code>class</code>可以看作是一个语法糖,它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h3 id="class核心语法"><a href="#class核心语法" class="headerlink" title="class核心语法"></a>class核心语法</h3><p><strong>核心语法:</strong></p><ol><li>如何定义及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes#%E7%B1%BB%E5%A3%B0%E6%98%8E">类</a>:</li><li>如何定义实例属性&#x2F;方法:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：class本质还是基于原型的</span></span><br><span class="line"><span class="comment">// 属性，在实例上</span></span><br><span class="line"><span class="comment">// 方法，在原型上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 实例属性，方便一眼确认有哪些（直接写，并且可以设置值）</span></span><br><span class="line">  <span class="comment">// 可以不写，构造函数中可以通过 this 动态添加</span></span><br><span class="line">  <span class="comment">// 建议写上</span></span><br><span class="line">  name</span><br><span class="line">  food</span><br><span class="line">  <span class="comment">// 构造方法，类似于构造函数，new的时候会调用，内部的this就是实例化的对象</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, food</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">food</span> = food</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢吃<span class="subst">$&#123;<span class="variable language_">this</span>.food&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小黑&#x27;</span>, <span class="string">&#x27;西蓝花&#x27;</span>)</span><br><span class="line">p.<span class="title function_">sayHi</span>()</span><br></pre></td></tr></table></figure><h3 id="class实现继承"><a href="#class实现继承" class="headerlink" title="class实现继承"></a>class实现继承</h3><p><strong>关键语法:</strong></p><ol><li><strong>子类</strong>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends">extends</a>继承<strong>父类</strong></li><li>子类构造函数中通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">super</a>调用父类构造函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上一份代码的基础上继续编写下面代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  song</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, food, song</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类构造函数使用this以前必须最开始调用super调用父类的构造函数！！！</span></span><br><span class="line">    <span class="variable language_">super</span>(name, food)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">song</span> = song</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  <span class="title function_">sing</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢唱<span class="subst">$&#123;<span class="variable language_">this</span>.song&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李雷&#x27;</span>, <span class="string">&#x27;花菜&#x27;</span>, <span class="string">&#x27;孤勇者&#x27;</span>)</span><br><span class="line">s.<span class="title function_">sayHi</span>()</span><br><span class="line">s.<span class="title function_">sing</span>()</span><br></pre></td></tr></table></figure><h3 id="class私有-静态属性和方法"><a href="#class私有-静态属性和方法" class="headerlink" title="class私有,静态属性和方法"></a>class私有,静态属性和方法</h3><p><strong>补充语法:</strong></p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Private_class_fields">私有</a>属性&#x2F;方法的定义及使用(内部调用)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static">静态</a>属性&#x2F;方法的定义及使用(类直接访问)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过#作为前缀添加的属性会变为私有</span></span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  #secret = <span class="string">&#x27;我有一个小秘密，就不告诉你&#x27;</span></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  #<span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有属性可以在</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;私有的say方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">info</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在类的内部可以访问私有属性调用私有方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#secret)</span><br><span class="line">    <span class="variable language_">this</span>.#<span class="title function_">say</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 static定义静态属性/方法</span></span><br><span class="line">  <span class="comment">// 访问的时候 通过 类 直接访问</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个静态方法&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> info = <span class="string">&#x27;直立行走，双手双脚&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line"><span class="comment">// 外部无法访问 点语法访问直接报错，通过[]无法动态获取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p[<span class="string">&#x27;#secret&#x27;</span>])</span><br><span class="line">p.<span class="title function_">info</span>()</span><br><span class="line"><span class="comment">// 通过类访问静态属性/方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">staticMethod</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">info</span>)</span><br></pre></td></tr></table></figure><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><blockquote><p>这一节咱们来学习内置函数<code>fetch</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">传送门-fetch</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response">传送门-Response</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">传送门-Headers</a></p></blockquote><p>全局的<code>fetch</code>函数用来发起获取资源请求.他返回一个<code>promise</code>,这个<code>promise</code>会在请求响应后被<code>resolve</code>,并传回Response对象</p><ol><li><p><code>fetch</code>核心语法</p></li><li><p><code>fetch</code>结合<code>URLSearchParams</code>发送get请求:</p><ol><li><pre><code class="javascript">const obj = &#123;    name:&#39;jack&#39;,    age:18&#125;name=jack&amp;age=17<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. `fetch`发送post请求,提交`JSON`数据</span><br><span class="line"></span><br><span class="line">4. `fetch`发送post请求,提交`FormData`数据</span><br><span class="line"></span><br><span class="line">### fetch核心语法</span><br><span class="line"></span><br><span class="line">**核心语法:**</span><br><span class="line"></span><br><span class="line">1. 如何[发请求](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch):</span><br><span class="line">2. 如何处理[响应](https://developer.mozilla.org/zh-CN/docs/Web/API/Response):</span><br><span class="line">3. 注:[测试用接口](https://apifox.com/apidoc/project-1937884/api-49760223)</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">document.querySelector(&#x27;.request&#x27;).addEventListener(&#x27;click&#x27;,() =&gt; &#123;</span><br><span class="line">    // 1. fetch(url地址) ===&gt; Promise对象</span><br><span class="line">    fetch(&#x27;http://hmajax.itheima.net/api/news&#x27;).then(response =&gt; &#123;</span><br><span class="line">        // console.log(response)</span><br><span class="line">        // 2. 请求成功之后， resolve  --&gt; then 获取 response</span><br><span class="line">        // 3. 调用 json 方法，获取解析之后的结果，返回Promise</span><br><span class="line">        response.json().then(res =&gt; &#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// async await 改写</span><br><span class="line">document.querySelector(&#x27;.request&#x27;).addEventListener(&#x27;click&#x27;, async() =&gt; &#123;</span><br><span class="line">   const response =  await fetch(&#x27;http://hmajax.itheima.net/api/news&#x27;)</span><br><span class="line">   const res = response.json()</span><br><span class="line">   console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h3 id="fetch结合URLSearchParams发送get请求"><a href="#fetch结合URLSearchParams发送get请求" class="headerlink" title="fetch结合URLSearchParams发送get请求:"></a>fetch结合URLSearchParams发送get请求:</h3><p><strong>需求:</strong></p><ol><li>使用<code>fetch</code>结合<code>URLSearchParams</code>调用地区查询<a href="https://apifox.com/apidoc/project-1937884/api-49760217">接口</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;</span><br><span class="line">    <span class="attr">pname</span>: <span class="string">&#x27;安徽省&#x27;</span>,</span><br><span class="line">    <span class="attr">cname</span>: <span class="string">&#x27;合肥市&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// console.log(params) URLSearchParams &#123; size: 2 &#125; 2组键值对</span></span><br><span class="line">  <span class="comment">// 传入的对象，转为查询字符串</span></span><br><span class="line">  <span class="comment">// key=value&amp;key=value</span></span><br><span class="line">  <span class="comment">// 中文会编码</span></span><br><span class="line">  <span class="comment">// params.toString() </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`http://hmajax.itheima.net/api/area?<span class="subst">$&#123;params.toString()&#125;</span>`</span></span><br><span class="line">  <span class="comment">// fetch函数返回的是 Promise对象，通过await等待获取response对象</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">  <span class="comment">// .json方法返回的是Promise对象 继续通过await等待</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="post请求-提交JSON"><a href="#post请求-提交JSON" class="headerlink" title="post请求-提交JSON"></a>post请求-提交JSON</h3><p><strong>需求:</strong></p><ol><li><code>fetch</code>发送post请求,提交<code>JSON</code>数据</li><li><a href="https://apifox.com/apidoc/project-1937884/api-49760218">测试接口-用户注册</a></li></ol><p><strong>核心步骤:</strong></p><ol><li>根据文档设置请求头</li><li>通过配置项设置,请求方法,请求头,请求体</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; (<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过headers设置请求头</span></span><br><span class="line">  <span class="keyword">const</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>()</span><br><span class="line">  <span class="comment">// 通过 content-type指定请求体数据格式</span></span><br><span class="line">  headers.<span class="title function_">append</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 参数1 url</span></span><br><span class="line">  <span class="comment">// 参数2 请求配置</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/register&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">// 请求方法</span></span><br><span class="line">    headers, <span class="comment">// 请求头</span></span><br><span class="line">    <span class="comment">// 请求体</span></span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">username</span>: <span class="string">&#x27;itheima9876&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>post请求-提交JSON</p><ol><li><code>fetch</code>函数的第二个参数可以设置请求头,请求方法,请求体</li></ol><h3 id="post请求-提交FormData"><a href="#post请求-提交FormData" class="headerlink" title="post请求-提交FormData"></a>post请求-提交FormData</h3><p><strong>需求:</strong></p><ol><li><code>fetch</code>发送post请求,提交<code>FormData</code>数据(上传+回显)</li><li><a href="https://apifox.com/apidoc/project-1937884/api-49760221">测试接口-上传图片</a></li></ol><p><strong>核心步骤:</strong></p><ol><li>通过<code>FormData</code>添加文件</li><li>通过配置项设置,请求方法,请求体(<code>FormData</code>不需要设置请求头)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;file&quot;</span> accept=<span class="string">&quot;image/*&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.file&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 生成FormData对象并添加数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    data.<span class="title function_">append</span>(<span class="string">&#x27;img&#x27;</span>, <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/uploadimg&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">body</span>: data</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> json = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">传送门-Generator</a></p></blockquote><p><code>Generator</code>对象由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*">生成器函数</a>返回并且它符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">可迭代协议</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">迭代器协议</a>.他可以用来<strong>控制流程</strong>,语法行为和之前学习的函数不一样</p><h3 id="Generator-核心语法"><a href="#Generator-核心语法" class="headerlink" title="Generator-核心语法"></a>Generator-核心语法</h3><p><strong>核心语法:</strong></p><ol><li>如何定义生成器函数:</li><li>如何获取<code>generator</code>对象</li><li><code>yield</code>表达式的使用</li><li>通过<code>for of</code>获取每一个<code>yield</code>的值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过function* 创建生成器函数 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 生成器函数内部的逻辑，不会自动调用，调用 Generator 对象的 next() 方法  </span></span><br><span class="line">  <span class="comment">// 遇到yield表达式时会暂停后续的操作 （*对应async  yield对应await）</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用函数获取生成器</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">foo</span>()</span><br><span class="line"><span class="comment">// 3. 通过next方法获取yield 之后的表达式结果，会被包装到一个对象中</span></span><br><span class="line"><span class="comment">// 执行一次next 即可获取一次 yield之后的表达式结果</span></span><br><span class="line"><span class="keyword">const</span> res1 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1)<span class="comment">// &#123;value: &#x27;a&#x27;, done: false&#125;</span></span><br><span class="line"><span class="keyword">const</span> res2 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2)<span class="comment">// &#123;value: &#x27;b&#x27;, done: false&#125;</span></span><br><span class="line"><span class="keyword">const</span> res3 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res3)<span class="comment">// &#123;value: &#x27;c&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// 最后一次可以拿到return的结果</span></span><br><span class="line"><span class="keyword">const</span> res4 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res4)<span class="comment">// &#123;value: &#x27;d&#x27;, done: true&#125; </span></span><br><span class="line"><span class="comment">// done 为true之后，获取到的value为undefined</span></span><br><span class="line"><span class="keyword">const</span> res5 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res5)<span class="comment">// &#123;value: undefined, done: true&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器，函数创建之后，代码不执行</span></span><br><span class="line"><span class="comment">// 每调用一次next执行到yield，获取结果</span></span><br><span class="line"><span class="comment">// 如果执行next之后无法获取结果， done: false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 通过for of 获取每一个yield之后的值，</span></span><br><span class="line"><span class="comment">// 迭代器协议 可以自定义 for of 的时候的行为</span></span><br><span class="line"><span class="comment">// iterator迭代（循环的每一项）</span></span><br><span class="line"><span class="comment">// f2 循环的内容</span></span><br><span class="line"><span class="keyword">const</span> f2 = <span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> f2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator)  <span class="comment">// a b c d 获取每一个 yeild 之后的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for of</span></span><br><span class="line"><span class="comment">// 可以用来遍历一些符合 迭代器协议的数据 比如数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Generator-id生成器"><a href="#Generator-id生成器" class="headerlink" title="Generator-id生成器"></a>Generator-id生成器</h3><p>**需求:**使用<code>Generator</code>实现一个id生成器id</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">idGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> idMaker = <span class="title function_">idGenerator</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用next方法,获取id(每次累加1)</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id1 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id1)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id2 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id2)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义生成器函数</li><li>内部使用循环,通过<code>yield</code>返回<code>id</code>并累加</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过function* 创建生成器函数 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 无限循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// id累加并返回</span></span><br><span class="line">    <span class="keyword">yield</span> id++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用函数获取生成器</span></span><br><span class="line"><span class="keyword">const</span> idMaker = <span class="title function_">generator</span>()</span><br><span class="line"><span class="comment">// 3. 需要id的时候 通过next获取即可</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id1 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id1)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id2 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id2)</span><br></pre></td></tr></table></figure><h3 id="Generator-流程控制"><a href="#Generator-流程控制" class="headerlink" title="Generator-流程控制"></a>Generator-流程控制</h3><p>遇到<code>yield</code>表达式时会<strong>暂停</strong>后续的操作</p><p>**需求:**使用<code>Generator</code>实现流程控制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">weatherGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 逻辑略</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">axios</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取Generator实例</span></span><br><span class="line"><span class="keyword">const</span> weather = <span class="title function_">weatherGenerator</span>()</span><br><span class="line"><span class="comment">// 依次获取 北上广深的天气 (axios)</span></span><br><span class="line">weather.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><code>yield</code>后面跟上天气查询逻辑</li><li><a href="https://apifox.com/apidoc/project-1937884/api-49760220">接口文档-天气预报</a></li><li>参考<code>code</code>:北京 110100  上海 310100  广州 440100 深圳 440300</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;getWeather&quot;</span>&gt;</span>天气查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.6/axios.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * 需求：流程控制，依次查询，北上广深的天气预报</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * 参考code: 北京 110100  上海 310100  广州 440100 深圳 440300</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * 接口文档: https://apifox.com/apidoc/project-1937884/api-49760220</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span>* <span class="title function_">weatherGenerator</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// yield 会暂停代码的执行</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 北京</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=110100&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 上海</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=310100&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 广州</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=440100&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 深圳</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=440300&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> cityWeather = <span class="title function_">weatherGenerator</span>()</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//const response = weather.next()</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 继续 .then</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//response.value.then(res =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//   console.log(res)</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//&#125;)</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.getWeather&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> res = <span class="keyword">await</span> genCity.<span class="title function_">next</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> 手写 </tag>
            
            <tag> 继承 </tag>
            
            <tag> fetch </tag>
            
            <tag> Generato </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在nodejs环境中应用并代理跨域</title>
      <link href="/posts/882eae4.html"/>
      <url>/posts/882eae4.html</url>
      
        <content type="html"><![CDATA[<h2 id="在nodejs环境中应用并代理跨域"><a href="#在nodejs环境中应用并代理跨域" class="headerlink" title="在nodejs环境中应用并代理跨域"></a>在nodejs环境中应用并代理跨域</h2><p>**<code>目标</code>**将打包好的代码打包上线，并在nodejs中代理跨域</p><h3 id="使用koa框架部署项目"><a href="#使用koa框架部署项目" class="headerlink" title="使用koa框架部署项目"></a>使用koa框架部署项目</h3><blockquote><p>到现在为止，我们已经完成了一个前端工程师的开发流程，按照常规的做法，此时，运维会将我们的代码部署到阿里云的ngix服务上，对于我们而言，我们可以将其部署到本机的nodejs环境中</p></blockquote><p>部署 自动化部署 &#x2F;手动部署</p><p>第一步，建立web服务文件夹  <strong><code>hrServer</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> hrServer <span class="comment">#建立hrServer文件夹 </span></span><br></pre></td></tr></table></figure><p>第二步，在该文件夹下，初始化npm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><p>第三步，安装服务端框架koa(也可以采用express或者egg)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i koa koa-static</span><br></pre></td></tr></table></figure><p>第四步，拷贝上小节打包的dist目录到**<code>hrServer/public</code>**下</p><p>第五步，在根目录下创建app.js，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span>  = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)  <span class="comment">// 引入Koa包</span></span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();  <span class="comment">// 实例化一个web服务</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(__dirname + <span class="string">&quot;/public&quot;</span>)); <span class="comment">//将public下的代码静态化</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3333</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人资项目启动&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>node app</p><p>此时，我们可以访问，<a href="http://localhost:3333/">http://localhost:3333</a></p></blockquote><p>页面出来了</p><h3 id="解决history页面404问题"><a href="#解决history页面404问题" class="headerlink" title="解决history页面404问题"></a>解决history页面404问题</h3><p>但是，此时存在两个问题，</p><ol><li><strong>当我们刷新页面，发现404</strong></li></ol><blockquote><p>  这是因为我们采用了history的模式，地址的变化会引起服务器的刷新，我们只需要在app.js对所有的地址进行一下处理即可</p></blockquote><p>安装 koa中间件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i koa2-connect-history-api-fallback <span class="comment">#专门处理history模式的中间件</span></span><br></pre></td></tr></table></figure><p><strong>注册中间件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span>  = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span>  &#123; historyApiFallback &#125; = <span class="built_in">require</span>(<span class="string">&#x27;koa2-connect-history-api-fallback&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="comment">// 这句话 的意思是除接口之外所有的请求都发送给了 index.html</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">historyApiFallback</span>(&#123;      <span class="comment">//应该先使用 处理访问的中间件 再使用静态化服务</span></span><br><span class="line">     <span class="attr">whiteList</span>: [<span class="string">&#x27;/prod-api&#x27;</span>]  <span class="comment">//prod-api代理跨域的问题  表示不要帮我处理 /prod-api 由自己处理</span></span><br><span class="line"> &#125;));  <span class="comment">// 这里的whiteList是 白名单的意思</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(__dirname + <span class="string">&quot;/public&quot;</span>)); <span class="comment">//将public下的代码静态化</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3333</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人资项目启动http://localhost:3333&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解决生产环境跨域问题"><a href="#解决生产环境跨域问题" class="headerlink" title="解决生产环境跨域问题"></a>解决生产环境跨域问题</h3><ol><li>当点击登录时，发现接口404</li></ol><blockquote><p>  前面我们讲过，vue-cli的代理只存在于开发期，当我们上线到node环境或者ngix环境时，需要我们再次在环境中代理</p></blockquote><p>在nodejs中代理</p><p>安装跨域代理中间件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i koa2-proxy-middleware</span><br></pre></td></tr></table></figure><p>配置跨越代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; historyApiFallback &#125; = <span class="built_in">require</span>(<span class="string">&#x27;koa2-connect-history-api-fallback&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;koa2-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册跨域代理的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">proxy</span>(&#123;</span><br><span class="line">    <span class="attr">targets</span>: &#123;</span><br><span class="line">        <span class="comment">// 代理哪个地址  代理以 &#x27;/prod-api&#x27;为开头的地址</span></span><br><span class="line">        <span class="string">&#x27;/prod-api/(.*)&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;https://heimahr.itheima.net/api&#x27;</span>, <span class="comment">// 将以prod/api开头的内容代理到该地址  后端服务器地址</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;/prod-api&#x27;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这句话 的意思是除接口之外所有的请求都发送给了 index.html</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">historyApiFallback</span>(&#123; <span class="comment">//应该先使用 处理访问的中间件 再使用静态化服务</span></span><br><span class="line">    <span class="attr">whiteList</span>: [<span class="string">&#x27;/prod-api&#x27;</span>] <span class="comment">// prod-api代理跨域的问题  表示不要帮我处理 /prod-api 由自己处理</span></span><br><span class="line">&#125;)); <span class="comment">// 这里的whiteList是 白名单的意思</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(__dirname + <span class="string">&quot;/public&quot;</span>)); <span class="comment">//将public下的代码静态化</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3333</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人资项目启动http://localhost:3333&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：这里之所以用了<strong>pathRewrite</strong>，是因为生产环境的请求基础地址是 <strong>&#x2F;prod-api</strong>，需要将该地址去掉</p><p>此时，我们的项目就可以跨域访问了！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阳光不错，微风正好</title>
      <link href="/posts/b313554c.html"/>
      <url>/posts/b313554c.html</url>
      
        <content type="html"><![CDATA[<h1 id="夏至"><a href="#夏至" class="headerlink" title="夏至"></a>夏至</h1><p>  一生的时间很短<br>  短到不过是两颗心之间的距离<br>  一生的时间也很长<br>  不如我们试着走走看</p>  <button type="button" onclick="SAONotify('Update','link start...','location.reload(true);')">SAO刷新按钮</button>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
