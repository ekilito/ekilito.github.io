<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023-11</title>
      <link href="/posts/893eae6.html"/>
      <url>/posts/893eae6.html</url>
      
        <content type="html"><![CDATA[<h1 id="2023-11"><a href="#2023-11" class="headerlink" title="2023-11"></a>2023-11</h1><h2 id="1-完成一个页面的开发"><a href="#1-完成一个页面的开发" class="headerlink" title="1.完成一个页面的开发"></a>1.完成一个页面的开发</h2><p><strong>本周任务</strong></p><ol><li>熟悉 vue3 若依基础框架</li><li>会使用 3h1 和 vben admin  antd 组件库的用法</li><li>新增路由  封装API 调用接口 页面渲染 curd</li><li>二级页面 Modal</li></ol><h4 id="1-index-vue"><a href="#1-index-vue" class="headerlink" title="1.index.vue"></a>1.index.vue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--BasicTable  表格--&gt;</span><br><span class="line">    &lt;BasicTable @register=&quot;registerTable&quot;&gt;</span><br><span class="line">      &lt;!-- 新增岗位 --&gt;</span><br><span class="line">      &lt;template #toolbar&gt;</span><br><span class="line">        &lt;a-button type=&quot;primary&quot; @click=&quot;handleCreate&quot;&gt; 新增岗位 &lt;/a-button&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template #bodyCell=&quot;&#123; column, record &#125;&quot;&gt;</span><br><span class="line">        &lt;!--v-if=&quot;column.dataIndex === &#x27;action&#x27;&quot; 判断当前列是否是操作列--&gt;</span><br><span class="line">        &lt;template v-if=&quot;column.dataIndex === &#x27;action&#x27;&quot;&gt;</span><br><span class="line">          &lt;TableAction</span><br><span class="line">            :actions=&quot;[</span><br><span class="line">              &#123;</span><br><span class="line">                label: &#x27;修改&#x27;,</span><br><span class="line">                onClick: handleEdit.bind(null, record),</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                label: &#x27;删除&#x27;,</span><br><span class="line">                popConfirm: &#123;</span><br><span class="line">                  title: &#x27;确定要删除吗？&#x27;,</span><br><span class="line">                  confirm: handleDelete.bind(null, record),</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ]&quot;</span><br><span class="line">        /&gt;&lt;/template&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/BasicTable&gt;</span><br><span class="line">    &lt;!--弹窗--&gt;</span><br><span class="line">    &lt;ceshiModel @register=&quot;registerModal&quot; @success=&quot;handleSuccess&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">  import &#123; BasicTable, useTable, TableAction, useModal &#125; from &#x27;3h1-ui&#x27;;</span><br><span class="line">  import componentSetting from &#x27;@/settings/componentSetting&#x27;;</span><br><span class="line">  import &#123; columns, searchFormSchema &#125; from &#x27;./ceshi.data&#x27;;</span><br><span class="line">  import ceshiModel from &#x27;./ceshiModel.vue&#x27;;</span><br><span class="line">  // 提示框</span><br><span class="line">  import &#123; useMessage &#125; from &#x27;@shy-plugins/use&#x27;;</span><br><span class="line">  // 导入接口</span><br><span class="line">  import * as ceshiApi from &#x27;@/api/system/post&#x27;;</span><br><span class="line">  //import &#123; usePermission &#125; from &#x27;@/hooks/web/usePermission&#x27;; 权限</span><br><span class="line">  //const &#123; hasPermission &#125; = usePermission();</span><br><span class="line"></span><br><span class="line">  const &#123;</span><br><span class="line">    table: &#123; fetchSetting &#125;,</span><br><span class="line">  &#125; = componentSetting;</span><br><span class="line"></span><br><span class="line">  // model</span><br><span class="line">  const [registerModal, &#123; openModal &#125;] = useModal();</span><br><span class="line"></span><br><span class="line">  // 提示框</span><br><span class="line">  const &#123; createMessage &#125; = useMessage();</span><br><span class="line"></span><br><span class="line">  const [registerTable, &#123; reload &#125;] = useTable(&#123;</span><br><span class="line">    columns, // 表单列信息 BasicColumn[]</span><br><span class="line">    /*api: () =&gt; &#123;</span><br><span class="line">      return new Promise((resolve) =&gt; &#123;</span><br><span class="line">        resolve([</span><br><span class="line">          &#123; id: 1, name: &#x27;测试1&#x27;, sort: 1, status: 1 &#125;,</span><br><span class="line">          &#123; id: 2, name: &#x27;测试2&#x27;, sort: 2, status: 0 &#125;,</span><br><span class="line">          &#123; id: 3, name: &#x27;测试3&#x27;, sort: 3, status: 0 &#125;,</span><br><span class="line">          &#123; id: 4, name: &#x27;测试4&#x27;, sort: 4, status: 1 &#125;,</span><br><span class="line">          &#123; id: 5, name: &#x27;测试5&#x27;, sort: 5, status: 1 &#125;,</span><br><span class="line">        ]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,*/</span><br><span class="line">    api: ceshiApi.getPostPageApi,</span><br><span class="line">    formConfig: &#123;</span><br><span class="line">      // 表单配置</span><br><span class="line">      schemas: searchFormSchema, // 表单配置</span><br><span class="line">    &#125;,</span><br><span class="line">    rowSelection: &#123; type: &#x27;checkbox&#x27; &#125;, // 选择列配置</span><br><span class="line">    clickToRowSelect: false, // 点击行是否选中 checkbox 或者 radio。需要开启</span><br><span class="line">    rowKey: &#x27;id&#x27;, // 根据唯一的 rowKey 更新指定行的数据</span><br><span class="line">    useSearchForm: true, // 使用搜索表单</span><br><span class="line">    pagination: true, // 分页信息配置，为 false 不显示分页</span><br><span class="line">    // handleSearchInfoFn: (data) =&gt; &#123;</span><br><span class="line">    // console.log(&#x27;sousuo*****&#x27;,data)</span><br><span class="line">    //&#125;,</span><br><span class="line">    actionColumn: &#123;</span><br><span class="line">      // 表格右侧操作列配置 BasicColumn</span><br><span class="line">      width: 200,</span><br><span class="line">      title: &#x27;操作&#x27;,</span><br><span class="line">      dataIndex: &#x27;action&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    fetchSetting, // 接口请求配置，可以配置请求的字段和响应的字段名</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 点击新增添加的逻辑</span><br><span class="line">  function handleCreate() &#123;</span><br><span class="line">    openModal(true, &#123;</span><br><span class="line">      isUpdate: false,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 删除操作</span><br><span class="line">  async function handleDelete(record: Recordable) &#123;</span><br><span class="line">    // 调用删除接口</span><br><span class="line">    await ceshiApi.deletePostApi(record.id);</span><br><span class="line">    createMessage.success(&#x27;删除成功&#x27;);</span><br><span class="line">    reload();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 修改</span><br><span class="line">  function handleEdit(record: Recordable) &#123;</span><br><span class="line">    openModal(true, &#123;</span><br><span class="line">      record,</span><br><span class="line">      isUpdate: true,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handleSuccess() &#123;</span><br><span class="line">    createMessage.success(&#x27;操作成功&#x27;);</span><br><span class="line">    reload();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-Modal-vue"><a href="#2-Modal-vue" class="headerlink" title="2.Modal.vue"></a>2.Modal.vue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!--  v-bind=&quot;$attrs&quot;用于将弹窗组件的 attribute 传入 BasicModal 组件 --&gt;</span><br><span class="line">  &lt;BasicModal</span><br><span class="line">    v-bind=&quot;$attrs&quot;</span><br><span class="line">    width=&quot;800px&quot;</span><br><span class="line">    title=&quot;新增&quot;</span><br><span class="line">    @register=&quot;registerModal&quot;</span><br><span class="line">    @ok=&quot;handleSubmit&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;BasicForm @register=&quot;registerForm&quot; /&gt;</span><br><span class="line">  &lt;/BasicModal&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;ceshiModel&quot;&gt;</span><br><span class="line">  import &#123; BasicModal, BasicForm, useForm, useModalInner &#125; from &#x27;3h1-ui&#x27;;</span><br><span class="line">  import &#123; formSchema &#125; from &#x27;./ceshi.data&#x27;;</span><br><span class="line">  import * as ceshiApi from &#x27;@/api/system/post&#x27;;</span><br><span class="line"></span><br><span class="line">  const emit = defineEmits([&#x27;success&#x27;, &#x27;register&#x27;]);</span><br><span class="line"></span><br><span class="line">  // 控制组件的显示与隐藏</span><br><span class="line">  const isUpdate = ref(true);</span><br><span class="line"></span><br><span class="line">  // 行id</span><br><span class="line">  const rowId = ref&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">  // useForm 表单配置对象  registerForm:表单对象  setFieldsValue:设置表单字段的值。resetFields:重置表单字段的值。validate:表单验证方法</span><br><span class="line">  const [registerForm, &#123; setFieldsValue, resetFields, validate &#125;] = useForm(&#123;</span><br><span class="line">    labelWidth: 100, // 标签宽度</span><br><span class="line">    baseColProps: &#123; span: 12 &#125;, // 基础列属性，用于设置列的宽度</span><br><span class="line">    schemas: formSchema, // 表单数据结构</span><br><span class="line">    showActionButtonGroup: false, // 是否显示操作按钮组，默认为 false</span><br><span class="line">    actionColOptions: &#123;</span><br><span class="line">      // 操作列选项，用于设置操作列的宽度，这里设置为 span 为 23。</span><br><span class="line">      span: 23,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // useModalInner（callback） 用于操作独立组件</span><br><span class="line">  // 回调函数用于接收 openModal 第二个参数传递的值 是个对象</span><br><span class="line">  const [registerModal, &#123; setModalProps, closeModal &#125;] = useModalInner(async (data) =&gt; &#123;</span><br><span class="line">    resetFields();</span><br><span class="line">    setModalProps(&#123; confirmLoading: false &#125;); // setModalProps 方法将确认按钮的加载状态设置为 false</span><br><span class="line">    //</span><br><span class="line">    isUpdate.value = data?.isUpdate;</span><br><span class="line"></span><br><span class="line">    if (unref(isUpdate)) &#123;</span><br><span class="line">      rowId.value = data.record.id;</span><br><span class="line">      // 数据回显</span><br><span class="line">      setFieldsValue(&#123;</span><br><span class="line">        ...data.record,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // const getTitle = computed(() =&gt; (unref(isUpdate) ? &#x27;修改岗位&#x27; : &#x27;添加岗位&#x27;));</span><br><span class="line"></span><br><span class="line">  // 点击确定回调</span><br><span class="line">  async function handleSubmit() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 表单校验</span><br><span class="line">      const values = await validate();</span><br><span class="line">      // 设置模态框的属性，将 confirmLoading 属性设置为 true,表示正在提交数据，需要显示加载动画。</span><br><span class="line">      setModalProps(&#123; confirmLoading: true &#125;);</span><br><span class="line">      // TODO custom api</span><br><span class="line">      // 根据 isUpdate 变量的值判断是更新还是创建操作</span><br><span class="line">      // 如果 isUpdate 为真，则执行更新操作；否则执行创建操作。</span><br><span class="line">      if (unref(isUpdate)) &#123;</span><br><span class="line">        values.id = rowId.value;</span><br><span class="line">        await ceshiApi.updatePostApi(values);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        await ceshiApi.createPostApi(values);</span><br><span class="line">      &#125;</span><br><span class="line">      // 关闭模态框</span><br><span class="line">      closeModal();</span><br><span class="line">      // 触发自定义事件 success,通知父组件表单提交成功</span><br><span class="line">      emit(&#x27;success&#x27;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 表示提交数据完成，取消加载动画。</span><br><span class="line">      setModalProps(&#123; confirmLoading: false &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-data-ts"><a href="#3-data-ts" class="headerlink" title="3.data.ts"></a>3.data.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BasicColumn</span>, <span class="title class_">FormSchema</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/components/Table&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; formatToDateTime &#125; <span class="keyword">from</span> <span class="string">&#x27;@shy-plugins/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Tag</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="line"><span class="comment">// 表格</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">columns</span>: <span class="title class_">BasicColumn</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;岗位编号&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;岗位编码&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">180</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;岗位名称&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;岗位排序&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">160</span>,</span><br><span class="line">    <span class="attr">customRender</span>: <span class="function">(<span class="params">&#123; record &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> status = record.<span class="property">status</span>;</span><br><span class="line">      <span class="keyword">const</span> enable = ~~status === <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> color = enable ? <span class="string">&#x27;green&#x27;</span> : <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> text = enable ? <span class="string">&#x27;启用&#x27;</span> : <span class="string">&#x27;停用&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">Tag</span>, &#123; <span class="attr">color</span>: color &#125;, <span class="function">() =&gt;</span> text);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;createTime&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">180</span>,</span><br><span class="line">    <span class="attr">customRender</span>: <span class="function">(<span class="params">&#123; text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">formatToDateTime</span>(text);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// search 搜索框</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">searchFormSchema</span>: <span class="title class_">FormSchema</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;岗位编码&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;Input&#x27;</span>,</span><br><span class="line">    <span class="attr">colProps</span>: &#123; <span class="attr">span</span>: <span class="number">8</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;岗位名称&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;Input&#x27;</span>,</span><br><span class="line">    <span class="attr">colProps</span>: &#123; <span class="attr">span</span>: <span class="number">8</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;Select&#x27;</span>,</span><br><span class="line">    <span class="attr">componentProps</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: [</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">&#x27;启用&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;0&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">&#x27;停用&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">colProps</span>: &#123; <span class="attr">span</span>: <span class="number">8</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹窗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">formSchema</span>: <span class="title class_">FormSchema</span>[] = [</span><br><span class="line">  &#123; <span class="attr">field</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">label</span>: <span class="string">&#x27;岗位名称&#x27;</span>, <span class="attr">component</span>: <span class="string">&#x27;Input&#x27;</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;岗位编码&#x27;</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;Input&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;岗位顺序&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;InputNumber&#x27;</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">componentProps</span>: &#123;</span><br><span class="line">      <span class="attr">min</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;岗位状态&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;RadioButtonGroup&#x27;</span>,</span><br><span class="line">    <span class="attr">defaultValue</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">componentProps</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: [</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">&#x27;启用&#x27;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">&#x27;停用&#x27;</span>, <span class="attr">value</span>: <span class="number">1</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">field</span>: <span class="string">&#x27;remark&#x27;</span>, <span class="attr">label</span>: <span class="string">&#x27;备注&#x27;</span>, <span class="attr">component</span>: <span class="string">&#x27;InputTextArea&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-封装-api"><a href="#4-封装-api" class="headerlink" title="4.封装 api"></a>4.封装 api</h4><p>api&#x2F;system&#x2F;post&#x2F;index.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defHttp &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/http/axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">PostVO</span> &#123;</span><br><span class="line">  id?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">sort</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">status</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">remark</span>: <span class="built_in">string</span>;</span><br><span class="line">  createTime?: <span class="title class_">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">PostPageReqVO</span> <span class="keyword">extends</span> <span class="title class_">PageParam</span> &#123;</span><br><span class="line">  code?: <span class="built_in">string</span>;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  status?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">PostExportReqVO</span> &#123;</span><br><span class="line">  code?: <span class="built_in">string</span>;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  status?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询岗位列表</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPostPageApi</span> = (<span class="params">params: PostPageReqVO</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="property">get</span>&lt;<span class="title class_">PageResult</span>&lt;<span class="title class_">PostVO</span>&gt;&gt;(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/page&#x27;</span>, params &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取岗位精简信息列表</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">listSimplePostsApi</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="title function_">get</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/list-all-simple&#x27;</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询岗位详情</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPostApi</span> = (<span class="params">id: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="title function_">get</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/get?id=&#x27;</span> + id &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增岗位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createPostApi</span> = (<span class="params">data: PostVO</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="title function_">post</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/create&#x27;</span>, data &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改岗位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">updatePostApi</span> = (<span class="params">data: PostVO</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="title function_">post</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/update&#x27;</span>, data &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除岗位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">deletePostApi</span> = (<span class="params">id: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="title function_">post</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/delete?id=&#x27;</span> + id &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出岗位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">exportPostApi</span> = (<span class="params">params: PostExportReqVO</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defHttp.<span class="title function_">download</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/system/post/export&#x27;</span>, params &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 三禾一 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三禾一 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sxms</title>
      <link href="/posts/3936.html"/>
      <url>/posts/3936.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="1-h5的新特性？css3的新特性？"><a href="#1-h5的新特性？css3的新特性？" class="headerlink" title="1.h5的新特性？css3的新特性？"></a>1.h5的新特性？css3的新特性？</h2><p><strong>H5新特性</strong></p><ol><li>拖拽释放api</li><li>自定义属性data-id</li><li>语义化标签</li><li>audio、video</li><li>canvas</li><li>地理api</li><li>localStorage、sessionStorage</li><li>表单控件</li><li>webworker、websocket</li></ol><p><strong>css3新特性</strong></p><ol><li>rgba</li><li>border-radius</li><li>盒子模型</li><li>线性渐变</li><li>过渡</li><li>动画</li><li>flex</li><li>字体图标</li></ol><h2 id="2-盒子水平垂直居中"><a href="#2-盒子水平垂直居中" class="headerlink" title="2.盒子水平垂直居中"></a>2.盒子水平垂直居中</h2><ol><li>绝对定位 + transform：translate（-50%，-50%）</li><li>flex布局</li></ol><h2 id="3-css选择器优先级"><a href="#3-css选择器优先级" class="headerlink" title="3.css选择器优先级"></a>3.css选择器优先级</h2><p>！Important&gt;行内样式&gt;ID 选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性</p><h2 id="4-rem的理解"><a href="#4-rem的理解" class="headerlink" title="4.rem的理解"></a>4.rem的理解</h2><p>rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。</p><p>手淘方案：</p><ol><li>拿到设计稿除以 10，得到 font-size 基准值</li><li>引入 flexible</li><li>设计稿 px&#x2F; font-size 基准值，即可换算为 rem</li></ol><h2 id="5-position"><a href="#5-position" class="headerlink" title="5.position"></a>5.position</h2><ol><li>static 静态定位（默认值）：不脱离文档流</li><li>absolute 绝对定位 ：找最近一级带有定位的父级元素进行移动 脱离文档流</li><li>relative 相对定位 </li><li>fixed 固定定位 脱离文档流 参照物浏览器窗口</li><li>sticky 粘性定位</li></ol><h2 id="6-浮动-float"><a href="#6-浮动-float" class="headerlink" title="6.浮动 float"></a>6.浮动 float</h2><p>浮动将元素排除在普通流之外，即元素将脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留。</p><p>1、子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素；</p><p>2、与浮动元素同级的非浮动元素（内联元素）会跟随其后；</p><p>3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法</p><p>清除浮动</p><ol><li>额外标签法  clear：both</li><li>双伪元素清除法</li><li>单伪元素清除法</li><li>构建BFC  为父元素添加 <code>overflow: hidden</code>   溢出隐藏</li><li>定高法</li></ol><h2 id="7-伪类和伪元素"><a href="#7-伪类和伪元素" class="headerlink" title="7. 伪类和伪元素"></a>7. 伪类和伪元素</h2><p>伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的;:hover</p><p>伪元素：用于创建一些不在DOM树中的元素，并为其添加样式 ;例如，我们可以通过  :before  :after</p><h2 id="8-css预处理器"><a href="#8-css预处理器" class="headerlink" title="8.css预处理器"></a>8.css预处理器</h2><p>Less、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率</p><h2 id="9-vw适配"><a href="#9-vw适配" class="headerlink" title="9.vw适配"></a>9.vw适配</h2><ul><li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100&#x2F;750)*32 vw</li><li>对于需要等比缩放的元素，CSS使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li></ul><h2 id="10-如何解决-margin“塌陷”？"><a href="#10-如何解决-margin“塌陷”？" class="headerlink" title="10.如何解决 margin“塌陷”？"></a><strong>10.如何解决 margin“塌陷”？</strong></h2><p><strong>外边距塌陷共有两种情况：</strong></p><p>第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同时出现</p><p>第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。</p><p><strong>解决方案：</strong></p><p>1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成透明：border：1px solid transparent）；</p><p>2、为父盒子添加 overflow：hidden；</p><p>3、为父盒子设定 padding 值；</p><p>4、为父盒子添加 position：fixed；</p><p>5、为父盒子添加 display：table；</p><h2 id="11-通过-CSS-的哪些方式可以实现隐藏页面上的元素？"><a href="#11-通过-CSS-的哪些方式可以实现隐藏页面上的元素？" class="headerlink" title="11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？"></a>11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？</h2><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td>opacity: 0</td><td>通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互</td></tr><tr><td>visibility: hidden</td><td>与透明度为0的方案非常类似，会占据空间，但不可以进行交互</td></tr><tr><td>overflow: hidden</td><td>只会隐藏元素溢出的部分；占据空间且不可交互</td></tr><tr><td>display: none</td><td>可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局</td></tr><tr><td>z-index: -9999</td><td>通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果</td></tr><tr><td>transform: scale(0,0)</td><td>通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互,只是一个视觉效果，不会影响其它盒子的布局。</td></tr><tr><td>left: -9999px</td><td>通过将元素定位到屏幕外面，达到看起来看不到的效果</td></tr></tbody></table><h2 id="12-如何理解-z-index？"><a href="#12-如何理解-z-index？" class="headerlink" title="12. 如何理解 z-index？"></a>12. 如何理解 z-index？</h2><p>可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。</p><p>元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。</p><p><code>z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级，当前盒子的z-index层级只是在父元素里面的层级</code></p><h2 id="13-谈谈你对-flex-的理解？"><a href="#13-谈谈你对-flex-的理解？" class="headerlink" title="13. 谈谈你对 flex 的理解？"></a>13. 谈谈你对 flex 的理解？</h2><p>在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。</p><p>flex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。 </p><p>你能联想到的flex语法有哪些呢?</p><p><code>flex-direction</code>: 调整主轴方向</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row：主轴方向为水平向右</span><br><span class="line">column：主轴方向为竖直向下</span><br><span class="line">row-reverse:主轴方向为水平向左</span><br><span class="line">column-reverse:主轴方向是竖直向上。</span><br></pre></td></tr></table></figure><p><code>justify-content</code>主要用来设置<strong>主轴方向的对齐方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start: 弹性盒子元素将向起始位置对齐</span><br><span class="line">flex-end: 弹性盒子元素将向结束位置对齐。</span><br><span class="line">center: 弹性盒子元素将向行中间位置对齐</span><br><span class="line">space-around: 弹性盒子元素会平均地分布在行里</span><br><span class="line">space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。</span><br></pre></td></tr></table></figure><p><code>align-items</code>用于调整<strong>侧轴的对齐方式</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex-start： 元素在侧轴的起始位置对齐。 </span><br><span class="line">flex-end： 元素在侧轴的结束位置对齐。</span><br><span class="line">center： 元素在侧轴上居中对齐。</span><br><span class="line">stretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。</span><br></pre></td></tr></table></figure><p><code>flex-wrap</code>属性控制flex容器是单行或者多行,默认不换行</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。</span><br><span class="line">wrap： 当宽度不够的时候，会换行。</span><br></pre></td></tr></table></figure><p><code>align-content</code>用来设置多行的flex容器的排列方式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-start： 各行向侧轴的起始位置堆叠。 </span><br><span class="line">flex-end： 各行向弹性盒容器的结束位置堆叠。</span><br><span class="line">center： 各行向弹性盒容器的中间位置堆叠。</span><br><span class="line">space-around： 各行在侧轴中平均分布。 </span><br><span class="line">space-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 </span><br><span class="line">stretch：拉伸，不设置高度的情况下。</span><br></pre></td></tr></table></figure><blockquote><p>可参考 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex布局教程</a></p></blockquote><hr><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-let-var-const的区别？"><a href="#1-let-var-const的区别？" class="headerlink" title="1. let var const的区别？"></a>1. let var const的区别？</h2><p><strong>var ES5变量声明方式</strong></p><ol><li>在变量未赋值时，变量undefined（为使用声明变量时也为undefined）</li><li>作用域 var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</li></ol><p><strong>let ES6变量声明方式</strong></p><ol><li>在变量为声明前直接使用会报错</li><li>作用域   let为块级作用域   通常let比var范围要小</li><li>let禁止 重复声明变量，否则会报错；var可以重复声明</li></ol><p><strong>const ES6变量声明</strong></p><ol><li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值</li><li>const实际上保证的，并不是变量的值不得改动，而时变量指向的哪个内存地址不得改动</li></ol><h2 id="2-js数据类型，区别"><a href="#2-js数据类型，区别" class="headerlink" title="2. js数据类型，区别"></a>2. js数据类型，区别</h2><p><strong>基本数据类型：</strong></p><p>number，string，boolean，null，undefined，symbol，bigint</p><p><strong>引用数据类型：</strong></p><p>object，function</p><p>object：普通对象，数组对象，正则对象，日期对象，math数学函数对象。</p><p>(NaN 是一个数值类型，但不是一个具体的数字。)</p><h2 id="3-slice-是干嘛的、splice是否会改变原数组？"><a href="#3-slice-是干嘛的、splice是否会改变原数组？" class="headerlink" title="3.slice 是干嘛的、splice是否会改变原数组？"></a>3.slice 是干嘛的、splice是否会改变原数组？</h2><ol><li><p>slice 是来截取的  参数可以写 slice(3)、slice(-3)、slice(1,3) 返回的是一个新的数组</p></li><li><p>splice 功能有：插入、删除、替换</p><p>返回：删除的值</p><p>该方法会改变原数组</p></li></ol><h2 id="4-数组去重"><a href="#4-数组去重" class="headerlink" title="4.数组去重"></a>4.数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br></pre></td></tr></table></figure><h2 id="5-Javascript-创建对象的几种方式？"><a href="#5-Javascript-创建对象的几种方式？" class="headerlink" title="5. Javascript 创建对象的几种方式？"></a>5. <strong>Javascript 创建对象的几种方式？</strong></h2><ol><li>简单对象的创建 使用对象字面量的方式{}</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Cat</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>new 一个function</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personOne=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><ol start="3"><li>使用工厂方式来创建（Object 关键字）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wcDog =<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 Object.create() 创建对象（使用现有对象作为原型）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(anotherPerson);</span><br></pre></td></tr></table></figure><ol start="5"><li>使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="6-如何区分数组和对象？"><a href="#6-如何区分数组和对象？" class="headerlink" title="6. 如何区分数组和对象？"></a>6. 如何区分数组和对象？</h2><ol><li>通过 ES6 中的 Array.isArray</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过 instanceof 来识别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过调用 constructor 来识别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.<span class="property">constructor</span> <span class="comment">//返回 object</span></span><br><span class="line">[].<span class="property">constructor</span> <span class="comment">//返回 Array</span></span><br></pre></td></tr></table></figure><ol start="4"><li>通过 Object.prototype.toString.call 方法来识别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">//[&quot;object Array&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">//[&quot;object Object&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="7-作用域和作用域链"><a href="#7-作用域和作用域链" class="headerlink" title="7. 作用域和作用域链"></a>7. 作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离<br>变量，不同作用域下同名变量不会有冲突。</p><p>全局作用域 和 局部作用域（分为 函数作用域 和 块级作用域）</p><ol><li>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。</li><li>ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现</li></ol><p><strong>什么是作用域链？</strong></p><p>作用域本质上是底层的变量查找机制。</p><p>在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。</p><p>总结：</p><ol><li>嵌套关系的作用域串联起来形成了作用域链</li><li>相同作用域链中按着从小到大的规则查找变量</li><li>子作用域能够访问父级作用域，父级作用域无法访问子级作用域</li></ol><ul><li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链</p></li><li><p>由子级作用域返回父级作用域中寻找变量，就叫做作用域链</p></li><li><p>作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自中的最后一个对象</p></li><li><p>作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象</p></li></ul><p><strong>如何延长作用域链？</strong></p><p>执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除具体来说就是执行这两个语句时，作用域链都会得到加强</p><ol><li><p>try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明</p></li><li><p>with 语句。with 语句会将指定的对象添加到作用域链中</p></li></ol><h2 id="8-map-和-forEach-的区别？"><a href="#8-map-和-forEach-的区别？" class="headerlink" title="8. map 和 forEach 的区别？"></a>8. map 和 forEach 的区别？</h2><p><strong>相同点：</strong></p><ol><li>都是循环遍历数组中的每一项</li><li>每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），<br>arr（原数组）</li><li>匿名函数中的this都是指向window</li><li>只能遍历数组</li></ol><p><strong>不同点：</strong></p><ol><li>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</li><li>forEach()允许callback更改原始数组的元素。map()返回新的数组。</li></ol><h2 id="9-js遍历对象的方法？"><a href="#9-js遍历对象的方法？" class="headerlink" title="9. js遍历对象的方法？"></a>9. js遍历对象的方法？</h2><ol><li><code>for...in</code> 循环</li><li><code>Object.keys()</code> 方法   获取对象中所有的键  对应 object.value</li><li><code>Object.entries()</code> 方法</li></ol><h2 id="10-new操作符具体干了什么呢"><a href="#10-new操作符具体干了什么呢" class="headerlink" title="10. new操作符具体干了什么呢?"></a>10. new操作符具体干了什么呢?</h2><ol><li>创建新对象</li><li>构造函数this指向新对象</li><li>执行构造函数代码，修改this，添加新的属性</li><li>返回新对象</li></ol><h2 id="11-类数组转换为数组"><a href="#11-类数组转换为数组" class="headerlink" title="11.类数组转换为数组"></a>11.类数组转换为数组</h2><ul><li>使用 Array.from()</li><li>使用 Array.prototype.slice.call()</li><li>使用 Array.prototype.forEach() 进行属性遍历并组成新的数组</li></ul><h2 id="12-简单说说-js-中有哪几种内存泄露的情况"><a href="#12-简单说说-js-中有哪几种内存泄露的情况" class="headerlink" title="12.简单说说 js 中有哪几种内存泄露的情况"></a>12.简单说说 js 中有哪几种内存泄露的情况</h2><ol><li>意外的全局变量；</li><li>闭包；</li><li>未被清空的定时器；</li><li>未被销毁的事件监听；</li><li>DOM 引用；</li></ol><h2 id="13-promise和-async-await-区别"><a href="#13-promise和-async-await-区别" class="headerlink" title="13. promise和 async await 区别?"></a>13. promise和 async await 区别?</h2><p><strong>概念</strong><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强<br>大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而<br>这些结果一旦生成是无法改变的<br>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执<br>行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象<br><strong>两者的区别</strong></p><ol><li>Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向<br>发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async<br>await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同<br>于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li><li>async await与Promise一样，是非阻塞的。</li><li>async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函<br>数。</li></ol><h2 id="14-defer和async区别"><a href="#14-defer和async区别" class="headerlink" title="14. defer和async区别?"></a>14. defer和async区别?</h2><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。多个defer脚本会按照它们在页面出现的顺序加载。&#x3D;&#x3D;“渲染完再执行”&#x3D;&#x3D;</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本是不能保证加载顺序的。&#x3D;&#x3D;“下载完就执行”&#x3D;&#x3D;</li></ul><p><strong>延迟加载有哪些js方式？</strong></p><ol><li><strong>defer</strong> : 等 html 全部解析完成，才会执行 js 代码，顺次执行 js 代码。</li><li><strong>async</strong>：async 和 html 解析是同步的（一起的），不是顺次执行 js 脚本（谁先加载完谁先执行）</li></ol><h2 id="15-同步和异步"><a href="#15-同步和异步" class="headerlink" title="15. 同步和异步"></a>15. 同步和异步</h2><p><strong>同步</strong></p><ul><li>指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。</li><li>也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序<br>和任务排列顺序是一致的。</li></ul><p><strong>异步</strong></p><ul><li>异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</li><li>每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。</li><li>程序的执行顺序和任务的排列顺序是不一致的，异步的。</li><li>我们常用的setTimeout和setInterval函数，Ajax都是异步操作。</li></ul><h2 id="16-null-和-undefined-的区别"><a href="#16-null-和-undefined-的区别" class="headerlink" title="16. null 和 undefined 的区别"></a>16. null 和 undefined 的区别</h2><p><strong>undefined</strong></p><ol><li>声明了一个变量，但没有赋值</li><li>访问对象上不存在的属性</li><li>函数定义了形参，但没有传递实参</li><li>使用 void 对表达式求值</li></ol><p><strong>null</strong></p><p>看过作者文献：最初设计js的时候借助了java的语言。</p><p>null 会被隐式的转换为 0，很不容易发现错误。</p><p>先有null 后有 undefined 是为了填补之前的坑。</p><p>具体区别：js 的最初版本是这样区分的，null 是一个表示 “无” 的对象，转为数值时为 0 值，转为数值才为 NaN。</p><ol><li>null是一个空值，表示无的对象</li><li>null 有属于自己的类型 Null，而不属于Object类型</li><li>二进制的前三位为 0 会被 typeof 判断为对象类型</li></ol><h2 id="17-call-appy-bind的作用和区别？"><a href="#17-call-appy-bind的作用和区别？" class="headerlink" title="17. call appy bind的作用和区别？"></a>17. call appy bind的作用和区别？</h2><p><strong>作用：</strong></p><p>都可以改变函数内部的this指向</p><p><strong>区别点：</strong></p><ol><li>call 和 apply 会调用函数，并且改变函数内部this指向。</li><li>call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg]</li><li>bind 不会调用函数，可以改变函数内部this指向</li></ol><p>应用场景</p><ol><li>object.prototype.toString.call()  检测数据类型</li><li>apply 经常和数组有关系，比如借助于数学对象实现数组的最大值最小值</li><li>比如改变定时器内部 的this 指向</li></ol><h2 id="18-this指向（普通函数、箭头函数）"><a href="#18-this指向（普通函数、箭头函数）" class="headerlink" title="18. this指向（普通函数、箭头函数）"></a>18. this指向（普通函数、箭头函数）</h2><ol><li>谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁</li><li>匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象</li></ol><p><strong>箭头函数中的this</strong></p><ul><li>箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的</li><li>箭头函数中的this指向父级作用域的执行上下文；</li><li>箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来</li></ul><h2 id="19-继承"><a href="#19-继承" class="headerlink" title="19. 继承"></a>19. 继承</h2><p>继承一些属性构造的过程和方法</p><p><strong>继承的好处</strong></p><p>a：提高了代码的复用性</p><p>b：提高了代码的维护性</p><p>c：让类与类之间产生了关系，是多态的前提</p><p><strong>继承的弊端</strong></p><p>类的耦合性增强了,但是开发的原则：高内聚，低耦合</p><ol><li>构造函数继承</li><li>原型链继承</li><li>原型式继承</li><li>组合继承</li><li>寄生式继承</li><li>寄生组合式继承</li><li>class extends 继承</li></ol><h2 id="20-promise"><a href="#20-promise" class="headerlink" title="20. promise"></a>20. promise</h2><p>promise的设计之初就是为了解决回调地狱的问题的。</p><p>本意是承诺，<strong>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了</strong></p><p><strong>Promise的三种状态</strong></p><ul><li><p>Pending—-Promise对象实例创建时候的初始状态</p></li><li><p>Fulfilled—-可以理解为成功的状态</p></li><li><p>Rejected—-可以理解为失败的状态</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)<span class="comment">//无效代码不会执行</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reason)<span class="comment">//reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>promise的链式调用</p><p>如果上一个.then中返回一个新的promise对象，则可以交给下一个.then继续处理。</p><ul><li>每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)</li><li>如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调</li><li>如果then中出现异常,会走下一个then的失败回调</li><li>在 then中使用了return，那么 return 的值会被Promise.resolve() 包装</li><li>then中可以不传递参数，如果不传递会透到下一个then中</li><li>catch 会捕获到没有捕获的异常</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">//包装成 Promise.resolve(2)</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="number">3</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="title function_">ajax</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">ajax</span>(url1)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">ajax</span>(url2)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure><p>存在一个缺点：无法取消promise，错误需要通过回调函数捕获</p><p>场景：</p><ol><li>异步请求</li><li>定时器</li><li>并行异步操作  当需要同时进行多个异步操作，并在它们都完成后执行一些任务时，可以使用 Promise.all 方法。</li></ol><p><strong>promise静态常用的方法</strong></p><ol><li>promise.all（[promise1,promise2…]）  等待机制  等待完才会走 .then</li><li>promise.race   赛跑机制</li></ol><h2 id="21、JavaScript-内置的常用对象有哪些？"><a href="#21、JavaScript-内置的常用对象有哪些？" class="headerlink" title="21、JavaScript 内置的常用对象有哪些？"></a>21、JavaScript 内置的常用对象有哪些？</h2><p><strong>对象及方法</strong></p><p>Arguments 函数参数集合</p><p>Arguments[ ] 函数参数的数组</p><p>Arguments 一个函数的参数和其他属性</p><p>Arguments.callee 当前正在运行的函数</p><p>Arguments.length 传递给函数的参数的个数</p><p><strong>Array 数组</strong></p><p>length 属性 </p><p>join() 将一个数组转成字符串。返回一个字符串。</p><p>reverse() 将数组中各元素颠倒顺序</p><p>delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。</p><p>shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。</p><p>pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。</p><p>unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，“b，“c”)</p><p>push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，“c”)</p><p>concat( ) 连接数组</p><p>slice( ) 返回数组的一部分</p><p>sort( ) 对数组元素进行排序</p><p>splice( ) 插入、删除或替换数组的元素</p><p>toLocaleString( ) 把数组转换成局部字符串</p><p>toString( ) 将数组转换成一个字符串</p><p>forEach 遍历所有元素</p><p>every 判断所有元素是否都符合条件</p><p>sort 排序</p><p>map 对元素重新组装，生成新数组</p><p>filter 过滤符合条件的元素</p><p><strong>String 字符串对象</strong></p><p>Length 获取字符串的长度。</p><p>toUpperCase() 将字符串中的字母转成全大写。如：strObj.toUpperCase()</p><p>charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串</p><p>substr() 在原始字符串，返回一个子字符串</p><p>substring() 在原始字符串，返回一个子字符串</p><p>split() 将一个字符串转成数组</p><p>charCodeAt( ) 返回字符串中的第 n 个字符的代码</p><p>concat( ) 连接字符串</p><p>fromCharCode( ) 从字符编码创建—个字符串</p><p>indexOf( ) 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没有找到，则返回-1</p><p>lastIndexOf( ) 从后向前检索一个字符串</p><p>localeCompare( ) 用本地特定的顺序来比较两个字符串</p><p>match( ) 找到一个或多个正则表达式的匹配</p><p>replace( ) 替换一个与正则表达式匹配的子串</p><p>search( ) 检索与正则表达式相匹配的子串</p><p>slice( ) 抽取一个子串</p><p>toLocaleLowerCase( ) 把字符串转换小写</p><p>toLocaleUpperCase( ) 将字符串转换成大写</p><p>toLowerCase( ) 将字符串转换成小写</p><p>toString( ) 返回字符串</p><p>toUpperCase( ) 将字符串转换成大写</p><p>valueOf( )</p><h2 id="22-谈谈事件委托的理解？"><a href="#22-谈谈事件委托的理解？" class="headerlink" title="22.谈谈事件委托的理解？"></a>22.谈谈事件委托的理解？</h2><p>JavaScript 事件代理则是一种简单的技巧，把事件处理器添加到一个上级元素上，这样就避免了把事件处理器添加到多个子级元素上。这主要得益于浏览器的事件冒泡机制。</p><p><strong>优点：</strong></p><p>1、减少事件注册，节省内存。</p><p>2、在 table 上代理所有 td 的 click 事件。</p><p>3、在 ul 上代理所有 li 的 click 事件。</p><p>4、简化了 dom 节点更新时，相应事件的更新。</p><p>5、不用在新添加的 li 上绑定 click 事件。</p><p>6、当删除某个 li 时，不用移解绑上面的 click 事件。</p><p><strong>缺点：</strong></p><p>1、事件委托基于冒泡，对于不冒泡的事件不支持</p><p>2、层级过多，冒泡过程中，可能会被某层阻止掉。</p><p>3、理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在 table 上代理 td，而不是在 document 上代理 td。</p><p>4、把所有事件都用代理就可能会出现事件误判。比如，在 document 中代理了所有 button 的 click事件，另外的人在引用改 js 时，可能不知道，造成单击 button 触发了两个 click 事件</p><h2 id="23-什么是闭包？"><a href="#23-什么是闭包？" class="headerlink" title="23.什么是闭包？"></a>23.什么是闭包？</h2><p><strong>定义：</strong></p><p> 一个作用域可以访问到另外一个函数内部的局部变量，或者说一个函数（子函数）访问另一个函数（父函数）中的变量。此时就会产生闭包，那么这个变量所在的函数我们就称之为闭包函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(a++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fun = <span class="title function_">aaa</span>()</span><br><span class="line"><span class="title function_">fun</span>()              <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>优缺点：</strong></p><p>闭包的主要作用：延伸了变量的作用范围，因为闭包函数中的局变量不会等着闭包函数执行完就销毁，因为还有别的函数要调用它，只有等着所有的函数都调用完了它才会销毁。 <strong>实现数据的私有。</strong></p><p>闭包会造成内存泄露，如何解决：用完之后手动是释放。</p><p>优点:</p><p>1）可以减少全局变量的定义，避免全局变量的污染</p><p>2）能够读取函数内部的变量</p><p>3）在内存中维护⼀个变量，可以⽤做缓存</p><p>缺点:</p><p>1）造成内存泄露</p><p>2）闭包可能在⽗函数外部，改变⽗函数内部变量的值。</p><p>3）造成性能损失</p><p>使用场景：</p><ol><li>封装私有变量</li><li>闭包可以用于创建模块化的代码结构，避免全局变量的污染。</li><li>在处理用户输入或频繁触发的事件时，可以通过闭包来实现防抖（debounce）和节流（throttle）的效果。防抖和节流是优化性能和减少不必要请求的常见方法。</li><li>缓存数据：通过闭包，可以在函数内部缓存一些计算结果或其他重要数据，避免重复计算或请求。</li></ol><h2 id="24-for-in-和-for-of-的区别"><a href="#24-for-in-和-for-of-的区别" class="headerlink" title="24.for in 和 for of 的区别"></a>24.for in 和 for of 的区别</h2><p>1、推荐在循环对象属性的时候使用 for…in，在遍历数组的时候的时候使用 for…of</p><p>2、for…in 循环出的是 key，for…of 循环出的是 value</p><p>3、注意，for…of 是 ES6 新引入的特性。修复了 ES5 引入的 for…in 的不足</p><p>4、for…of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</p><h2 id="25、split（）和-join（）的区别？"><a href="#25、split（）和-join（）的区别？" class="headerlink" title="25、split（）和 join（）的区别？"></a>25、split（）和 join（）的区别？</h2><p>split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里即切割成数组的形式；</p><p>join() 是把数组中的字符串连成一个长串，可以大体上认为是 split()的逆操作</p><h2 id="26-深拷贝"><a href="#26-深拷贝" class="headerlink" title="26.深拷贝"></a>26.深拷贝</h2><blockquote><p>首先浅拷贝和深拷贝只针对引用类型</p></blockquote><p><strong>浅拷⻉</strong>: 拷贝的是地址</p><p>拷贝对象</p><ol><li>object.assign() </li><li>展开运算符</li></ol><p>拷贝数组</p><ol><li>object.prototype.concat()</li></ol><p>如果是简单数据类型拷贝值，不会影响元对象，引用数据类型拷贝的是地址。</p><p><strong>深拷⻉</strong>: 拷贝的是对象，不是地址</p><ol><li>递归</li><li>JSON 对象中的 parse 和 stringify</li><li>lodash  里的 cloneDeep</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">⽬前实现深拷⻉的主要是利⽤ <span class="title class_">JSON</span> 对象中的 parse 和 stringify  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloneArray = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(originArray));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArray === originArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>用到？</p><ol><li>处理嵌套对象和数组：创建一个独立的副本。这样，对副本的修改不会影响原始数据。</li><li>操作不可变的数据</li><li>序列化和反序列化：当你需要将对象转换为字符串进行存储或传输时，深拷贝可以帮助你创建一个完整的副本，并且在后续需要时可以还原为原始对象。</li></ol><h2 id="27-原型链"><a href="#27-原型链" class="headerlink" title="27.原型链"></a>27.原型链</h2><p><strong>原型</strong></p><ol><li>构造函数通过原型分配的函数是所有对象所共享的</li><li>js 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象。</li><li>这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存。</li><li>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</li><li>构造函数和原型对象中的this 都指向实例化对象。</li></ol><p><strong>constructor属性</strong></p><p>每个原型对象里面都有个 constructor 属性，该属性指向该原型对象的构造函数。</p><p>使用场景：</p><p>如果有多个对象的方法，我们可以给原型对象采取 对象形式赋值。</p><p>但是这样就会覆盖构造函数原型对象原来的内容。</p><p>这样修改后的原型对象 constructor 就不再指向当前构造函数了。</p><p>此时，我们应该在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><p><strong>对象原型 –proto–</strong></p><p>实例对象的原型，对象都有一个属性 –proto–，指向构造函数的 prototype 原型对象。</p><p>之所以我们对象可以使用构造函数prototype原型对象上的方法和属性，就是因为对象有–proto–原型的存在。</p><p><strong>原型链：</strong></p><p>所有的实例对象里面都有–proto–对象原型，指向原型对象</p><p>所有的原型对象里面有 constructor，指向创造该原型对象的构造函数</p><ol><li>当访问一个对象的属性和方法时，首先查找这个对象本身有没有该属性</li><li>如果没有就查找它的原型（也就是–proto–指向的prototype原型对象）</li><li>如果还没有就查找原型对象上的原型</li><li>依此类推，一直找到为止</li><li>–proto–对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li><li>可以使用 instanceof 运算符用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上。<br><img src="https://bu.dusays.com/2023/10/29/653d326d4d351.png" alt="Snipaste_2023-10-29_00-09-55.png"></li></ol><h2 id="28-防抖和节流"><a href="#28-防抖和节流" class="headerlink" title="28.防抖和节流"></a>28.防抖和节流</h2><p>**防抖(debounce)**：触发⾼频事件后 n 秒内函数只会执⾏⼀次，如果 n 秒内⾼频事件再次被触发，则重新计算时间</p><p>使用场景：</p><ol><li>搜索框防抖</li><li>手机号、邮箱验证输入检测</li></ol><p><strong>手写防抖函数</strong>：</p><p>思路：防抖的核心就是利用 settimeout 实现的</p><ol><li>声明一个定时器变量</li><li>当鼠标每次滑动都先判断 是否有定时器了，如果有定时器先清除以前的定时器</li><li>如果没有定时器则开启定时器，记得存到变量里面</li><li>在定时器里面调用要执行的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeId</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timeId) <span class="built_in">clearTimeout</span>(timeId)</span><br><span class="line">        timeId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">fn</span>() </span><br><span class="line">        &#125;,t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="title function_">debounce</span>(mouseMove,<span class="number">500</span>))</span><br></pre></td></tr></table></figure><p>**节流(throttle)**：⾼频事件触发，但在 n 秒内只会执⾏⼀次，所以节流会稀释函数的执⾏频率</p><p>使用场景：</p><ol><li>小米轮播图切换点击效果</li><li>页面尺寸缩放resize</li><li>滚动条滚动</li></ol><p><strong>手写节流函数</strong></p><p>思路：一样</p><ol><li>声明一个定时器变量</li><li>当鼠标每次滑动都先判断 是否有定时器了，如果有定时器，则不开启新定时器</li><li>如果没有定时器则开启定时器，记得存到变量里面</li><li>定时器里面调用执行的函数</li><li>清空定时器</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!timeId) &#123;</span><br><span class="line">            timeId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">               <span class="title function_">fn</span>()</span><br><span class="line">                timeId = <span class="literal">null</span></span><br><span class="line">            &#125;,t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="title function_">throttle</span>(mouseMove,<span class="number">500</span>))</span><br></pre></td></tr></table></figure><p>区别：防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏变成每隔⼀段时间执⾏。</p><h2 id="29-ES6"><a href="#29-ES6" class="headerlink" title="29.ES6"></a>29.ES6</h2><ol><li>let  const</li><li>模板字符串</li><li>箭头函数</li><li>object.keys() 遍历对象的键</li><li>object.assign() 合并对象 常用于对象拷贝</li><li>for of</li><li>import（用于在一个模块中加载另一个含有 export 接口的模块）  export（用于对外输出本模块）</li><li>promise</li><li>set</li><li>class</li></ol><h2 id="30-介绍下-Set、Map-的区别"><a href="#30-介绍下-Set、Map-的区别" class="headerlink" title="30.介绍下 Set、Map 的区别"></a>30.介绍下 Set、Map 的区别</h2><p><strong>区别</strong></p><p>应用场景 Set 用于数据重组，Map 用于数据储存</p><p>Set：</p><p>成员不能重复</p><p>只有键值没有键名，类似数组</p><p>可以遍历，方法有 add, delete,has</p><p>Map: </p><p>本质上是健值对的集合，类似集合</p><p>可以遍历，可以跟各种数据格式转换</p><h2 id="31-async-await"><a href="#31-async-await" class="headerlink" title="31.async await"></a>31.async await</h2><ol><li>async 用于修饰一个函数，表示一个函数是异步的</li><li>await 要用在 async 函数中</li><li>await 后面一般会跟一个 promise 对象</li><li>await 只会等待 promise 成功的结果</li></ol><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="1-cookie-sessionStorage-localStorage区别"><a href="#1-cookie-sessionStorage-localStorage区别" class="headerlink" title="1.cookie sessionStorage localStorage区别"></a>1.cookie sessionStorage localStorage区别</h2><p><strong>共同点：</strong></p><p>都是保存在浏览器端、且同源的</p><p><strong>区别：</strong></p><ol><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 </p></li><li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 </p></li><li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </p></li><li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p></li><li><p>Storage的api接口使用更方便</p></li></ol><h2 id="2-浏览器输入URL发生了什么"><a href="#2-浏览器输入URL发生了什么" class="headerlink" title="2. 浏览器输入URL发生了什么"></a>2. 浏览器输入URL发生了什么</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h2 id="3-浏览器是如何渲染页面的？"><a href="#3-浏览器是如何渲染页面的？" class="headerlink" title="3. 浏览器是如何渲染页面的？"></a>3. 浏览器是如何渲染页面的？</h2><p>不同浏览器内核渲染机制有所区别</p><ol><li>HTML 被 HTML 解析器解析成 DOM 树；</li><li>CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><h2 id="4-重绘、重排"><a href="#4-重绘、重排" class="headerlink" title="4. 重绘、重排"></a>4. 重绘、重排</h2><p><strong>概念</strong></p><ol><li>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树</li><li>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</li></ol><p><strong>区别：</strong></p><p>重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p><p><strong>引发重排</strong></p><ol><li>添加、删除可见的dom</li><li>元素的位置改变</li><li>元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</li><li>页面渲染初始化</li><li>浏览器窗口尺寸改变</li><li>获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存</li></ol><p><strong>优化方案</strong></p><p>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p><p>减少 reflow&#x2F;repaint：</p><ol><li><p>不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的className。</p></li><li><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会reflow 的。</p></li><li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)</p></li><li><p>不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</p></li></ol><h2 id="5-事件循环（Event-loop）"><a href="#5-事件循环（Event-loop）" class="headerlink" title="5. 事件循环（Event loop）"></a>5. 事件循环（Event loop）</h2><p>js 是一门单线程执行的语言。也就是说，同一时间只能做一件事情。</p><p>为了防止某个耗时任务导致程序假死的问题，异步代码由js 委托给宿主环境（浏览器、node环境）等待执行。</p><p><strong>JavaScript 的事件分两种</strong></p><ol><li>宏任务：包括整体代码 script，setTimeout，setInterval</li><li>微任务：Promise.then(非 new Promise是同步的)，catch、process.nextTick(node 中)</li></ol><p><strong>具体执行：</strong></p><p>事件的执行顺序——先执行宏任务，然后执行微任务，任务有同步的任务和异步的任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放在队列中，如果还有异步的宏任务，那么就会进行循环执行上述的操作</p><p>主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行</p><p><strong>详细步骤</strong>：</p><ol><li><p>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</p></li><li><p>将事件循环的当前运行宏任务设置为已选择的宏任务。</p></li><li><p>运行宏任务。</p></li><li><p>将事件循环的当前运行任务设置为null。</p></li><li><p>将运行完的宏任务从宏任务队列中移除。</p></li><li><p>microtasks步骤：进入microtask检查点。</p></li><li><p>更新界面渲染。</p></li><li><p>返回第一步。</p></li></ol><h2 id="6-跨域"><a href="#6-跨域" class="headerlink" title="6. 跨域"></a>6. 跨域</h2><p><strong>跨域是什么？</strong></p><p>跨域（Cross-Origin）指的是在浏览器中，当一个请求的源（Origin）与目标资源的源不一致时，即发生跨域访问。在默认情况下，浏览器的同源策略（Same-Origin Policy）会阻止这种跨域访问。同源策略是为了保护用户的信息安全，防止恶意网站对其他网站的资源进行访问和操作。</p><p><strong>同源策略规定几个约束</strong></p><ol><li>协议相同</li><li>域名相同</li><li>端口号相同</li></ol><p><strong>同源策略限制内容有</strong></p><ul><li>cookie、localstorage、indexedDB 等</li><li>dom节点</li><li>ajax 请求</li></ul><p><strong>跨域解决⽅法：</strong></p><p>1、jsonp⽅式</p><p>2、代理服务器的⽅式</p><p>3、服务端允许跨域访问(CORS)</p><p>4、取消浏览器的跨域限制</p><h2 id="7-常见code码"><a href="#7-常见code码" class="headerlink" title="7.常见code码"></a>7.常见code码</h2><p>200 - 请求成功</p><p>301 - 资源（⽹⻚等）被永久转移到其它URL</p><p>403 - Forbidden 服务器理解请求客户端的请求，但是拒绝执⾏此请求</p><p>404 - 请求的资源（⽹⻚等）不存在</p><p>500 - 内部服务器错误</p><p>502 - Bad Gateway 作为⽹关或者代理⼯作的服务器尝试执⾏请求时，从远程服务器接收到了⼀个⽆效的响应</p><h2 id="8-http-和-https-的区别"><a href="#8-http-和-https-的区别" class="headerlink" title="8. http 和 https 的区别"></a>8. http 和 https 的区别</h2><ol><li><p>HTTP 明⽂传输，数据都是未加密的，安全性较差，HTTPS 数据传输过程是加密的，安全性较好。</p></li><li><p>使⽤ HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，⼀般免费证书较少，因⽽需要⼀定费⽤</p></li><li><p>HTTP ⻚⾯响应速度⽐ HTTPS 快，主要是因为 HTTP 使⽤ TCP 三次握⼿建⽴连接，客户端和服务器需要交换 3 个包，⽽ HTTPS除了 TCP 的三个包，还要加上 ssl 握⼿需要的 9 个包，所以⼀共是 12 个包。</p></li><li><p>HTTP 和 HTTPS 使⽤的是完全不同的连接⽅式，⽤的端⼝也不⼀样，前者是 80，后者是 443。</p></li><li><p>HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要⽐较 HTTPS ⽐ HTTP 要更耗费服务器资源。</p></li></ol><h2 id="9-前端优化策略"><a href="#9-前端优化策略" class="headerlink" title="9. 前端优化策略"></a>9. 前端优化策略</h2><p>1、减少http请求数</p><p>2、将脚本往后挪，减少对并发下载的影响</p><p>3、避免频繁的DOM操作</p><p>4、压缩图⽚</p><p>5、gzip压缩优化，对传输资源进⾏体积压缩(html,js,css)</p><p>6、按需加载</p><p>7、组件化</p><p>8、减少不必要的Cookie（Cookie存储在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从⽽会影响加载速度，所以尽量减少不必要的Cookie。）</p><h2 id="10-介绍一下-websocket"><a href="#10-介绍一下-websocket" class="headerlink" title="10.介绍一下 websocket"></a>10.介绍一下 websocket</h2><p>websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通 信的协议，这个对比着 HTTP 协议来说，HTTP 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。HTTP 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信， 以 便 任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接， 就 可 以一直保持连接状态</p><h2 id="11-webpack"><a href="#11-webpack" class="headerlink" title="11.webpack"></a>11.webpack</h2><p>webpack 的作⽤就是处理依赖，模块化，打包压缩⽂件，管理插件。</p><p>1、webpack打包原理</p><p> 把所有依赖打包成⼀个 bundle.js ⽂件，通过代码分割成单元⽚段并按需加载。</p><p>2、webpack的优势</p><p>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的⽀持也很全⾯，⽅便</p><p>旧项⽬进⾏代码迁移。</p><p>（2）能被模块化的不仅仅是 JS 了。</p><p>（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的⼯作，⽐如打包、压缩混淆、图⽚转base64等。</p><p>（4）扩展性强，插件机制完善</p><h2 id="12-Get-和-Post-的区别以及使用场景"><a href="#12-Get-和-Post-的区别以及使用场景" class="headerlink" title="12.Get 和 Post 的区别以及使用场景"></a><strong>12.Get 和 Post 的区别以及使用场景</strong></h2><p><strong>区别</strong></p><p>1、Get 使用 URL 或 Cookie 传参。而 Post 将数据放在 body 中</p><p>2、Get 的 URL 会有长度上的限制，则 Post 的数据则可以非常大</p><p>3、Post 比 Get 安全，因为数据在地址栏上不可见</p><p><strong>最本质的区别</strong></p><p>基于 http 协议进行请求， 其实 GET 和 POST 无区别， 只是请求时的方式不同， 都可以携带请求体， 也可以在 URL 带参数区别来自于浏览器对 URL 长度的限制， 请求体大小来源于服务器的限制</p><p><strong>还有语义的区别：</strong></p><p>GET 是获取， POST 是提交</p><p>Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据</p><h2 id="13-HTTP有哪些⽅法？"><a href="#13-HTTP有哪些⽅法？" class="headerlink" title="13. HTTP有哪些⽅法？"></a>13. HTTP有哪些⽅法？</h2><p>HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD</p><p>HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT</p><h2 id="14-各个HTTP方法的具体作用是什么？"><a href="#14-各个HTTP方法的具体作用是什么？" class="headerlink" title="14. 各个HTTP方法的具体作用是什么？"></a>14. 各个HTTP方法的具体作用是什么？</h2><table><thead><tr><th align="center">方法</th><th>功能</th></tr></thead><tbody><tr><td align="center">GET</td><td>通常⽤于请求服务器发送某些资源</td></tr><tr><td align="center">POST</td><td>发送数据给服务器</td></tr><tr><td align="center">HEAD</td><td>请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个<code>使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</code></td></tr><tr><td align="center">PUT</td><td>⽤于全量修改⽬标资源 (看接口, 也可以用于添加)</td></tr><tr><td align="center">DELETE</td><td>⽤于删除指定的资源</td></tr><tr><td align="center">OPTIONS</td><td>⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全)</td></tr><tr><td align="center">TRACE</td><td>该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断</td></tr><tr><td align="center">CONNECT</td><td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户)</td></tr><tr><td align="center">PATCH</td><td>⽤于对资源进⾏部分修改</td></tr></tbody></table><p>GET POST PUT PATCH DELETE</p><p>GET&#x2F;DELETE  参数是在地址栏中传递的</p><p>PUT&#x2F;PATCH&#x2F;POST 参数是在请求体传递的</p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-谈谈你对-Vue-生命周期的理解？"><a href="#1-谈谈你对-Vue-生命周期的理解？" class="headerlink" title="1.谈谈你对 Vue 生命周期的理解？"></a>1.谈谈你对 Vue 生命周期的理解？</h2><p><strong>（1）生命周期是什么？</strong></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期</p><p><strong>（2）各个生命周期的作用</strong></p><table><thead><tr><th align="left">beforeCreate</th><th align="left">组件实例被创建之初，组件的属性生效之前</th></tr></thead><tbody><tr><td align="left">created</td><td align="left">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td align="left">beforeMount</td><td align="left">在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td align="left">mounted</td><td align="left">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td align="left">beforeUpdate</td><td align="left">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td align="left">update</td><td align="left">组件数据更新之后</td></tr><tr><td align="left">activited</td><td align="left">keep-alive 专属，组件被激活时调用</td></tr><tr><td align="left">deadctivated</td><td align="left">keep-alive 专属，组件被销毁时调用</td></tr><tr><td align="left">beforeDestory</td><td align="left">组件销毁前调用</td></tr><tr><td align="left">destoryed</td><td align="left">组件销毁后调用</td></tr></tbody></table><h2 id="2-keep-alive"><a href="#2-keep-alive" class="headerlink" title="2. keep-alive"></a>2. keep-alive</h2><p><strong>1、什么是keep-alive？</strong></p><p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，⽽不是销毁它们。keep-alive 是⼀个抽象组件：它⾃身不会渲染成⼀个 DOM 元素，也不会出现在⽗组件链中</p><p><strong>2、keep-alive的优点</strong>？</p><p>在组件切换过程中 把切换出去的组件保留在内存中，防⽌重复渲染DOM，减少加载时间及性能消耗，提⾼⽤户体验性。</p><p><strong>3、keep-alive有三个属性</strong></p><p>include ： 只有匹配的组件会被缓存</p><p>exclude ： 任何匹配的组件都不会被缓存</p><p>max ： 最多可以缓存多少组件实例</p><p><strong>4、keep-alive的使⽤会触发两个⽣命周期函数？</strong></p><p>这两个函数分别是</p><p>activated 当组件被激活（使⽤）的时候触发 可以简单理解为进⼊这个⻚⾯的时候触发</p><p>deactivated 当组件不被使⽤的时候触发 可以简单理解为离开这个⻚⾯的时候触发</p><h2 id="3-数据双向绑定原理"><a href="#3-数据双向绑定原理" class="headerlink" title="3. 数据双向绑定原理"></a>3. 数据双向绑定原理</h2><p>数据变化更新视图</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View &#x3D;&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data &#x3D;&gt; View 的变化</li></ul><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的⽅式来实现的.</p><p> 数据劫持、vue是通过Object.defineProperty()来实现数据劫持，</p><p> 其中会有getter()和setter⽅法；当读取属性值时，就会触发getter()⽅法，</p><p> 在view中如果数据发⽣了变化，就会通过Object.defineProperty( )对属性设置⼀个setter函数，</p><p> 当数据改变了就会来触发这个函数；</p><p>实现一个监听器 -&gt;实现一个解析器 -&gt; 实现一个订阅者 -&gt; 实现一个订阅器 Dep</p><h2 id="4-路由守卫"><a href="#4-路由守卫" class="headerlink" title="4. 路由守卫"></a>4. 路由守卫</h2><p><strong>1.全局路由守卫</strong></p><p>beforeEach(to, from, next) 全局前置守卫，路由跳转前触发</p><p>beforeResolve(to, from, next) 全局解析守卫 在所有组件内守卫和异步路由组件被解析之后触发</p><p>afterEach(to, from) 全局后置守卫，路由跳转完成后触发</p><p><strong>2.路由独享守卫</strong></p><p>beforeEnter(to,from,next) 路由对象单个路由配置 ，单个路由进⼊前触发</p><p><strong>3.组件路由守卫</strong></p><p>beforeRouteEnter(to,from,next) 在组件⽣命周期beforeCreate阶段触发</p><p>beforeRouteUpdadte(to,from,next) 当前路由改变时触发</p><p>beforeRouteLeave(to,from,next) 导航离开该组件的对应路由时触发</p><p><strong>4.参数</strong></p><p>to： 即将要进⼊的⽬标路由对象</p><p>from： 即将要离开的路由对象</p><p>next(Function)：是否可以进⼊某个具体路由，或者是某个具体路由的路径</p><h2 id="5-Vuex"><a href="#5-Vuex" class="headerlink" title="5. Vuex"></a>5. Vuex</h2><p>Vuex有五个核⼼概念：state,getters,mutations,actions,modules</p><ol><li><p>state：vuex的基本数据，⽤来存储变量</p></li><li><p>geeter：从基本数据(state)派⽣的数据，相当于state的计算属性</p></li><li><p>mutation：提交更新数据的⽅法，必须是同步的(如果需要异步使⽤action)。每个 mutation 都有⼀个字符串的 事件类型 (type) 和 ⼀个 回调函数 (handler)。</p></li></ol><p>回调函数就是我们实际进⾏状态更改的地⽅，并且它会接受 state 作为第⼀个参数，提交载荷作为第⼆个参数。</p><ol start="4"><li><p>action：和mutation的功能⼤致相同，不同之处在于 &#x3D;&#x3D;》1. Action 提交的是 mutation，⽽不是直接变更状态。 2. Action 可以包含任意异步操作。</p></li><li><p>modules：模块化vuex，可以让每⼀个模块拥有⾃⼰的state、mutation、action、getters,使得结构⾮常清晰，⽅便管理。</p></li></ol><h2 id="6-组件通讯（⽗、⼦）"><a href="#6-组件通讯（⽗、⼦）" class="headerlink" title="6. 组件通讯（⽗、⼦）"></a>6. 组件通讯（⽗、⼦）</h2><ol><li><p>⽗组件向⼦组件传值:⽗组件通过属性的⽅式向⼦组件传值，⼦组件通过 props 来接收</p></li><li><p>⼦组件向⽗组件传值:⼦组件绑定⼀个事件，通过 this.$emit() 来触发</p></li><li><p>其他⽅式：缓存、vuex、eventBus事件总线、provide  inject</p></li></ol><h2 id="7-怎么定义vue-router的动态路由？"><a href="#7-怎么定义vue-router的动态路由？" class="headerlink" title="7. 怎么定义vue-router的动态路由？"></a>7. 怎么定义vue-router的动态路由？</h2><p>在router⽬录下的index.js⽂件中，对path属性加上&#x2F;:id。 使⽤router对象的params.id </p><h2 id="8-2-0和3-0的区别"><a href="#8-2-0和3-0的区别" class="headerlink" title="8. 2.0和3.0的区别"></a>8. 2.0和3.0的区别</h2><p>双向绑定:</p><p>V2：使⽤Object.defineProperty</p><p>V3：使⽤ES6的新特性proxy来劫持数据，当数据改变时发出通知</p><p>根元素:</p><p>V2: 必须要有⼀个根元素</p><p>V3: ⽆要求</p><p>diff算法:</p><p>V2: 虚拟Dom全量⽐较</p><p>V3: 增加了静态标记PatchFlag</p><p>生命周期不同</p><h2 id="9-computed-与-watch-的区别"><a href="#9-computed-与-watch-的区别" class="headerlink" title="9. computed 与 watch 的区别"></a>9. computed 与 watch 的区别</h2><p>computed⽀持缓存，相依赖的数据发⽣改变才会重新计算；watch不⽀持缓存，只要监听的数据变化就会触发相应操作</p><p>computed不⽀持异步，当computed内有异步操作时是⽆法监听数据变化的；watch⽀持异步操作</p><p>computed属性的属性值是⼀函数，函数返回值为属性的属性值，computed中每个属性都可以设置set与get⽅法。watch监听的数据必须是data中声明过或⽗组件传递过</p><p><strong>computed</strong></p><ol><li>它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景 </li><li>它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存</li><li>只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算 </li><li>它适⽤于计算⽐较消耗性能的计算场景 </li><li>必须要有一个返回值</li></ol><p><strong>watch</strong></p><ol><li><p>它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。</p><p>主要⽤于观察 <code>props</code> 或 本组件data的值，当这些值发生变化时，执⾏处理操作</p></li><li><p>不一定要返回某个值</p></li></ol><p><strong>建议</strong></p><ol><li><p>当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 <code>computed</code></p></li><li><p>当需要在某个数据发生变化的, 同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ <code>watch</code></p></li></ol><h2 id="10-Route和router的区别"><a href="#10-Route和router的区别" class="headerlink" title="10.Route和router的区别"></a>10.Route和router的区别</h2><ol><li><p>route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。</p></li><li><p>Router:是路由实例对象，包括了路由跳转⽅法，钩⼦函数等。</p></li></ol><h2 id="11-vue-router-路由模式有⼏种？"><a href="#11-vue-router-路由模式有⼏种？" class="headerlink" title="11.vue-router 路由模式有⼏种？"></a>11.vue-router 路由模式有⼏种？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract：</p><p>hash: 使⽤ URL hash 值来作路由。⽀持所有浏览器，包括不⽀持 HTML5 History Api 的浏览器；</p><p>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p><p>abstract : ⽀持所有 JavaScript 运⾏环境，如 Node.js 服务器端。如果发现没有浏览器的API，路由会⾃动强制进⼊这个模式.</p><h2 id="12-Object-defineProperty-和-Proxy-的区别"><a href="#12-Object-defineProperty-和-Proxy-的区别" class="headerlink" title="12. Object.defineProperty 和 Proxy 的区别"></a>12. Object.defineProperty 和 Proxy 的区别</h2><p>Object.defineProperty 和 Proxy 的区别如下:</p><ol><li>Proxy 可以直接监听对象而非属性；&#x20;</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等 是 Object.defineProperty 不具备的&#x20;</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准 的性能红利&#x20;</li><li>Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题, 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重 写</li></ol><h2 id="13-vue3-新特性有哪些？"><a href="#13-vue3-新特性有哪些？" class="headerlink" title="13. vue3 新特性有哪些？"></a>13. vue3 新特性有哪些？</h2><p>1、性能提升</p><ul><li>响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快，消除警告。</li><li>重写了 Vdom ，突破了 Vdom 的性能瓶颈。</li><li></li><li>进行模板编译优化。</li><li>更加高效的组件初始化</li></ul><p>2、更好的支持 typeScript</p><ul><li>有更好的类型推断，使得 Vue3 把 typeScript 支持得非常好</li></ul><p>3、新增Composition API</p><ul><li>Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强</li></ul><p>4、新增组件</p><ul><li>Fragment 不再限制 template 只有一个根几点。</li><li>Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。</li><li>Supense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。</li></ul><p>5、Tree-shaking：支持摇树优化</p><ul><li>摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快</li></ul><p>6、Custom Renderer API： 自定义渲染器</p><ul><li>实现 DOM 的方式进行 WebGL 编程</li></ul><h2 id="14-v-show-与-v-if-区别"><a href="#14-v-show-与-v-if-区别" class="headerlink" title="14. v-show 与 v-if 区别"></a>14. v-show 与 v-if 区别</h2><p>v-show和v-if的区别：</p><p>v-show是css切换，v-if是完整的销毁和重新创建。</p><p>使⽤频繁切换时⽤v-show，运⾏时较少改变时⽤v-if</p><h2 id="15-vue中v-if和v-for优先级在vue2和vue3中的区别"><a href="#15-vue中v-if和v-for优先级在vue2和vue3中的区别" class="headerlink" title="15. vue中v-if和v-for优先级在vue2和vue3中的区别"></a>15. vue中v-if和v-for优先级在vue2和vue3中的区别</h2><p>实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。</p><ul><li>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。</li><li>在 vue 3.x 中， v-if 总是优先于 v-for 生效。</li><li>vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。</li><li>vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常</li></ul><h2 id="16-script-setup-是干啥的？"><a href="#16-script-setup-是干啥的？" class="headerlink" title="16. script setup 是干啥的？"></a>16. script setup 是干啥的？</h2><p>scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：</p><ul><li>属性和方法无需返回，可以直接使用。</li><li>引入组件的时候，会自动注册，无需通过 components 手动注册。</li><li>使用 defineProps 接收父组件传递的值。</li><li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。</li><li>默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。</li></ul><h2 id="17-reactive与ref的区别？"><a href="#17-reactive与ref的区别？" class="headerlink" title="17. reactive与ref的区别？"></a>17. reactive与ref的区别？</h2><p>Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。</p><p>ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。</p><p>reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。</p><h2 id="18-v-model的使用？"><a href="#18-v-model的使用？" class="headerlink" title="18. v-model的使用？"></a>18. v-model的使用？</h2><p>v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.</p><p>V-model的原理：</p><ul><li><p>v-bind绑定一个value属性</p></li><li><p>v-on指令给当前元素绑定input事件</p></li></ul><p>可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体</p><p>组件上的双向绑定（原理）</p><p>v-model绑定在组件上的时候做了以下步骤</p><ul><li>在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性</li><li>子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。</li><li>子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值</li><li>v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上</li></ul><h2 id="19-vuex中的辅助函数怎么使用？"><a href="#19-vuex中的辅助函数怎么使用？" class="headerlink" title="19. vuex中的辅助函数怎么使用？"></a>19. vuex中的辅助函数怎么使用？</h2><p>vuex的辅助函数有4个</p><ul><li>mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。</li><li>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他</li><li>mapMutations 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.$store.commit(‘montify’)</li><li>mapActions在组件中使用 this.$store.dispatch(‘prodect’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用</li></ul><h2 id="20-slot是什么？有什么作用？原理是什么？"><a href="#20-slot是什么？有什么作用？原理是什么？" class="headerlink" title="20. slot是什么？有什么作用？原理是什么？"></a>20. slot是什么？有什么作用？原理是什么？</h2><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p><p><strong>slot又分三类，默认插槽，具名插槽和作用域插槽。</strong></p><ul><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p><strong>实现原理：</strong></p><p>当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default具名插槽为vm.$slot.xxx，xxx 为插槽名</p><p>当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽</p><h2 id="21-nextTick的使用"><a href="#21-nextTick的使用" class="headerlink" title="21. $nextTick的使用"></a>21. $nextTick的使用</h2><p>用法：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><p><strong>$nextTick() 的应用场景</strong></p><p>在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 $nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p><p>mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题</p><p>在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 $nextTick() 的回调函数中。</p><h2 id="22-v-for中的key"><a href="#22-v-for中的key" class="headerlink" title="22. v-for中的key"></a>22. v-for中的key</h2><p><strong>语法：</strong> key&#x3D;”唯一值”</p><p><strong>作用：</strong>给列表项添加的<strong>唯一标识</strong>。便于Vue进行列表项的<strong>正确排序复用</strong>。</p><p><strong>为什么加key：</strong>Vue 的默认行为会尝试原地修改元素（<strong>就地复用</strong>）</p><p>实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in booksList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item.author &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;del(item.id)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><strong>key 的值只能是字符串 或 数字类型</strong></li><li><strong>key 的值必须具有唯一性</strong></li><li>推荐使用  id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li></ol><h2 id="23-data必须是一个函数"><a href="#23-data必须是一个函数" class="headerlink" title="23.data必须是一个函数"></a>23.data必须是一个函数</h2><p><strong>1、data为什么要写成函数</strong></p><p>一个组件的 <strong>data</strong> 选项必须<strong>是一个函数</strong>。目的是为了：<strong>保证每个组件实例</strong>，维护<strong>独立</strong>的一份<strong>数据</strong>对象。</p><p>每次创建新的组件实例，都会新<strong>执行一次data 函数</strong>，得到一个新对象。</p><h2 id="24-编程式导航，如何跳转传参？"><a href="#24-编程式导航，如何跳转传参？" class="headerlink" title="24.编程式导航，如何跳转传参？"></a><strong>24.编程式导航，如何跳转传参？</strong></h2><p>1.path路径跳转</p><ul><li><p>query传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/路径?参数名1=参数值1&amp;参数2=参数值2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/路径&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    参数名<span class="number">1</span>: <span class="string">&#x27;参数值1&#x27;</span>,</span><br><span class="line">    参数名<span class="number">2</span>: <span class="string">&#x27;参数值2&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>动态路由传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/路径/参数值&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/路径/参数值&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>2.name命名路由跳转</p><ul><li><p>query传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;路由名字&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    参数名<span class="number">1</span>: <span class="string">&#x27;参数值1&#x27;</span>,</span><br><span class="line">    参数名<span class="number">2</span>: <span class="string">&#x27;参数值2&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>动态路由传参 (需要配动态路由)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;路由名字&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    参数名: <span class="string">&#x27;参数值&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="25-什么是-M-V-VM"><a href="#25-什么是-M-V-VM" class="headerlink" title="25. 什么是 M V  VM"></a>25. 什么是 M V  VM</h2><p><code>Model-View-ViewModel 模式</code></p><img src="web/面试/面试加强/02-笔记/前端面试手册.assets/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" /><p><strong>Model 层</strong>: <code>数据模型层</code></p><p>通过 <code>Ajax</code>、<code>fetch</code> 等 API 完成客户端和服务端业务模型的同步。</p><p><strong>View 层</strong>: <code>视图层</code></p><p>作为视图模板存在，其实View 就是⼀个动态模板。</p><p><strong>ViewModel 层</strong>: <code>视图模型层</code></p><p>负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明, 进行实际的业务逻辑实现。</p><p><strong><code>数据变化了, 视图自动更新</code></strong> &#x3D;&gt; ViewModel 底层会做好监听Object.defineProperty，当数据变化时，View 层会自动更新</p><p><strong><code>视图变化了, 绑定的数据自动更新</code></strong> &#x3D;&gt;  会监听双向绑定的表单元素的变化，⼀旦变化，绑定的数据也会得到⾃动更新。</p><h2 id="26-MVVM的优缺点有哪些？"><a href="#26-MVVM的优缺点有哪些？" class="headerlink" title="26. MVVM的优缺点有哪些？"></a>26. MVVM的优缺点有哪些？</h2><p><strong>优点</strong></p><ol><li><p>实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性</p></li><li><p>提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码 </p></li><li><p>能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来</p></li></ol><p><strong>缺点</strong></p><ol><li><p>Bug 难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，</p><p>也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，</p><p>要定位原始出问题的地⽅就变得不那么容易了</p><p>可采用的<code>调试方案</code>:</p><p>(1) 注释掉一段代码, 确定代码的位置</p><p>(2) debugger 打断点 或者 console 进行调试</p></li><li><p>在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，但如果⻓期持有不释放内存，就会造成更多的内存消耗 </p><p>占用的是 浏览器的 内存</p></li></ol><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="1-分析登录流程"><a href="#1-分析登录流程" class="headerlink" title="1.分析登录流程"></a>1.分析登录流程</h2><blockquote><p>传统思路都是登录校验通过之后，直接调用接口，获取token之后，跳转到主页。</p></blockquote><ul><li>vue-element-admin的登录思路：</li></ul><ol><li>登录表单校验通过</li><li>调用Vuex提供的登录的action</li><li>登录的Action中会调用接口</li><li>登录接口如果成功执行，会返回token</li><li>利用Vuex的特性，将token共享的到Vuex中，这样Vuex就统一管理了token,别的地方想要使用，直接通过Vuex就可以</li><li>登录接口会调用单独封装的请求模块(api)</li><li>请求模块中又会使用用到axios封装的请求工具</li><li>而请求工具又要考虑区分 开发环境和生产环境的问题</li><li>请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域</li></ol><h2 id="2-登录模块业务实现思路"><a href="#2-登录模块业务实现思路" class="headerlink" title="2.登录模块业务实现思路"></a>2.登录模块业务实现思路</h2><ol><li>首先设计并开发出登录页面的静态页面，设置Rules校验函数，对手机号和密码实现校验。基础校验和统一校验。</li><li>使用token 信息作为用户登录的唯一标识，并且存储在LocalStorage中，通过Vuex 统一管理token ，并且实现token 的持久化。</li><li>利用 axios 中设置请求拦截器，在每次请求的请求头中，注入 token 信息，作为登录的标识。</li><li>配合Vue-Router 中的beforeEach 前置导航守卫函数，实现对 token 信息的统一监测，和拦截登录。</li></ol><h2 id="3-主页模块的实现思路"><a href="#3-主页模块的实现思路" class="headerlink" title="3.主页模块的实现思路"></a>3.主页模块的实现思路</h2><ol><li>登录成功后，根据业务的需求，配合suss 实现对样式的二次修改。</li><li>初始化 Vuex 中的 mutations 信息，更新登录后用户的信息收集，封装 action 获取用户资料</li><li>利用 Vuex 中的 getters 属性，完成用户登陆后的视图层渲染</li><li>封装 action ，实现用户退出登录，调用 commit 方法，清除 Vuex 中保存的 token 信息</li><li>根据后端检测 token 返回的状态码，设置拦截器，对失效 token 信息实现拦截登录，并提示用户token失效</li></ol><h2 id="4-登录流程"><a href="#4-登录流程" class="headerlink" title="4.登录流程"></a>4.登录流程</h2><ol><li><p>拉取 vue-admin-template 代码，进行一些改造。</p></li><li><p>设计并且开发登录页面，进行表单校验，基础校验 + 统一校验</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 基础校验</span></span><br><span class="line"><span class="comment">el-form  :model=&quot;表单对象&quot;  :rules=&quot;规则对象&quot;</span></span><br><span class="line"><span class="comment">el-form-item  prop属性指定一下要使用哪条规则</span></span><br><span class="line"><span class="comment">el-input v-model双向绑定</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">统一校验</span></span><br><span class="line"><span class="comment">1. 获取表单的实例对象</span></span><br><span class="line"><span class="comment">2. 调用validate方法    const res = await this.$refs.loginForm.validate() </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Vuex 中实现用户的模块</p><ol><li><p>删除模板中原有的内容进行重写  </p></li><li><p>开启命名空间，导出 vuex 子模块</p></li><li><p>实现 token 的vue数据持久化   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 存<span class="title class_">Token</span>数据时，一份存入vuex，一份存入cookie</span><br><span class="line"><span class="number">2.</span> vuex中初始化<span class="title class_">Token</span>时，优先从本地cookie取，取不到再初始化为空串儿</span><br></pre></td></tr></table></figure></li><li><p>实现登录的actions方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">form</span>.<span class="title function_">validate</span>(<span class="function">(<span class="params">isOK</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOK) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;user/login&quot;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Vue-cli 代理解决跨域：配置文件可以直接配置代理 vue.config.js  -&gt; devServer  -&gt;  proxy -&gt; api</p></li><li><p>axios 二次封装，将 <code>axios </code>请求方法，封装到 request 模块</p><ol><li><p>配置基础地址  ，超出时间</p></li><li><p>请求拦截器 - 根据获取仓库中的token 来判断  然后 在header 中统一注入 token</p></li><li><p>响应拦截器 - 解构数据  -  处理异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用配置</span></span><br><span class="line"><span class="comment">// 1. axios实例化  axios.create() 基地址配置 baseURL + 超时时间 timeout（100ms）</span></span><br><span class="line"><span class="comment">// 拓展：create方法可以调用多次 每次执行都会生成一个独一无二的实例</span></span><br><span class="line"><span class="comment">// export default const a = asiox.create(&#123; baseURL: &#x27;a.com&#x27; &#125;)</span></span><br><span class="line"><span class="comment">// export default const b = asiox.create(&#123; baseURL: &#x27;b.com&#x27; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求拦截器  请求头中添加token数据  接口鉴权  统一配置</span></span><br><span class="line"><span class="comment">// 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端</span></span><br><span class="line"><span class="comment">// 拓展：可以添加多个请求拦截器</span></span><br><span class="line"><span class="comment">// 客户端请求 - 拦截器1(处理参数) - 拦截器2 - 后端 </span></span><br><span class="line"><span class="comment">// 最后一定要return  config  失败就执行promise.reject(error)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 响应拦截器 数据剥离 res.data / token失效401错误处理 / 前端自定义错误处理？ </span></span><br><span class="line"><span class="comment">// 后端 - 响应拦截器 - 客户端</span></span><br><span class="line"><span class="comment">// 成功回调 200-300</span></span><br><span class="line"><span class="comment">// 失败回调 不在这个之间</span></span><br><span class="line"><span class="comment">// axios默认包裹了一层data 把响应数据解构出来  判断如果业务成功 返回用户所需要的数据   业务失效 错误提示  return 一个error  （new一个）</span></span><br><span class="line"><span class="comment">// // 所有的响应错误信息，统一处理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>封装 api 接口</p><p><strong>将请求封装成方法，统一存放到 api 模块，与页面分离,可维护性高</strong></p><p>新建 <code>api/user.js</code> 提供注册 Api 函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">register</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> request.<span class="title function_">post</span>(<span class="string">&#x27;/user/register&#x27;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>区分环境（表单）</p><ol><li>开发环境  developent</li><li>生产环境   production</li></ol></li><li><p>登录联调</p><ol><li>封装登录的api</li><li>vuex 中的用户模块调用登录接口</li><li>登录成功后，跳转到主页</li><li>区分表单不同环境下的不同数据</li></ol></li><li><p>主页鉴权验证</p><ol><li>访问主页-有token放过，没有token跳到登录页</li><li>访问登录-有token跳到主页，没有token放过</li><li>前置守卫 - beforeEach 中 来处理逻辑  白名单</li></ol></li></ol><h2 id="5-智慧园区"><a href="#5-智慧园区" class="headerlink" title="5.智慧园区"></a>5.智慧园区</h2><h3 id="1-搜索功能"><a href="#1-搜索功能" class="headerlink" title="1.搜索功能"></a>1.搜索功能</h3><p>  思路分析：把各种搜索条件当作请求参数发给后端 后端会根据字段对数据库数据做过滤筛选拿到符合条件返回</p><pre><code>        1. 表单组件的双向绑定收集到当前的请求数据        2. 把收集到的表单参数发送接口给后端那符合条件的数据        3. 把拿到的数据关系显示在列表中</code></pre><h3 id="2-excel导出"><a href="#2-excel导出" class="headerlink" title="2.excel导出"></a>2.excel导出</h3><ol><li><p>实际开发过程中的导出</p><ol><li><p>前端主导（xlsx）</p><p>流程：调用列表接口把要导出的数据拿到 -&gt; 数据的二次转化  -&gt;  [excel 工作簿 - 工作表 - 单元格数据] - 使用xlsx创建一个工作簿 - 使用xlsx方法创建一个工作表 - 把工作表添加到工作簿 – [使用中文替换中文表头] 调用xlsx的导出方法</p><p>工作中遇到了需求，参考代码 换接口 数据二次处理 处理表头</p></li><li><p>后端主导（最常见）</p><p>流程：前端直接调用导出接口 - 后端会把数据转换成excel文件流当成返回值返回 - 直接触发浏览器的下载功能</p></li></ol></li><li><p>两种方案的本质区别：</p><p>把数据转化成excel的过程发生在哪里？如果发生在浏览器 前端主导 如果发生在后端服务器 后端主导</p><p>前端主导 - 处理数据量不能太大</p><p>后端主导 - 适合处理量大或量小都可</p></li></ol><h3 id="3-网络请求的优化"><a href="#3-网络请求的优化" class="headerlink" title="3.网络请求的优化"></a>3.网络请求的优化</h3><ol><li>场景: 限制了请求个数 保证只有打开时才请求</li><li>怎么做到？<ol><li>判断第一个参数row是否能在第二个参数rows中找到 如果能找到代表打开了</li><li>find 通过匹配找到符合条件的第一项 然后把找到的项返回</li><li>findIndex 通过匹配找到符合条件的第一项 然后把找到项的下标值返回 splice(index,1)</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有展开时获取数据并绑定</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">expandHandle</span>(<span class="params">row, rows</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;展开或关闭&#x27;, row, rows) 点击行row.id  rows数组对象</span></span><br><span class="line">  <span class="comment">// row: 当前行的对象  rows数组对象</span></span><br><span class="line">  <span class="comment">// 1. 先拿到当前行的数据</span></span><br><span class="line">  <span class="comment">// 2. 使用当前行的企业数据，获取下面的合同列表数据</span></span><br><span class="line">  <span class="comment">// 3. 把拿到的合同列表存入企业对象中 但是row里面没有存放的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化网络请求 只在打开时才去触发 核心：拿到当前是打开的条件 做判断</span></span><br><span class="line">    <span class="comment">// 判断条件：第一个row是否能在第二个rows中找到 如果找到了 代表打开了 如果找不到 代表收起了</span></span><br><span class="line">    <span class="comment">// find findIndex</span></span><br><span class="line">  <span class="keyword">const</span> isExpend = rows.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === row.<span class="property">id</span>)</span><br><span class="line">  <span class="keyword">if</span> (isExpend) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了这一项，才回去调用接口</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getRentListAPI</span>(row.<span class="property">id</span>)</span><br><span class="line">    <span class="comment">// eslint-disable-next-line require-atomic-updates</span></span><br><span class="line">    row.<span class="property">rentList</span> = res.<span class="property">data</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-后端返回数据字段不够前端自定义字段"><a href="#4-后端返回数据字段不够前端自定义字段" class="headerlink" title="4.后端返回数据字段不够前端自定义字段"></a>4.后端返回数据字段不够前端自定义字段</h3><p>  默认的返回的企业列表数据中没有一个存放合同列表的数据的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">list</span> = res.<span class="property">data</span>.<span class="property">rows</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">rendList</span>: []  <span class="comment">// 通过映射自定义添加字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-树状组件怎么实现的？"><a href="#5-树状组件怎么实现的？" class="headerlink" title="5.树状组件怎么实现的？"></a>5.树状组件怎么实现的？</h3><p>树形组件：用层级结构展示信息，可展开或折叠。</p><ol><li><p>element-ui提供了树组件<a href="https://element.eleme.cn/#/zh-CN/component/tree">el-tree</a>的应用</p></li><li><p>组件中放置树形组件</p></li><li><p>获取后台的数据</p></li><li><p>递归转化树形结构</p><ol><li>首先分析数据的关联关系</li><li>封装递归函数根据关联关系转化层级结构</li><li>通过分析了解到，父级的id为子级的pid</li><li>封装公共方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 列表型数据转化树形</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">transListToTreeData</span>(<span class="params">list, rootValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">pid</span> === rootValue) &#123;</span><br><span class="line">      <span class="comment">// 找到了匹配的节点</span></span><br><span class="line">      <span class="comment">// 当前节点的id 和 当前节点的子节点的pid是想等的</span></span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">transListToTreeData</span>(list, item.<span class="property">id</span>) <span class="comment">// 找到的节点的子节点</span></span><br><span class="line">      item.<span class="property">children</span> = children  <span class="comment">// 将子节点赋值给当前节点</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将列表型的数据转化成树形数据 =&gt; 递归算法 =&gt; 自身调用自身 =&gt; 一定条件不能一样， 否则就会死循环</span></span><br><span class="line"><span class="comment">//  *  遍历树形 有一个重点 要先找一个头儿</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="6-记住我优化"><a href="#6-记住我优化" class="headerlink" title="6.记住我优化"></a>6.记住我优化</h3><ol><li>基础实现逻辑<br>如果当前用户选中了记住，在登录时把用户的信息存入本地 在组件初始化的时候去取数据 回填<br>  如果当前没有选中，在登录时把数据清空</li></ol><h3 id="7-数据基础渲染"><a href="#7-数据基础渲染" class="headerlink" title="7.数据基础渲染"></a>7.数据基础渲染</h3><ol><li>基础实现逻辑<ol><li>准备静态模版（elementUI）</li><li>解决初始报错 在data中把模版绑定的数据都声明一遍</li><li>封装接口（url&#x2F; method &#x2F; 参数[名称 + 类型 + 参数数量]）</li><li>组件中封装一个独立的方法 在方法中调用接口函数 （复用的好处 调用之前做一些额外的参数处理）</li><li>选择一个合适生命周期钩子函数调用独立的方法 （created &#x2F; mounted 都可以）</li><li>使用数据渲染模版 （数据驱动视图）</li></ol></li></ol><h3 id="8-列表基础渲染"><a href="#8-列表基础渲染" class="headerlink" title="8.列表基础渲染"></a>8.列表基础渲染</h3><ol><li><p>实现步骤</p><ol><li>按照接口文档请求列表接口封装一下（url&#x2F;method&#x2F;参数）</li><li>data准备响应式的数据（以后端接口实际返回为主）</li><li>在methods封装一个方法（参数的二次处理 + 调用接口 + 数据赋值）</li><li>生命周期钩子函数调用这个方法（created &#x2F; mounted）</li><li>把响应式数据绑定组件身上（文档组件要求通过什么属性绑定就通过生命属性）</li></ol></li><li><p>分页功能</p><ol><li><p>分页的逻辑<br>页数 &#x3D; 总条数 &#x2F; 单页的条数</p></li><li><p>组件分好页<br>传入总数  :total&#x3D;”100”<br>单页条数  :pageSize&#x3D;”2” 默认10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">   1. 页数分出来 （页数 = 总条数 / 每页条数）</span><br><span class="line">   2. 点击每页的时候获取当前页的数据重新渲染到table上</span><br><span class="line">--&gt;</span><br><span class="line">&lt;el-pagination</span><br><span class="line">  layout=&quot;total, prev, pager, next&quot;</span><br><span class="line">  :page-size=&quot;params.pageSize&quot;</span><br><span class="line">  :total=&quot;total&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击分页交互的实现</p><ol><li><p>点击时拿到当前点击的页数（父组件从子组件获取内部的数据 子传父）<br>@current-change&#x3D;”pageChange”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pageChange</span>(<span class="params">page</span>) &#123; </span><br><span class="line">   <span class="comment">// console.log(page) // 回调参数 拿到的是当前页</span></span><br><span class="line">   <span class="comment">// 把点击的页数赋值给请求参数页数  </span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line">   <span class="comment">// 使用最新的请求参数获取列表数据</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getCardList</span>()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用当前的页数去后端要当前页的数据重新渲染到table</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="9-状态适配"><a href="#9-状态适配" class="headerlink" title="9.状态适配"></a>9.状态适配</h3><ol><li><p>场景<br>后端返回的数据无法直接显示到页面中 0&#x2F;1 男女</p></li><li><p>转化的状态码数量只有两个<br>解决方案：三元表达式  status &#x3D;&#x3D;&#x3D; 0? ‘女’ ：’男’</p><p>转化的状态码比较多<br>解决方案：映射的方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">status</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAP</span> = &#123;</span><br><span class="line">   <span class="number">0</span>:<span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">   <span class="number">1</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">MAP</span>[status]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong>带有模板的状态格式化</strong></p><ol><li><p>直接可以把后端的数据渲染出来 prop指定要渲染的字段</p></li><li><p>不能直接渲染  需要格式化  格式化出来的内容一九是一个文本  string</p><ol><li>：formatter&#x3D;”formatStatus” 不需要手动传参 自动传入</li><li>插槽 + 插值表达式  [渲染出来的是函数的返回值]</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">default</span>=<span class="string">&quot;&#123;row&#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; formatStatus(row.status) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="10-上传图片"><a href="#10-上传图片" class="headerlink" title="10.上传图片"></a>10.上传图片</h3><ol><li><p>上传的流程<br>点击上传按钮 -&gt; el-upload [打开本地文件选择框 + 上传前的文件校验] -&gt; File -&gt;<br>new FormData()[接口要求传递一个formdata类型的数据] -&gt; 往formData的对象中append字段<br>-&gt; append(‘file’,file) append(‘type’,’business…’) -&gt; 使用完整的formData对象提交接口完成    上传</p></li><li><p>细节问题</p><ol><li>el-upload<ol><li>非常简单  不需要做任何的自定义配置 默认的配置项完成上传就行了</li><li>需要自定义场景  :http-request&#x3D;’function’</li><li>如果添加了上传前的校验 流程：先执行上传前的校验函数 函数返回值为true 再执行upload上传函数</li><li>函数参数 ：上传前的函数 file对象 [size &#x2F; type做校验] 上传函数  res对象 { file：File }</li></ol></li><li>上传接口接口参数<ol><li>常规的接口  contentType  application&#x2F;json</li><li>上传接口    contentType  application&#x2F;form-data</li></ol></li><li>前后端校验逻辑要保持一致<br>文件大小  小于5m  &#x2F; 文件类型 jpeg  前端要以这个为主<br>[因为接口不只是可以通过浏览器提交 也可以通过其他方式提交 基于界面操作类校验会失败]</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> :http-request=&quot;uploadRequest&quot; 自定义上传</span><br><span class="line">  action 本来是一个用来配置默认上传的接口地址</span><br><span class="line">  因为我们覆盖了  所以用一个 # 占个位置 消除必填警告</span><br><span class="line">  input type=&quot;file&quot; 本身具备选择文件的能力</span><br><span class="line">  覆盖原因：默认的配置上传不够灵活 仅支持一些简单的上传 </span><br><span class="line"></span><br><span class="line">  如果想要完全自定义上传 http-request</span><br><span class="line">  在选择文件之后 自动执行upload函数 并且把一个对象传给我们</span><br><span class="line">  对象中有一个file属性 就是我们要上传的对象</span><br><span class="line">      </span><br><span class="line">  上传前校验：</span><br><span class="line">    1. 上传图片之前加一层校验 目的为了限制用户上传的文件类型和大小</span><br><span class="line">    2. 如果我们添加了beforeUpload这个属性方法 这个函数中必须return的数据为true</span><br><span class="line">       才会继续执行 upload 方法 如果校验不通过 暂停执行 不会走上传逻辑</span><br><span class="line">    3. file对象中两个属性</span><br><span class="line">       size: 文件大小 / 1024/1024 = M</span><br><span class="line">       type: 文件类型  image/文件类型</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=&quot;营业执照&quot;&gt;</span><br><span class="line">    &lt;el-upload</span><br><span class="line">      action=&quot;#&quot;</span><br><span class="line">      :http-request=&quot;uploadRequest&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">      &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">    &lt;/el-upload&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- </span><br><span class="line">    上传实现流程：</span><br><span class="line">      1. el-upload 打开本地文件  并且校验这个文件是否符合要求 - File</span><br><span class="line">      2. :http-request = &#x27;upload&#x27;</span><br><span class="line">      3. 按照接口的要求格式 得到类型为FormData对象 new FormData()</span><br><span class="line">      4. 按照要求往 formData中添加字段数据 fd.append(&#x27;字段名&#x27;,&#x27;字段值&#x27;)</span><br><span class="line">      5. 调用上传接口</span><br><span class="line">      6. 拿到返回的文件地址和其有用的信息id 存入data中的响应式数据的位置 将来提交表单</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure><h3 id="11-菜单路由控制权限"><a href="#11-菜单路由控制权限" class="headerlink" title="11.菜单路由控制权限"></a>11.菜单路由控制权限</h3><ol><li>权限数据的生成（RBAC）<ol><li>新增一个角色 给角色配置权限数据</li><li>新增一个员工 给员工分配这个角色 员工就有了当前角色下所有的权限数据</li></ol></li><li>完整的实现流程<ol><li><p>调用接口获取当前员工的权限数据  permission [‘park:building:add_edit’]</p><ol><li>在Vuex中编写逻辑，user&#x2F;state里存放个人用户信息 </li><li>action里调用时，把permissions目标数据return出去 给另一个js模块使用</li><li>permission文件中触发action，获取用户信息（有token时）</li></ol></li><li><p>对权限数据做格式化处理 产生两个权限数据  一级路由权限数组 + 二级路由权限数组</p></li><li><p>把路由表拆分成两部分 动态路由表[需要加权限控制] + 静态路由表[不需要加权限控制]</p><ol><li>拆分动态路由表导出使用 asyncRoutes</li><li>初始化时候只处理静态路由表  routes: […routes]</li></ol></li><li><p>以一级和二级权限数组作为对主动态路由表做过滤筛选处理 -&gt; 有资格加入到路由系统中的动态路由表</p><ol><li>使用一级权限点过滤一级路由 使用二级权限点过滤二级路由 最终得到显示左侧的路由表</li><li>调用函数获取最终的动态路由</li></ol></li><li><p>调用router的addRoute方法把动态路由表依次添加到路由系统中 访问url可以渲染对应的组件</p></li><li><p>使用动态路由表数据通过存入Vuex然后利用它响应式的特性 渲染到左侧菜单中</p><ol><li>vuex新增一个模块，menu模块，先以静态的路由表作为初始值</li><li>在得到过滤之后的动态路由表之后，和之前的静态做一个结合</li><li>在sidebar组件中结合v-for指令做使用Vuex中的数据做渲染</li></ol></li><li><p>解决切换用户有缓存的bug 方案：在用户退出登录时</p><ol><li><p>调用清空路由的reset方法</p></li><li><p>手动把Vuex中的数据也清空</p></li><li><p>用户信息也清空</p></li></ol></li></ol></li><li>每一个独立的小功能封装成一个独立的小函数 维护方便</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">profile</span>.<span class="property">id</span>) &#123;</span><br><span class="line">       <span class="comment">// 1. 调用action函数获取用户权限数据</span></span><br><span class="line">       <span class="keyword">const</span> permissions = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getProfile&#x27;</span>)</span><br><span class="line">       <span class="comment">// 2. 把后端的权限数组格式化成我们自己的俩个权限数据</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前的权限数据为:&#x27;</span>, permissions)</span><br><span class="line">       <span class="keyword">const</span> firstRoutePerms = <span class="title function_">getFirstRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一级路由权限&#x27;</span>, firstRoutePerms)</span><br><span class="line">       <span class="keyword">const</span> secondRoutePerms = <span class="title function_">getSecondRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;二级路由权限&#x27;</span>, secondRoutePerms)</span><br><span class="line">       <span class="comment">// 3. 根据权限标识过滤路由表 最终得到显示到左侧的路由表</span></span><br><span class="line">       <span class="keyword">const</span> routes = <span class="title function_">getRoutes</span>(firstRoutePerms, secondRoutePerms, asyncRoutes)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最终路由表&#x27;</span>, routes)</span><br><span class="line">       <span class="comment">// 4. addRoute动态添加 (当浏览器中访问路由的路径 显示渲染出来对应的组件)</span></span><br><span class="line">       routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> router.<span class="title function_">addRoute</span>(route))</span><br><span class="line">       <span class="comment">// 5. 存入Vuex渲染左侧菜单</span></span><br><span class="line">       store.<span class="title function_">commit</span>(<span class="string">&#x27;menu/setMenuList&#x27;</span>, routes)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="12-按钮控制权限"><a href="#12-按钮控制权限" class="headerlink" title="12.按钮控制权限"></a>12.按钮控制权限</h3><blockquote><p>概念：根据当前用户的权限数据控制按钮的显示和隐藏</p></blockquote><p>思路：每一个需要做权限控制的按钮都有一个自己独有的 <code>标识</code> , 如果标识可以在权限数据列表中找到，则显示，找不到就隐藏<br>方案：应用中可能会有很多按钮需要做权限控制，所以方案一定是全局生效的，我们提供俩种可选的方案</p><p>全局指令方案  和  高阶组件  方案。</p><h3 id="13-微前端"><a href="#13-微前端" class="headerlink" title="13.微前端"></a>13.微前端</h3><p>微前端是一种前端架构模式，它将大型单体应用程序分解为小的、松散耦合的部分，每个部分都可以独立开发、测试和部署。</p><p>使用乾坤方案进行改造.</p><p><strong>1. 基础运行原理</strong></p><ol><li><p>监听路由变化  实现一个注册子应用配置的方法</p></li><li><p>匹配子应用  实现路由的匹配</p></li><li><p>加载子应用  实现加载子应用</p></li><li><p>渲染子应用  实现子应用的渲染</p></li><li><p><strong>前端加载3D模型</strong></p><ol><li>下载模型解析包</li><li>拉取模型并渲染</li><li>添加进入条</li></ol></li><li><p><strong>大屏适配</strong></p><ol><li>安装组件  npm i v-scale-screen</li><li>使用组件并制定高度</li></ol></li></ol><h2 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h2><ol><li><p>Vue 中使用样式无法生效  deep</p></li><li><p>解决history页面404访问问题</p><ol><li>当我们刷新页面，发现404</li></ol><blockquote><p>  这是因为我们采用了history的模式，地址的变化会引起服务器的刷新，我们只需要在app.js对所有的地址进行一下处理即可</p></blockquote></li><li><p>在 Vue 中使用 axios 下载 excel 文档，出现乱码</p><p>4．使用 webpack 打包项目，导致图片无法显示 ： 文件路径错误      配置问题：Webpack配置文件中是否有正确的loader配置来处理图片文件。</p></li></ol><h3 id="1-refresh-token"><a href="#1-refresh-token" class="headerlink" title="1.refresh_token"></a>1.refresh_token</h3><p>在调用登录接口成功后会返回 <code>token</code> 和 <code>refreshToken</code> 当 <code>token</code> 有效时间设置了 8 个小时，<code>refreshToken</code> 有效时间设置了 3 天，当 <code>token</code> 失效后 <code>refreshToken</code> 仍然有效，此时可以通过 <code>refreshToken</code> 来为 <code>token</code> 续期，所谓的续期就是调用后端提供的一个接口，然后把 <code>refreshToken</code> 发送给服务端，服务端重新返回新的 <code>token</code> 和 <code>refreshToken</code>。</p><ol><li><p>判断当前的 <code>token</code> 有没有失效可以根据接口返回的状态码进行判断，当 <code>token</code> 失效后会返回 <code>401</code>，在响应拦截器中可以统一获取所有接口返回的状态码，然后对其进行判断</p></li><li><p>要想通过应用实例 getApp 来读取 <code>refreshToken</code> 必须提前读取本地存储的数据并存储到应用实例当中</p></li><li><p>调用接口把 <code>refreshToken</code> 发送给服务端换取新的 <code>token</code> 和 <code>refreshToken</code></p><p>接口中所需要的接口 <code>refreshToken</code> 需要通过自定义的头信息 <code>Authorization</code> 来传递</p></li></ol><h3 id="2-实现vant组件自动按需加载，和自动导入"><a href="#2-实现vant组件自动按需加载，和自动导入" class="headerlink" title="2.实现vant组件自动按需加载，和自动导入"></a>2.实现vant组件自动按需加载，和自动导入</h3><ol><li>安装 yarn add unplugin-vue-components -D</li><li>配置 plugins 里的 Components</li></ol><h3 id="3-vueuse-core"><a href="#3-vueuse-core" class="headerlink" title="3.@vueuse&#x2F;core"></a>3.@vueuse&#x2F;core</h3><p>介绍 @vueuse&#x2F;core 组合api库，使用 useXxx 函数获取设备宽度，动态设置滚动距离</p><p>@vueuse&#x2F;core 介绍：<a href="https://vueuse.org/functions.html">文档</a></p><ul><li>是一个基于 组合API 封装的库</li><li>提供了一些网站开发常用的工具函数，且得到的是响应式数据</li></ul><p>需求：</p><ul><li>在 375 宽度设备，滚动宽度为 150</li><li>在其他设备需要等比例设置滚动的宽度</li><li>scrollWidth &#x3D; 150 &#x2F; 375 * deviceWidth 就可以适配</li></ul><p>@vueuse&#x2F;core 应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @vueuse/core</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useWindowSize &#125; from &#x27;@vueuse/core&#x27;</span><br><span class="line"></span><br><span class="line">const &#123; width &#125; = useWindowSize()</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>如果遇见一些常见的需求可以先看看 @vueuse&#x2F;core 是否提供，这样可以提高开发效率。<ul><li>如果：窗口尺寸，滚动距离，是否进入可视区，倒计时，…等等。</li></ul></li></ul><h3 id="4-极速问诊"><a href="#4-极速问诊" class="headerlink" title="4.极速问诊"></a>4.极速问诊</h3><p><img src="https://bu.dusays.com/2023/10/29/653d31d9160d7.png" alt="image-20231028232009299.png"></p><h3 id="5-问诊室-websocket介绍"><a href="#5-问诊室-websocket介绍" class="headerlink" title="5.问诊室-websocket介绍"></a>5.问诊室-websocket介绍</h3><p>什么是 websocket ? <a href="https://websocket.org/">https://websocket.org/</a></p><ul><li>是一种网络通信协议，和 HTTP 协议 一样。</li></ul><p>为什么需要websocket ?</p><ul><li>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</li></ul><p>我们项目中使用 socket.io-client 来实现客户端代码，它是基于 websocket 的库。</p><p><strong>问诊室-socket.io使用</strong></p><blockquote><p>目的：掌握 <a href="http://socket.io/">socket.io</a> 的基本使用</p></blockquote><ol><li><a href="http://socket.io/">socket.io</a> 什么？<ul><li><a href="http://socket.io/">socket.io</a> 是一个基于 WebSocket 的 CS（客户端-服务端）的实时通信库</li><li>使用它可以在后端提供一个即时通讯服务</li><li>它也提供一个 js 库，在前端可以去链接后端的 <a href="http://socket.io/">socket.io</a> 创建的服务</li><li>总结：它是一套基于 websocket 前后端即时通讯解决方案</li></ul></li><li><a href="http://socket.io/">socket.io</a> 如何使用？<ul><li>大家可以体验下这个 <a href="https://socket.io/get-started/chat#getting-this-example">官方Demo</a></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add socket.io-client</span><br></pre></td></tr></table></figure><p>如何建立连接？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import io from &#x27;socket.io-client&#x27;</span><br><span class="line">// 参数1：不传默认是当前服务域名，开发中传入服务器地址</span><br><span class="line">// 参数2：配置参数，根据需要再来介绍</span><br><span class="line">const socket = io()</span><br></pre></td></tr></table></figure><p>如何确定连接成功？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&#x27;connect&#x27;, () =&gt; &#123;</span><br><span class="line">  // 建立连接成功</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如何发送消息？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// chat message 发送消息事件，由后台约定，可变</span><br><span class="line">socket.emit(&#x27;chat message&#x27;, &#x27;消息内容&#x27;)</span><br></pre></td></tr></table></figure><p>如何接收消息？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// chat message 接收消息事件，由后台约定，可变</span><br><span class="line">socket.on(&#x27;chat message&#x27;, (ev) =&gt; &#123;</span><br><span class="line">  // ev 是服务器发送的消息</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如何关闭连接？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 离开组件需要使用</span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li><p>sockt.io</p><p>在前端使用的js库需要知道哪些内容？</p><ul><li>如何建立链接 <code>io(&#39;地址&#39;)</code></li><li>连接成功的事件 <code>connect</code></li><li>如何发消息 <code>emit</code> + 事件</li><li>如何收消息 <code>on</code> + 事件</li><li>如果关闭连接 <code>close()</code></li></ul></li></ul><h3 id="6-Vue-项目权限处理"><a href="#6-Vue-项目权限处理" class="headerlink" title="6. Vue 项目权限处理"></a>6. Vue 项目权限处理</h3><p>现在权限相关管理系统用的框架都是element提供的<a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>模板框架比较常见。</p><p>权限控制常见分为三大块</p><ul><li><strong>菜单权限控制</strong></li><li><strong>按钮权限控制</strong></li><li>请求url权限控制。</li></ul><p><strong>权限管理在后端中主要体现在对接口访问权限的控制，在前端中主要体现在对菜单访问权限的控制。</strong></p><ol><li><p>按钮权限控制比较容易，主要采取的方式是从后端返回按钮的权限标识，然后在前端进行显隐操作 v-if &#x2F; disabled。</p></li><li><p>url权限控制，主要是后端代码来控制，前端只需要规范好格式即可。</p></li><li><p>剩下的菜单权限控制，是相对复杂一些的</p><p>(1) <strong>需要在路由设计时, 就拆分成静态路由和动态路由</strong></p><p>​       静态路由: 所有用户都能访问到的路由, 不会动态变化的 (登录页, 首页, 404, …)</p><p>​   动态路由: 动态控制的路由, 只有用户有这个权限, 才将这个路由添加给你 (审批页, 社保页, 权限管理页…)</p><p>(2) 用户登录进入首页时, 需要立刻发送请求, 获取个人信息 (包含权限的标识)</p><p><img src="/web/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA/02-%E7%AC%94%E8%AE%B0/images/image-20210309031043592.png" alt="image-20210309031043592"></p><p>(3) <strong>利用权限信息的标识, 筛选出合适的动态路由</strong>, 通过路由的 <strong>addRoutes 方法</strong>, 动态添加路由即可!</p><p>(4) router.options.routes (拿的是默认配置的项, 拿不到动态新增的) 不是响应式的! </p><p>​  为了能正确的显示菜单, 为了能够将来正确的获取到用户路由, 我们需要用<strong>vuex管理routes路由数组</strong></p><p>(5) 利用vuex中的 routes, 动态渲染菜单</p></li></ol><h3 id="7-如何处理-打包出来的项目-首屏-加载过慢的问题"><a href="#7-如何处理-打包出来的项目-首屏-加载过慢的问题" class="headerlink" title="7. 如何处理 打包出来的项目(首屏)加载过慢的问题"></a>7. 如何处理 打包出来的项目(首屏)加载过慢的问题</h3><p>SPA应用: 单页应用程序, 所有的功能, 都在一个页面中, 如果第一次将所有的路由资源, 组件都加载了, 就会很慢!</p><p>加载过慢 &#x3D;&gt; 一次性加载了过多的资源,  一次性加载了过大的资源</p><ul><li>加载过多 &#x3D;&gt; 路由懒加载, 访问到路由, 再加载该路由相关的组件内容</li><li>加载过大 &#x3D;&gt; 图片压缩, 文件压缩合并处理, 开启gzip压缩等</li></ul><p>比如:</p><ol><li><p>配置异步组件, 路由懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;../pages/login.vue&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>图片压缩: 使用 webp 格式的图片, 提升首页加载的速度</p></li><li><p>CDN加速: 配置CDN加速, 加快资源的加载效率 (花钱)</p></li><li><p>开启 gzip 压缩 (一般默认服务器开启的, 如果没开, 确实可能会很慢, 可以让后台开一下)</p></li></ol><h3 id="8-你在项目中遇到过什么技术难题"><a href="#8-你在项目中遇到过什么技术难题" class="headerlink" title="8. 你在项目中遇到过什么技术难题"></a>8. 你在项目中遇到过什么技术难题</h3><p><strong>问题: 考察解决问题的能力!</strong></p><p>话术: 前端要学的东西确实很多，但是并不夸张, 肯多花点时间沉淀一般都会有解决方案</p><p>一般遇到难题 (这些前端所谓的难题, 一般都是一些没有做过, 没有尝试过得一些业务),  我们要时刻保持独立思考，</p><p><strong>知道自己要做什么业务</strong>，<strong>由此决定要学什么知识</strong>, 然后<strong>实现业务</strong>, 举一反三，总结归纳!</p><p>比如1: 如果之前没有做过国际化, 换肤, 没有做过支付, 权限控制,  没有做过即时通信websocket,  excel导入导出, 就会觉得很难, </p><p>但其实真正上手花时间去学着做了, 也都能逐步思考解决相关页面, 这些其实也都还 ok</p><p>比如2: 有时候, <code>复杂的或者困难的</code>, 并不是技术层面的, 而是<code>业务需求方面</code>的, 需要进行大量树形结构的处理</p><p>展示列表式数据时,  展示图表数据时,  筛选条件关联条件多了,  组件与组件的联动关系的控制也比较麻烦, </p><p>将联动的条件, 存vuex,  然后 &#x3D;&gt; 进行分模块管理也是比较合适的选择 </p><h1 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h1><h2 id="1-nav-bar-组件结构"><a href="#1-nav-bar-组件结构" class="headerlink" title="1.nav-bar 组件结构"></a>1.nav-bar 组件结构</h2><blockquote><p>掌握：van-nav-bar组件的基础使用，抽取到 cp-nav-bar 组件，作为通用组件</p></blockquote><h2 id="2-radio-btn-组件封装"><a href="#2-radio-btn-组件封装" class="headerlink" title="2.radio-btn 组件封装"></a>2.radio-btn 组件封装</h2><blockquote><p>实现：按钮组单选框组件</p></blockquote><h2 id="3-支付抽屉组件封装"><a href="#3-支付抽屉组件封装" class="headerlink" title="3.支付抽屉组件封装"></a>3.支付抽屉组件封装</h2><ul><li>组件需要实现哪些功能？<ul><li>展示微信支付和支付宝支付，可以选择</li><li>展示支付金额，传入订单ID用于生成订单支付链接</li><li>打开关闭抽屉</li><li>关闭后的业务可自定义</li></ul></li><li>需要暴露哪些 props 参数？<ul><li>orderId actualPayment onClose show</li></ul></li><li>需要提供哪些 emits 事件？<ul><li>update:show</li></ul></li></ul><h2 id="4-将树形的操作内容单独抽提成组件"><a href="#4-将树形的操作内容单独抽提成组件" class="headerlink" title="4.将树形的操作内容单独抽提成组件"></a>4.将树形的操作内容单独抽提成组件</h2><p>**<code>目标</code>**： 将树形的操作内容单独抽提成组件</p><p>封装单独的树操作栏组件</p><blockquote><p>通过第一个章节，我们发现，树形的顶级内容实际和子节点的内容是一致的，此时可以将该部分抽提成一个组件，节省代码</p></blockquote><h2 id="5-封装一个通用的工具栏"><a href="#5-封装一个通用的工具栏" class="headerlink" title="5.封装一个通用的工具栏"></a>5.封装一个通用的工具栏</h2><p>**<code>目标</code>**：封装一个通用的工具栏供大家使用</p><h2 id="6-新增员工的弹层组件"><a href="#6-新增员工的弹层组件" class="headerlink" title="6.新增员工的弹层组件"></a>6.新增员工的弹层组件</h2><h2 id="7-个人详情组件和岗位详情组件封装"><a href="#7-个人详情组件和岗位详情组件封装" class="headerlink" title="7.个人详情组件和岗位详情组件封装"></a>7.个人详情组件和岗位详情组件封装</h2><h2 id="8-封装上传图片组件"><a href="#8-封装上传图片组件" class="headerlink" title="8.封装上传图片组件"></a>8.封装上传图片组件</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智慧园区后台</title>
      <link href="/posts/883eae6.html"/>
      <url>/posts/883eae6.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h1 id="vue-admin"><a href="#vue-admin" class="headerlink" title="vue-admin"></a>vue-admin</h1><p>场景： 二次迭代 </p><p><a href="https://gitee.com/panjiachen/vue-admin-template?_from=gitee_search">vue-admin-template</a>  下载项目 找到核心内容 （自己分到的业务模块）</p><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p>固定的抽象模式  语义化  + 增加可维护性</p><ol><li>src - 业务代码 最终浏览器中运行 （目录划分相似 语义化 模块化 - 维护方便）</li><li>src之外 - 开发阶段配置文件</li></ol><h1 id="关键文件"><a href="#关键文件" class="headerlink" title="关键文件"></a>关键文件</h1><ol><li><p><strong>package.json  包管理文件</strong></p><ol><li>scripts  可执行的命令 可以自定义 </li><li>dependencies  生产依赖  这里面的包参与业务开发最终打包上线  npm i axios 参与打包  运行浏览器</li><li>devDependencies 开发依赖 开发阶段生效 不参与打包  npm i sass -D 不参与打包  开发阶段生效<br>团队开发模式下 整个团队要保证每个人在本地依赖的包都是一样的</li></ol></li><li><p><strong>main.js</strong><br>不写业务代码  全局初始化的事情 初始化三方组件&#x2F;样式初始化&#x2F;store&#x2F;router</p><p>全局注册elementui 挂载vuerouter 挂载vuex 渲染app根组件</p></li><li><p>组件化的开发模式  组件树</p></li><li><p><strong>vueRouter</strong></p><ol><li>如果左侧菜单只有一项  如何配置</li><li>如果左侧菜单有嵌套  如何配置</li></ol></li><li><p><strong>vuex</strong></p><p>解决的问题：把应用中很多地方都会用到的状态统一管理<br>模块化的开发模式：1. 定义模块（state - mutation - action） 2. 把子模块在modules选项中注册好<br>使用vuex中的数据或者方法：加上模块名</p><ol><li>模块化  namespaced  modules: {子模块}</li><li>和数据相关的所有操作都放到vuex中维护 + 组件只做一个事儿 触发action</li></ol></li></ol><h1 id="request-js-apis"><a href="#request-js-apis" class="headerlink" title="request.js + apis"></a>request.js + apis</h1><ol><li>request 产生一个实例对象给每一个api函数使用  一对多的关系  request配置一次  所有的api函数都会跟着生效</li><li>asiox基础封装<ol><li>实例化  axios.create({}) baseURL + timeout</li><li>请求拦截器 拦截请求处理请求参数再交给后端  headers中注入token</li><li>响应拦截器 拦截返回数据做处理再交给客户端  401  return response.data  401状态 数据剥离</li></ol></li><li>拓展<ol><li>axios.create() 可以执行多次</li><li>拦截器可以有多个（串联参数的模式 前一个拦截器处理完 会把处理之后的数据 下发给下一个拦截器继续处理）</li><li>拦截器函数中千万别弄丢 return</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 1. 通用配置</span></span><br><span class="line"><span class="comment">// 2. 定制化配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用配置</span></span><br><span class="line"><span class="comment">// 1. axios实例化  axios.create() 基地址配置 baseURL + 超时时间 timeout（100ms）</span></span><br><span class="line"><span class="comment">// 拓展：create方法可以调用多次 每次执行都会生成一个独一无二的实例</span></span><br><span class="line"><span class="comment">// export default const a = asiox.create(&#123; baseURL: &#x27;a.com&#x27; &#125;)</span></span><br><span class="line"><span class="comment">// export default const b = asiox.create(&#123; baseURL: &#x27;b.com&#x27; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求拦截器  请求头中添加token数据  接口鉴权  统一配置</span></span><br><span class="line"><span class="comment">// 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端</span></span><br><span class="line"><span class="comment">// 拓展：可以添加多个请求拦截器</span></span><br><span class="line"><span class="comment">// 客户端请求 - 拦截器1(处理参数) - 拦截器2 - 后端 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 响应拦截器 数据剥离 res.data / 401错误处理 / 前端自定义错误处理？ </span></span><br><span class="line"><span class="comment">// 后端 - 响应拦截器 - 客户端</span></span><br><span class="line"><span class="comment">// 成功回调 200-300</span></span><br><span class="line"><span class="comment">// 失败回调 不在这个之间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果后端不管接口成功还是失败统一返回200？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api-hmzs.itheima.net/v1&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span> <span class="comment">// request timeout</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一般项目中多数的接口使用的配置是相似的，所以需要统一配置一次</span><br><span class="line"><span class="number">2.</span> 请求拦截器主要做的事情是在请求发送之前，针对请求参数对象做一些事情（比如添加鉴权<span class="title class_">Token</span>）</span><br><span class="line"><span class="number">3.</span> 响应拦截器主要做的事情是在响应数据返回到业务方之前，针对响应对象做一些事情（比如简化data，错误处理等）</span><br></pre></td></tr></table></figure><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><ol><li><p>业务模式</p><ol><li><p>表单基础校验</p></li><li><p>表单统一校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 按照业务要求编写校验规则对象（rules）</span><br><span class="line">2. el-form组件绑定表单对象（model）和规则对象（rules）</span><br><span class="line">3. el-form-item组件通过prop属性指定要使用的校验规则</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line"> 基础校验</span><br><span class="line">el-form  :model=&quot;表单对象&quot;  :rules=&quot;规则对象&quot;</span><br><span class="line">el-form-item  prop属性指定一下要使用哪条规则</span><br><span class="line">el-input v-model双向绑定</span><br><span class="line"></span><br><span class="line">统一校验</span><br><span class="line">1. 获取表单的实例对象</span><br><span class="line">2. 调用validate方法</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>后续的业务处理（调用接口 - token - 存入token - 跳转首页 - 提示用户）</p></li></ol></li><li><p>表单校验</p><ol><li>先通过 devtools查看双向啊绑定是否成功</li><li>对照接口文档查看接口参数是否一致（拼写+类型）</li><li>校验时机实时校验和统一校验都需要</li></ol></li><li><p>token管理</p><blockquote><p>业务背景：Token的有效期会持续一段时间，在这段时间内没有必要重复请求token，但是Vuex本身是基于内存的管理方式，<strong>刷新浏览器Token会丢失</strong>，为了避免丢失需要配置持久化进行缓存<br>基础思路：</p><ol><li>存Token数据时，一份存入vuex，一份存入cookie</li><li>vuex中初始化Token时，优先从本地cookie取，取不到再初始化为空串儿</li></ol></blockquote><ol><li>多模块共享  - vuex维护</li><li>管理方式 vuex + cookie(localstorage)</li></ol><h2 id="为什么要使用Vuex-Cookies"><a href="#为什么要使用Vuex-Cookies" class="headerlink" title="为什么要使用Vuex+Cookies"></a>为什么要使用Vuex+Cookies</h2><blockquote><p>俩种存储方式的优势都想要</p><ol><li>vuex  基于内存  存取快  但是刷新就丢失</li><li>ls&#x2F;cookie  基于磁盘  存取速度稍慢  刷新不丢失(持久化)</li></ol><p>因为我们既可以享受vuex速度优势封装优势 同时保持持久化</p></blockquote><h2 id="cookie-vs-ls"><a href="#cookie-vs-ls" class="headerlink" title="cookie  vs  ls"></a>cookie  vs  ls</h2><ol><li>存数据的空间大小</li></ol><p>​     ls  5M    cookie kb</p><ol start="2"><li>是否允许后端操作</li></ol><p>​     ls 纯前端操作   cookie 前端可操作 后端也可操作(占多数)</p><ol start="3"><li>是否跟随接口发送</li></ol><p>​      cookie</p></li></ol><h1 id="token持久化"><a href="#token持久化" class="headerlink" title="token持久化"></a>token持久化</h1><ol><li><p>为什么要进行持久化<br>基于vuex的存储页面刷新token丢失</p></li><li><p>如何来做</p><ol><li>在获取到token之后 一式两份  vuex + cookie(ls)</li><li>Vuex初始化state的时候 优先从本地取 取不到才初始化为空</li></ol></li><li><p>vuex vs cookie<br>vuex - 基于内存  快 刷新就丢<br>cookie - 基于磁盘 稍慢 持久化</p></li></ol><h1 id="请求头添加token（请求拦截器）"><a href="#请求头添加token（请求拦截器）" class="headerlink" title="请求头添加token（请求拦截器）"></a>请求头添加token（请求拦截器）</h1><ol><li><p>为什么要做<br>接口鉴权 </p></li><li><p>怎么做<br>请求拦截器中统一配置  headers.Authorization &#x3D; token(格式以后端要求的为主)</p></li></ol><h1 id="记住我优化"><a href="#记住我优化" class="headerlink" title="记住我优化"></a>记住我优化</h1><ol><li>基础实现逻辑<br>如果当前用户选中了记住，在登录时把用户的信息存入本地 在组件初始化的时候去取数据 回填<br>  如果当前没有选中，在登录时把数据清空</li></ol><h1 id="接口错误统一处理"><a href="#接口错误统一处理" class="headerlink" title="接口错误统一处理"></a>接口错误统一处理</h1><ol><li><p>为什么统一处理<br>很多个接口都需要做这个事儿<br>  而且报错的提示位置和字段和后端协商好的</p></li><li><p>如何来做<br>axios响应拦截器来做 判断错误信息存在 弹框提示</p></li></ol><h1 id="token是否存在控制路由权限跳转"><a href="#token是否存在控制路由权限跳转" class="headerlink" title="token是否存在控制路由权限跳转"></a>token是否存在控制路由权限跳转</h1><ol><li>根据流程图 -&gt; js分支语句</li><li>permission.js <ol><li>权限相关的事儿都放到这里 模块化的思想</li><li>路由权限前置守卫</li><li>main.js引入立刻执行</li></ol></li></ol><h1 id="数据基础渲染"><a href="#数据基础渲染" class="headerlink" title="数据基础渲染"></a>数据基础渲染</h1><ol><li>基础实现逻辑<ol><li>准备静态模版（elementUI）</li><li>解决初始报错 在data中把模版绑定的数据都声明一遍</li><li>封装接口（url&#x2F; method &#x2F; 参数[名称 + 类型 + 参数数量]）</li><li>组件中封装一个独立的方法 在方法中调用接口函数 （复用的好处 调用之前做一些额外的参数处理）</li><li>选择一个合适生命周期钩子函数调用独立的方法 （created &#x2F; mounted 都可以）</li><li>使用数据渲染模版 （数据驱动视图）</li></ol></li></ol><h1 id="列表基础渲染"><a href="#列表基础渲染" class="headerlink" title="列表基础渲染"></a>列表基础渲染</h1><ol><li><p>实现步骤</p><ol><li>按照接口文档请求列表接口封装一下（url&#x2F;method&#x2F;参数）[拼写&#x2F;类型]</li><li>data准备响应式的数据（以后端接口实际返回为主）</li><li>在methods封装一个方法（参数的二次处理 + 调用接口 + 数据赋值）</li><li>生命周期钩子函数调用这个方法（created &#x2F; mounted）</li><li>把响应式数据绑定组件身上（文档组件要求通过什么属性绑定就通过生命属性）</li></ol></li><li><p>分页功能</p><ol><li><p>分页的逻辑<br>页数 &#x3D; 总条数 &#x2F; 单页的条数</p></li><li><p>组件分好页<br>传入总数  :total&#x3D;”100”<br>单页条数  :pageSize&#x3D;”2” 默认10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">   1. 页数分出来 （页数 = 总条数 / 每页条数）</span><br><span class="line">   2. 点击每页的时候获取当前页的数据重新渲染到table上</span><br><span class="line">--&gt;</span><br><span class="line">&lt;el-pagination</span><br><span class="line">  layout=&quot;total, prev, pager, next&quot;</span><br><span class="line">  :page-size=&quot;params.pageSize&quot;</span><br><span class="line">  :total=&quot;total&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击分页交互的实现</p><ol><li><p>点击时拿到当前点击的页数（父组件从子组件获取内部的数据 子传父）<br>@current-change&#x3D;”pageChange”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pageChange</span>(<span class="params">page</span>) &#123; </span><br><span class="line">   <span class="comment">// console.log(page) // 回调参数 拿到的是当前页</span></span><br><span class="line">   <span class="comment">// 把点击的页数赋值给请求参数页数  </span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line">   <span class="comment">// 使用最新的请求参数获取列表数据</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getCardList</span>()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用当前的页数去后端要当前页的数据重新渲染到table</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">params</span>.<span class="property">page</span> = page</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">getList</span>()</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h1 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h1><!-- 搜索区域 --><pre><code>思路分析：把各种搜索条件当作请求参数发给后端 后端会根据字段对数据库数据做过滤筛选拿到符合条件返回  1. 表单组件的双向绑定收集到当前的请求数据        2. 把收集到的表单参数发送接口给后端那符合条件的数据        3. 把拿到的数据关系显示在列表中</code></pre><p>下拉组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-select v-model=&quot;params.cardStatus&quot;&gt;</span><br><span class="line">     &lt;!-- </span><br><span class="line">        el-select: 双向绑定收集当前选中的数据</span><br><span class="line">        el-option： 下拉框中的每一项</span><br><span class="line">         label（中文显示）</span><br><span class="line">         value （选中之后赋值给v-model的数据将来传给后端）</span><br><span class="line">    --&gt;</span><br><span class="line">   &lt;el-option</span><br><span class="line">     v-for=&quot;item in cardStatusList&quot;</span><br><span class="line">     :key=&quot;item.id&quot;</span><br><span class="line">     :value=&quot;item.id&quot;</span><br><span class="line">     :label=&quot;item.name&quot;</span><br><span class="line">   /&gt;</span><br><span class="line"> &lt;/el-select&gt;</span><br></pre></td></tr></table></figure><h1 id="状态适配"><a href="#状态适配" class="headerlink" title="状态适配"></a>状态适配</h1><ol><li><p>场景<br>后端返回的数据无法直接显示到页面中 0&#x2F;1 男女</p></li><li><p>转化的状态码数量只有两个<br>解决方案：三元表达式  status &#x3D;&#x3D;&#x3D; 0? ‘女’ ：’男’</p><p>转化的状态码比较多<br>解决方案：映射的方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">status</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAP</span> = &#123;</span><br><span class="line">   <span class="number">0</span>:<span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">   <span class="number">1</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">MAP</span>[status]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h1><pre><code>1. 步骤   1. 点击跳转到新的路由页面/在当前页面打开一个弹框   2. 准备表单项（通常只要有表单就会有校验 单独校验 + 统一校验）   3. 收集表单数据（打开devtools 检测双向绑定是否ok）   4. 提交 (接口字段不多不少 字段名称完全对应 类型完全匹配)   5. 后续的逻辑处理 （提供用户 + 重新拉取列表 + 表单的重置 + 路由的重置）</code></pre><h1 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h1><ol><li><p>简单校验<br>使用elementUI默认的配置项就可以完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">  el-form  :model  :rules</span><br><span class="line">  el-form-item  prop指定要用哪条规则</span><br><span class="line">  el-input v-model双向绑定</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>自定义校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">validateMobile</span> = (<span class="params">rule,value,cb</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 默认的配置 声明式配置</span></span><br><span class="line">      <span class="comment">// 自定义校验逻辑 命令式的校验 写的式逻辑代码</span></span><br><span class="line">      <span class="comment">// value: 输入框的数据 校验的那个数据</span></span><br><span class="line">      <span class="comment">// cb：校验放行函数 不管在通过还是未通过都需要调用它</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  validator： validateMobile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对某些字段单独校验</p><ol><li>场景：默认的表单校验管控不到 出现在自定义组件中 上传</li><li>调用单独校验实例方法  this.$refs.form.validateField(‘校验的字段’)</li></ol></li><li><p>表单功能的时候要提前做数据验证 devtools 双向绑定是否生效 生效之后再调用接口</p></li></ol><h1 id="梳理新增和编辑"><a href="#梳理新增和编辑" class="headerlink" title="梳理新增和编辑"></a>梳理新增和编辑</h1><ol><li><p>新增 点击新增按钮 - 跳转到新增路由 - 准备表单- 二次参数处理 - 提交新增接口 - 后续处理（提示&#x2F;回跳）</p></li><li><p>编辑 点击编辑按钮 - 携带id跳转到新增路由 - 准备表单（回填） - 表单校验 - 二次参数处理 - 提交的更新接口 - 提示回跳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">  scope 作用域插槽</span><br><span class="line">  scope.row  -&gt; 当前行的数据对象</span><br><span class="line"> </span><br><span class="line">  如果我们只是想使用插槽渲染模板 #default</span><br><span class="line">  如果我们除了想要使用插槽渲染模板 而且还想要拿到它内部的数据 #default=&quot;scope&quot;</span><br><span class="line">  scope 类似于函数的形参</span><br><span class="line">  组件内部会把当前行数数据对象当成一个实参传到scope的位置</span><br><span class="line">  </span><br><span class="line">  在内部传递实参的时候 实参的格式</span><br><span class="line">  &#123;</span><br><span class="line">   row: 当前行的对象数据</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  因为本来传下来的就是一个对象 所以通过解构赋值的方式去取row参数 #default=&quot;&#123;row&#125;&quot;</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;el-button size=&quot;mini&quot; type=&quot;text&quot; @click=&quot;editCard(scope.row.id)&quot;&gt;编辑&lt;/el-button&gt;</span><br></pre></td></tr></table></figure></li></ol><p>重点：</p><ol><li><p>新增和编辑状态 始终用的就是 id 有id代表当前是编辑状态 没有id代表就是新增状态</p><ol><li>有id 才获取详情接口</li><li>有id 调用更新接口 没有id 调用新增接口</li><li>有id 显示编辑 没有id 显示新增</li></ol></li><li><p>点击确定调用接口时区分状态之外 还需区分参数</p><ol><li>如果是新增接口调用  没有任何id</li><li>如果是更新接口调用  请求参数中附加id[相关id数据在数据回填的时候加进去] 通知后端要更新谁</li></ol></li></ol><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><ol><li><p>上传的流程<br>点击上传按钮 -&gt; el-upload [打开本地文件选择框 + 上传前的文件校验] -&gt; File -&gt;<br>new FormData()[接口要求传递一个formdata类型的数据] -&gt; 往formData的对象中append字段<br>-&gt; append(‘file’,file) append(‘type’,’business…’) -&gt; 使用完整的formData对象提交接口完成    上传</p></li><li><p>细节问题</p><ol><li>el-upload<ol><li>非常简单  不需要做任何的自定义配置 默认的配置项完成上传就行了</li><li>需要自定义场景  :http-request&#x3D;’function’</li><li>如果添加了上传前的校验 流程：先执行上传前的校验函数 函数返回值为true 再执行upload上传函数</li><li>函数参数 ：上传前的函数 file对象 [size &#x2F; type做校验] 上传函数  res对象 { file：File }</li></ol></li><li>上传接口接口参数<ol><li>常规的接口  contentType  application&#x2F;json</li><li>上传接口    contentType  application&#x2F;form-data</li></ol></li><li>前后端校验逻辑要保持一致<br>文件大小  小于5m  &#x2F; 文件类型 jpeg  前端要以这个为主<br>[因为接口不只是可以通过浏览器提交 也可以通过其他方式提交 基于界面操作类校验会失败]</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> :http-request=&quot;uploadRequest&quot; 自定义上传</span><br><span class="line">  action 本来是一个用来配置默认上传的接口地址</span><br><span class="line">  因为我们覆盖了  所以用一个 # 占个位置 消除必填警告</span><br><span class="line">  input type=&quot;file&quot; 本身具备选择文件的能力</span><br><span class="line">  覆盖原因：默认的配置上传不够灵活 仅支持一些简单的上传 </span><br><span class="line"></span><br><span class="line">  如果想要完全自定义上传 http-request</span><br><span class="line">  在选择文件之后 自动执行upload函数 并且把一个对象传给我们</span><br><span class="line">  对象中有一个file属性 就是我们要上传的对象</span><br><span class="line">      </span><br><span class="line">  上传前校验：</span><br><span class="line">    1. 上传图片之前加一层校验 目的为了限制用户上传的文件类型和大小</span><br><span class="line">    2. 如果我们添加了beforeUpload这个属性方法 这个函数中必须return的数据为true</span><br><span class="line">       才会继续执行 upload 方法 如果校验不通过 暂停执行 不会走上传逻辑</span><br><span class="line">    3. file对象中两个属性</span><br><span class="line">       size: 文件大小 / 1024/1024 = M</span><br><span class="line">       type: 文件类型  image/文件类型</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=&quot;营业执照&quot;&gt;</span><br><span class="line">    &lt;el-upload</span><br><span class="line">      action=&quot;#&quot;</span><br><span class="line">      :http-request=&quot;uploadRequest&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">      &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">    &lt;/el-upload&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- </span><br><span class="line">    上传实现流程：</span><br><span class="line">      1. el-upload 打开本地文件  并且校验这个文件是否符合要求 - File</span><br><span class="line">      2. :http-request = &#x27;upload&#x27;</span><br><span class="line">      3. 按照接口的要求格式 得到类型为FormData对象 new FormData()</span><br><span class="line">      4. 按照要求往 formData中添加字段数据 fd.append(&#x27;字段名&#x27;,&#x27;字段值&#x27;)</span><br><span class="line">      5. 调用上传接口</span><br><span class="line">      6. 拿到返回的文件地址和其有用的信息id 存入data中的响应式数据的位置 将来提交表单</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure><h1 id="表单校验-1"><a href="#表单校验-1" class="headerlink" title="表单校验"></a>表单校验</h1><ol><li>基础校验  [按照配置]</li><li>统一校验  [validate 把所有需要校验的表单项都校验一便 把校验的结果布尔值返回valid]</li><li>自定义校验规则 [{ validator:校验方法 rule value cb } 不管是成功还是失败都必须调用cb]</li><li>单独校验某个表单字段<ol><li>场景：表单中有一些特殊的字段  没有直接和el-form表单系统进行绑定  有值之后不会通知校验系统</li><li>解决办法：手动触发校验逻辑 调用el-form组件实例对象的单独校验方法 validateField(‘prop指定的那        个规则’)</li></ol></li></ol><h1 id="vue2的响应式缺点"><a href="#vue2的响应式缺点" class="headerlink" title="vue2的响应式缺点"></a>vue2的响应式缺点</h1><p>对象的属性动态添加 不是响应式的<br>Object.defineProperty<br>解决办法：<br>  this.$set(要修改的对象,要添加的属性名，新属性的值)</p><p>特俗情况： v-model  视图修改的时候同样可以被收集到本来不存在的属性身上</p><h1 id="下拉列表的数据"><a href="#下拉列表的数据" class="headerlink" title="下拉列表的数据"></a>下拉列表的数据</h1><ol><li>单独有一个下拉列表接口</li><li>没有单独下拉 复用table表格的列表接口（不需要判断状态 没有状态的所有数据）</li></ol><p>知道一个事情：业务数据是由状态的 而且状态可以通过用户操作进行切换</p><h1 id="表单的清空"><a href="#表单的清空" class="headerlink" title="表单的清空"></a>表单的清空</h1><ol><li><p>调用表单组件的实例方法 resetFields</p></li><li><p>手动做数据的清除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">form</span> = &#123;</span><br><span class="line">   name= <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="网络请求的优化"><a href="#网络请求的优化" class="headerlink" title="网络请求的优化"></a>网络请求的优化</h1><ol><li>场景: 限制了请求个数 保证只有打开时才请求</li><li>怎么做到？<ol><li>判断第一个参数row是否能在第二个参数rows中找到 如果能找到代表打开了</li><li>find 通过匹配找到符合条件的第一项 然后把找到的项返回</li><li>findIndex 通过匹配找到符合条件的第一项 然后把找到项的下标值返回 splice(index,1)</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有展开时获取数据并绑定</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">expandHandle</span>(<span class="params">row, rows</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;展开或关闭&#x27;, row, rows) 点击行row.id  rows数组对象</span></span><br><span class="line">  <span class="comment">// row: 当前行的对象  rows数组对象</span></span><br><span class="line">  <span class="comment">// 1. 先拿到当前行的数据</span></span><br><span class="line">  <span class="comment">// 2. 使用当前行的企业数据，获取下面的合同列表数据</span></span><br><span class="line">  <span class="comment">// 3. 把拿到的合同列表存入企业对象中 但是row里面没有存放的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化网络请求 只在打开时才去触发 核心：拿到当前是打开的条件 做判断</span></span><br><span class="line">    <span class="comment">// 判断条件：第一个row是否能在第二个rows中找到 如果找到了 代表打开了 如果找不到 代表收起了</span></span><br><span class="line">    <span class="comment">// find findIndex</span></span><br><span class="line">  <span class="keyword">const</span> isExpend = rows.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === row.<span class="property">id</span>)</span><br><span class="line">  <span class="keyword">if</span> (isExpend) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了这一项，才回去调用接口</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getRentListAPI</span>(row.<span class="property">id</span>)</span><br><span class="line">    <span class="comment">// eslint-disable-next-line require-atomic-updates</span></span><br><span class="line">    row.<span class="property">rentList</span> = res.<span class="property">data</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="带有模板的状态格式化"><a href="#带有模板的状态格式化" class="headerlink" title="带有模板的状态格式化"></a>带有模板的状态格式化</h1><ol><li><p>直接可以把后端的数据渲染出来 prop指定要渲染的字段</p></li><li><p>不能直接渲染  需要格式化  格式化出来的内容一九是一个文本  string</p><ol><li>：formatter&#x3D;”formatStatus” 不需要手动传参 自动传入</li><li>插槽 + 插值表达式  [渲染出来的是函数的返回值]</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">default</span>=<span class="string">&quot;&#123;row&#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; formatStatus(row.status) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>&#x2F;&#x2F; 格式化status<br>   formatStatus(type) {<br>  const TYPEMAP &#x3D; {<br>       0: ‘待生效’,<br>    1: ‘生效中’,<br>       2: ‘已到期’,<br>       3: ‘已退租’<br>     }<br>     return TYPEMAP[type]<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 不能直接渲染 格式化出来的是一个模板</span><br><span class="line"></span><br><span class="line">   插槽 + 插值表达式 [渲染出来的是函数的返回值]</span><br><span class="line"></span><br><span class="line">   ```html</span><br><span class="line">   &lt;template default=&quot;&#123;row&#125;&quot;&gt;</span><br><span class="line">       &lt;el-tag&gt; &#123;&#123; formatStatus(row.status) &#125;&#125; &lt;/el-tag&gt;</span><br><span class="line">   &lt;/template&gt;</span><br></pre></td></tr></table></figure><p>​      </p><h1 id="对象动态添加响应式属性"><a href="#对象动态添加响应式属性" class="headerlink" title="对象动态添加响应式属性"></a>对象动态添加响应式属性</h1><ol><li><p>vue2 Object.defineProperty  无法监听到对象属性的添加 &#x2F; 数组通过下标直接修改 也监听不到</p></li><li><p>Vue.set &#x2F; this.$set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">form</span>,<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>) <span class="comment">// 就会变成响应式</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">list</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;new data&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h1 id="后端返回的数据字段不够-需要前端自定义字段"><a href="#后端返回的数据字段不够-需要前端自定义字段" class="headerlink" title="后端返回的数据字段不够 需要前端自定义字段"></a>后端返回的数据字段不够 需要前端自定义字段</h1><p>  默认的返回的企业列表数据中没有一个存放合同列表的数据的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">list</span> = res.<span class="property">data</span>.<span class="property">rows</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">rendList</span>: []  <span class="comment">// 通过映射自定义添加字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="word-文档的预览"><a href="#word-文档的预览" class="headerlink" title="word 文档的预览"></a>word 文档的预览</h1><p>解决方案：通过一个固定的预览地址 拼接 自己的合同url地址 然后通过a链接在新窗口打开</p><p>拼接方式：prewViewURL?src&#x3D;url</p><h1 id="业务数据状态变化"><a href="#业务数据状态变化" class="headerlink" title="业务数据状态变化"></a>业务数据状态变化</h1><p>合同列表</p><ol><li>当前时间还没有合同的起止时间 未开始</li><li>当前时间已经超过了合同的起止时间 已结束</li><li>当前时间正好式合同期限内，且用户没有退租 生效中</li></ol><p>不同的业务数据状态影响显示及操作区域按钮的控制</p><p>实际开发时如何判断某块业务已经跑通了：接口通了并且对应的状态已经确认被修改了</p><h1 id="excel导出"><a href="#excel导出" class="headerlink" title="excel导出"></a>excel导出</h1><ol><li><p>实际开发过程中的导出</p><ol><li><p>前端主导（xlsx）</p><p>流程：调用列表接口把要导出的数据拿到 -&gt; 数据的二次转化  -&gt;  [excel 工作簿 - 工作表 - 单元格数据] - 使用xlsx创建一个工作簿 - 使用xlsx方法创建一个工作表 - 把工作表添加到工作簿 – [使用中文替换中文表头] 调用xlsx的导出方法</p><p>工作中遇到了需求，参考代码 换接口 数据二次处理 处理表头</p></li><li><p>后端主导（最常见）</p><p>流程：前端直接调用导出接口 - 后端会把数据转换成excel文件流当成返回值返回 - 直接触发浏览器的下载功能</p></li></ol></li><li><p>两种方案的本质区别：</p><p>把数据转化成excel的过程发生在哪里？如果发生在浏览器 前端主导 如果发生在后端服务器 后端主导</p><p>前端主导 - 处理数据量不能太大</p><p>后端主导 - 适合处理量大或量小都可</p></li></ol><h1 id="账单支付金额的接口计算"><a href="#账单支付金额的接口计算" class="headerlink" title="账单支付金额的接口计算"></a>账单支付金额的接口计算</h1><p>思想：</p><p>​    操作表现流程：选中了楼宇 + 选中时间  &#x3D;&gt; 调用接口  -&gt; 计算之后的数据 -&gt; 显示到input框内</p><pre><code>1. 通过事件分别监听一下楼宇什么时候选中 时间什么时候选中  [通过事件绑定回调函数 两个组件分别绑定同一个回调函数]   2. 在事件的回调中判断一下接口必须传参是否都具备了 [非空判断]   3. 如果接口参数都不是空  正常发接口请求  获取计算金额   4. 通过 v-model 进行正常的回填  [通过属性控制它不可编辑]</code></pre><h1 id="tab切换类交互"><a href="#tab切换类交互" class="headerlink" title="tab切换类交互"></a>tab切换类交互</h1><ol><li>场景：角色列表切换  &#x2F; 菜单列表切换  &#x2F; tabs组件点击切换</li><li>通用实现方法<ol><li>点击谁把谁index&#x2F;id（唯一的标识）记录下来</li><li>准备一个激活的类名样式 active </li><li>通过vue中的动态类名:class &#x3D; {acitve: index(当前项index) &#x3D;&#x3D;&#x3D; curIndex（激活记录下标） }</li></ol></li></ol><h1 id="树状组件"><a href="#树状组件" class="headerlink" title="树状组件"></a>树状组件</h1><ol><li><p>树:嵌套的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;第一项&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="string">&#x27;1-1&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&#x27;第二项&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">id</span>:<span class="string">&#x27;1-1-1&#x27;</span>,</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;第三项&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>如何把一个平铺的数组处理成树形的数组？<br>大多是情况下 都需要前端自己处理 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeList = [</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">   <span class="attr">title</span>:<span class="string">&#x27;第一项&#x27;</span>,</span><br><span class="line">   <span class="attr">pid</span>: <span class="literal">null</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">id</span>:<span class="string">&#x27;1-1&#x27;</span>,</span><br><span class="line">   <span class="attr">title</span>:<span class="string">&#x27;第二项&#x27;</span>,</span><br><span class="line">   <span class="attr">pid</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">id</span>:<span class="string">&#x27;1-1-1&#x27;</span>,</span><br><span class="line">   <span class="attr">title</span>:<span class="string">&#x27;第三项&#x27;</span>，</span><br><span class="line">   <span class="attr">pid</span>:<span class="string">&#x27;1-1&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h1 id="前端同步异步的问题"><a href="#前端同步异步的问题" class="headerlink" title="前端同步异步的问题"></a>前端同步异步的问题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getRoleList</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getTreeList</span>()</span><br><span class="line">  <span class="comment">// 初始化的时候使用第一项的roleId进行高亮处理</span></span><br><span class="line">  <span class="comment">// 这个方法调用初始化时同步调用 而它依赖的roleList treeList都是通过异步获取的</span></span><br><span class="line">  <span class="comment">// 为了保证数据已经准备好了 模拟同步 必须保证上面的俩个异步返回数据之后才调用方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setTreeByPerms</span>(<span class="variable language_">this</span>.<span class="property">roleList</span>[<span class="number">0</span>].<span class="property">roleId</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RBAC指的是什么？"><a href="#RBAC指的是什么？" class="headerlink" title="RBAC指的是什么？"></a>RBAC指的是什么？</h1><p>基于角色的权限控制思想<br>员工 - 角色 - 权限点<br>先把权限点交给某个角色 然后再把角色交给某个员工 这个员工自动有了角色下所有的权限点</p><h1 id="前端菜单路由权限控制"><a href="#前端菜单路由权限控制" class="headerlink" title="前端菜单路由权限控制"></a>前端菜单路由权限控制</h1><p><img src="https://bu.dusays.com/2023/09/04/64f5e46ce1093.png" alt="74.png"></p><ol><li>权限数据的生成（RBAC）<ol><li>新增一个角色 给角色配置权限数据</li><li>新增一个员工 给员工分配这个角色 员工就有了当前角色下所有的权限数据</li></ol></li><li>完整的实现流程<ol><li><p>调用接口获取当前员工的权限数据  permission [‘park:building:add_edit’]</p><ol><li>在Vuex中编写逻辑，user&#x2F;state里存放个人用户信息 </li><li>action里调用时，把permissions目标数据return出去 给另一个js模块使用</li><li>permission文件中触发action，获取用户信息（有token时）</li></ol></li><li><p>对权限数据做格式化处理 产生两个权限数据  一级路由权限数组 + 二级路由权限数组</p></li><li><p>把路由表拆分成两部分 动态路由表[需要加权限控制] + 静态路由表[不需要加权限控制]</p><ol><li>拆分动态路由表导出使用 asyncRoutes</li><li>初始化时候只处理静态路由表  routes: […routes]</li></ol></li><li><p>以一级和二级权限数组作为对主动态路由表做过滤筛选处理 -&gt; 有资格加入到路由系统中的动态路由表</p><ol><li>使用一级权限点过滤一级路由 使用二级权限点过滤二级路由 最终得到显示左侧的路由表</li><li>调用函数获取最终的动态路由</li></ol></li><li><p>调用router的addRoute方法把动态路由表依次添加到路由系统中 访问url可以渲染对应的组件</p></li><li><p>使用动态路由表数据通过存入Vuex然后利用它响应式的特性 渲染到左侧菜单中</p><ol><li>vuex新增一个模块，menu模块，先以静态的路由表作为初始值</li><li>在得到过滤之后的动态路由表之后，和之前的静态做一个结合</li><li>在sidebar组件中结合v-for指令做使用Vuex中的数据做渲染</li></ol></li><li><p>解决切换用户有缓存的bug 方案：在用户退出登录时</p><ol><li><p>调用清空路由的reset方法</p></li><li><p>手动把Vuex中的数据也清空</p></li><li><p>用户信息也清空</p></li></ol></li></ol></li><li>每一个独立的小功能封装成一个独立的小函数 维护方便</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">profile</span>.<span class="property">id</span>) &#123;</span><br><span class="line">       <span class="comment">// 1. 调用action函数获取用户权限数据</span></span><br><span class="line">       <span class="keyword">const</span> permissions = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getProfile&#x27;</span>)</span><br><span class="line">       <span class="comment">// 2. 把后端的权限数组格式化成我们自己的俩个权限数据</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前的权限数据为:&#x27;</span>, permissions)</span><br><span class="line">       <span class="keyword">const</span> firstRoutePerms = <span class="title function_">getFirstRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一级路由权限&#x27;</span>, firstRoutePerms)</span><br><span class="line">       <span class="keyword">const</span> secondRoutePerms = <span class="title function_">getSecondRoutePerms</span>(permissions)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;二级路由权限&#x27;</span>, secondRoutePerms)</span><br><span class="line">       <span class="comment">// 3. 根据权限标识过滤路由表 最终得到显示到左侧的路由表</span></span><br><span class="line">       <span class="keyword">const</span> routes = <span class="title function_">getRoutes</span>(firstRoutePerms, secondRoutePerms, asyncRoutes)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最终路由表&#x27;</span>, routes)</span><br><span class="line">       <span class="comment">// 4. addRoute动态添加 (当浏览器中访问路由的路径 显示渲染出来对应的组件)</span></span><br><span class="line">       routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> router.<span class="title function_">addRoute</span>(route))</span><br><span class="line">       <span class="comment">// 5. 存入Vuex渲染左侧菜单</span></span><br><span class="line">       store.<span class="title function_">commit</span>(<span class="string">&#x27;menu/setMenuList&#x27;</span>, routes)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧园区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue原理</title>
      <link href="/posts/f82ea27.html"/>
      <url>/posts/f82ea27.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Vue原理"><a href="#一、Vue原理" class="headerlink" title="一、Vue原理"></a>一、Vue原理</h2><ul><li>响应式系统<ul><li>学习<code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</li></ul></li><li>vue中选项方法<ul><li>学习watch选项 $watch方法 computed选项 $set方法 $nextTick $mount方法的封装</li></ul></li><li>template 编译过程<ul><li>学习<code>Vue</code>内部是怎么把<code>template</code>模板编译成虚拟<code>DOM</code>,从而渲染出真实<code>DOM</code></li></ul></li><li>虚拟 dom 生成与更新<ul><li>学习什么是虚拟 DOM，以及<code>Vue</code>中的<code>DOM-Diff</code>原理</li></ul></li></ul><h2 id="二、Vue2-学习路线图"><a href="#二、Vue2-学习路线图" class="headerlink" title="二、Vue2 学习路线图"></a>二、Vue2 学习路线图</h2><p>下面这张流程图中表示了vue的关键部分的执行过程，和核心函数。我们可以根据这样一个过程来自己实现一个vue框架。</p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://bu.dusays.com/2023/08/20/64e1c9eb42347.png" alt="image-20230704110034877-8439636.png"></h6><p>通过梳理Vue初始化的过程，我们发现实现一个类似于Vue的框架主要需要实现这几部分 响应式系统框架、虚拟dom编译渲染机制 MVVM更新机制，接下来我们先从最基本的响应式系统开始，自己动手写一个Vue的简单框架</p><p>【思考】Vue在初始化的过程中主要经历的哪些步骤</p><p>【回答】</p><p>1、初始化Vue构造函数，挂载属性 方法</p><p>2、模板编译成render函数</p><p>3、通过Watcher收集依赖</p><p>4、diff更新dom</p><p>5、渲染dom</p><p>【补充】vue是一个标准的MVVM框架么？</p><p>Vue 并不完全是一个MVVM框架MVVM只能数据驱动视图，视图更改数据，而不能通过其他方式操作数据。在vue中我们也可以自己手动修改数据，所以vue并不是一个完全意义上的MVVM框架。</p><h2 id="三、Vue2-响应式原理"><a href="#三、Vue2-响应式原理" class="headerlink" title="三、Vue2 响应式原理"></a>三、Vue2 响应式原理</h2><p>从这一小节开始我们带着大家实现一个Vue框架</p><p>我们先来看看面试宝典中的关于Vue响应式的八股文 （P143-4）</p><p><img src="https://bu.dusays.com/2023/08/20/64e1cb8bedb70.png" alt="image-20230712205031984.png"></p><p>相信绝大多数的同学看到这个八股文都会感觉头大。学完今天的内容，我们都会对怎么回答vue的响应式原理有了自己的理解。</p><p>下面我们一起来揭秘vue的响应式原理到底是怎么实现的！</p><h3 id="1、章节概述"><a href="#1、章节概述" class="headerlink" title="1、章节概述"></a>1、章节概述</h3><p>我们首先实现学习路线中第一条分支，从状态初始化到数据响应式的过程</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e7ec1b1.png" alt="image-20230712205309319.png"></p><p>所谓数据响应式就是<strong>能够使数据变化可以被检测并对这种变化做出响应的机制</strong>。MVVM框架中要解决的一个核心问题是连接数据层和视图层，通过<strong>数据驱动</strong>应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9dc7f684.png" alt="data.png"></p><p>Vue 的响应式原理依赖于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>，Vue通过设定对象属性的 setter&#x2F;getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。</p><p>所以在vue中的数据响应式原理主要是给data绑定一个观察着 observe 让数据变成可观察的，我们首先来看源码然后自己尝试手写一个observe</p><h3 id="2、环境准备"><a href="#2、环境准备" class="headerlink" title="2、环境准备"></a>2、环境准备</h3><p>在这一小节中我们开始自己实现一个Vue框架，通过Vue源码我们了解到Vue使用的rollup构建工具进行打包</p><p><strong>&#x2F;package.json</strong></p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9dd5dfad.png" alt="image-20230419133024189.png"></p><p>这里我们也使用Rollup实现项目打包，我们之前有学习过脚手架工具webpack，Rollup和webpack的区别在于项目类代码中有大量的代码拆分，构建项目类型的应用显然webpack更为合适，如果想要构建js类库将多个模块打包成一个大的文件rollpu更加合适，同时rollup中提供的tree-shake可以帮助我们自动删除冗余代码</p><table><thead><tr><th><strong>Webpack</strong></th><th><strong>Rollup</strong></th></tr></thead><tbody><tr><td>vue-cli, create-react-app 各类应用脚手架</td><td>react，vue，three.js，<a href="https://so.csdn.net/so/search?q=D3&spm=1001.2101.3001.7020">D3</a>，moment</td></tr></tbody></table><h4 id="1、源码工程的初始化"><a href="#1、源码工程的初始化" class="headerlink" title="1、源码工程的初始化"></a>1、源码工程的初始化</h4><h5 id="1、新建项目文件夹，在文件夹下初始化工程"><a href="#1、新建项目文件夹，在文件夹下初始化工程" class="headerlink" title="1、新建项目文件夹，在文件夹下初始化工程"></a>1、新建项目文件夹，在文件夹下初始化工程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9df6c2cb.png" alt="image-20230419134428522.png"></p><p>获得package.json</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e037863.png" alt="image-20230419134457299.png"></p><h5 id="2、安装Rollup打包依赖"><a href="#2、安装Rollup打包依赖" class="headerlink" title="2、安装Rollup打包依赖"></a>2、安装Rollup打包依赖</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1，安装 rollup：用于 Vue 源码的打包构建</span><br><span class="line">npm install rollup</span><br><span class="line"></span><br><span class="line">// 2，使用 babel：需要安装核心模块 @babel/core；</span><br><span class="line">npm install @babel/core</span><br><span class="line"></span><br><span class="line">// 3，rollup 与 babel 关联</span><br><span class="line">npm install rollup-plugin-babel</span><br><span class="line"></span><br><span class="line">// 4，浏览器兼容：将 ES6 语法转译为 ES5</span><br><span class="line">npm install @babel/preset-env</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ==&gt; 合并写法：一次性安装开发环境所需的全部依赖</span><br><span class="line">npm install rollup @babel/core rollup-plugin-babel @babel/preset-env -D</span><br></pre></td></tr></table></figure><h5 id="3、创建Vue-js文件"><a href="#3、创建Vue-js文件" class="headerlink" title="3、创建Vue.js文件"></a>3、创建Vue.js文件</h5><p>创建打包入口：src&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js Vue 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Vue 函数，提供外部使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9dfc043b.png" alt="image-20230419135420661.png"></p><h5 id="4、创建-Rollup-配置文件"><a href="#4、创建-Rollup-配置文件" class="headerlink" title="4、创建 Rollup 配置文件"></a>4、创建 Rollup 配置文件</h5><p>rollup 默认配置文件：项目根目录下<code>rollup.config.js</code>文件</p><p>创建 rollup.config.js，完成 rollup、<a href="https://so.csdn.net/so/search?q=babel&spm=1001.2101.3001.7020">babel</a> 相关配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-babel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 rollup 配置对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 打包入口</span></span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,   </span><br><span class="line">  <span class="comment">// 打包出口：可定义为数组，输出多种构件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;                </span><br><span class="line">    <span class="comment">// 打包输出文件</span></span><br><span class="line">    <span class="attr">file</span>: <span class="string">&#x27;dist/vue.js&#x27;</span>,   </span><br><span class="line">    <span class="comment">// 打包格式（可选项）：iife（立即执行函数）、esm（ES6 模块）、cjs（Node 规范）、umd（支持 amd + cjs）</span></span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,         </span><br><span class="line">    <span class="comment">// 使用 umd 打包需要指定导出的模块名，Vue 模块将会绑定到 window 上；</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span>,          </span><br><span class="line">    <span class="comment">// 开启 sourcemap 源码映射，打包时会生成 .map 文件；作用：浏览器调试ES5代码时，可定位到ES6源代码所在行；</span></span><br><span class="line">    <span class="attr">sourcemap</span>: <span class="literal">true</span>,      </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用 Rollup 插件转译代码</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="comment">// 忽略 node_modules 目录下所有文件（**：所有文件夹下的所有文件）</span></span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&#x27;node_modules/**&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、创建-rollup-构建脚本"><a href="#5、创建-rollup-构建脚本" class="headerlink" title="5、创建 rollup 构建脚本"></a>5、创建 rollup 构建脚本</h5><p>执行 Rollup 打包构建 Vue，创建 rollup-script 构建脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">.........</span><br><span class="line">  <span class="comment">// ollup 命令：默认会去找 node_module/bin/rollup；</span></span><br><span class="line"><span class="comment">// - -c：config 选项，使用配置文件，默认找 rollup.config.js；</span></span><br><span class="line"><span class="comment">// - -w：watch 选项，监听文件变化；当文件发生变化时重新打包；</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rollup -c -w&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">.........</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>dev 脚本解释：</p><ul><li>rollup 命令：默认会去找 node_module&#x2F;bin&#x2F;rollup；</li><li>-c：config 选项，使用配置文件，默认找 rollup.config.js；</li><li>-w：watch 选项，监听文件变化；当文件发生变化时重新打包；</li></ul><h5 id="6、打包构建-Vue"><a href="#6、打包构建-Vue" class="headerlink" title="6、打包构建 Vue"></a>6、打包构建 Vue</h5><p>执行构建脚本 npm run dev</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9de75622.png" alt="image-20230419135603333.png"></p><p>将 <code>src/index.js</code> 输出至 <code>dist/vue.js</code> 其中，<code>vue.js.map</code> 为 sourcemap 源码映射文件</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e1a53ce.png" alt="image-20230419135710522.png"></p><h5 id="7、创建-Html-引入-Vue"><a href="#7、创建-Html-引入-Vue" class="headerlink" title="7、创建 Html 引入 Vue"></a>7、创建 Html 引入 Vue</h5><p>创建 <code>dist/index.html</code> 引入 <code>dist/vue.js</code>，打印输出 Vue：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 vue.js，将会绑定到 window--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vue</span>) </span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开<code>index.html</code>，查看控制台输出，此时一个<code>Vue</code>的构建环境就搭建完成了</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e008d28.png" alt="image-20230419135928971.png"></p><h3 id="3、Vue函数的封装"><a href="#3、Vue函数的封装" class="headerlink" title="3、Vue函数的封装"></a>3、Vue函数的封装</h3><p>【目标】封装一个 Vue 函数并且在 index.html 中引入</p><p>【前置知识】</p><p>在js中函数和class都可以new，如下：有啥区别呢 ？</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e5aa25b.png" alt="Snipaste_2023-08-20_16-04-06.png"></p><p>class <strong>类是用于创建对象的模板。</strong></p><p>我们使用 class 关键字来创建一个类，类体在一对大括号 <strong>{}</strong> 中，我们可以在大括号 <strong>{}</strong> 中定义类成员的位置，如方法或构造函数。</p><p>每个类中包含了一个特殊的方法 **constructor()**，它是类的构造函数，这种方法用于创建和初始化一个由 <strong>class</strong> 创建的对象。</p><p>创建一个类的语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>在js中除了class函数也可以new，函数本身就是对象，在js中每定义一个函数都会同时生成一个以这个函数体为构造函数的对象，不信你试试</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e6d4278.png" alt="image-20230704111250514.png"></p><p>可以通过对象来new出一个新的对象。定义 function Vue(options){} 时， 实际上生成了一个Function类型（预定义类型）的对象，对象名叫Vue，对象的构造函数就是这个函数的体。如下</p><p>我们在初始化<code>Vue</code>项目的时候使用到<code>new</code>关键字，这里的vue是使用函数定义的。目的是提升vue的灵活性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = options.<span class="property">name</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = options.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【思考】为什么vue使用函数定义而其他的watcher observer使用class定义？</p><p>【回答】核心目的：提升Vue的灵活性：</p><p>1、class的所有方法都是不可枚举的，而function声明的函数是可以枚举的。用户可以根据需要定制重写（重载）vue提供的成员方法</p><p>2、function 既能当常规函数来用，又能当做函数的属性来用，又能当类来用。相对class更加灵活。</p><p>3、对于内部定义的不希望修改的方法，通过class来定义，另外class声明的函数会有变量提升。</p><p>下面我们实例化一个Vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时在 vm 实例上就具有了 name 和 data 属性</p><p>接下来我们在<code>src/index.js</code>中定义这个类并导出。在构造函数中获取传入的<code>options</code>并挂载到<code>vue</code>实例上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vue构造器执行&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  vm.<span class="property">$options</span> = options        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在 <strong>dist&#x2F;index.html</strong>中实例化一个Vue对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 vue.js，将会绑定到 window--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">a</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">b</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">c</span>: <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&quot;hello world!&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e0cb735.png" alt="image-20230505142517798.png"></p><p>此时我们访问<code>Vue</code>对象中data里面定义的数据不能直接访问，必须通过<code>vue.data.xxx</code>访问，实际在<code>Vue</code>项目中<code>data</code>里面定义的数据是可以直击访问的，所以我们需要给<code>data</code>中的数据添加一个代理实现数据的直接访问。</p><h3 id="4、核心函数-Object-defineProperty-的介绍和简单响应式的实现"><a href="#4、核心函数-Object-defineProperty-的介绍和简单响应式的实现" class="headerlink" title="4、核心函数 Object.defineProperty 的介绍和简单响应式的实现"></a>4、核心函数 Object.defineProperty 的介绍和简单响应式的实现</h3><p>【目标】能够了解Object.defineProperty的用法，并且实现一个简单的响应式</p><p>为了实现vue中的数据代理，我们需要首先了解一下vue中的响应式核心方法Object.defineProperty</p><p>Object.defineProperty 在 vue2 中起到了非常重要的作用，通过Object.defineProperty实现了数据的代理，数据响应式原理，以及vue中的一些重要成员方法。下面我们学习Object.defineProperty的基本概念和用法。</p><p>语法：**<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty(obj, prop, descriptor)</a>**<br>其中：<strong>obj</strong>要在其上定义属性的对象。<strong>prop</strong>要定义或修改的属性的名称。<strong>descriptor</strong>将被定义或修改的属性描述符。</p><p>参数：    1、obj : 第一个参数就是要在哪个对象身上添加或者修改属性</p><p>​2、prop : 第二个参数就是添加或修改的属性名</p><p>​3、desc ： 配置项，一般是一个对象 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">desc 的详细配置</span><br><span class="line">writable：是否可重写</span><br><span class="line">value：  当前值 </span><br><span class="line">enumerable： 是否可以遍历</span><br><span class="line">configurable： 是否可再次修改配置项</span><br><span class="line">get：     读取时内部调用的函数</span><br><span class="line">set：        写入时内部调用的函数</span><br><span class="line"></span><br><span class="line">当数据调用的时候触发get 方法，当数据修改的时候触发set方法</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 通过 Object.defineProperty 设置的属性默认是不可修改，不可枚举，不可配置</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以枚举</span></span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span> <span class="comment">// 是否可以修改</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【思考】什么是响应式？</p><p>【回答】对外界的变化做出反应</p><p>【思考】数据响应式的核心思想是什么？</p><p>【回答】将数据变成可观察的</p><p>下面我们来实现一个简单的数据响应式过程，在 dist 下新建一个 **defineproperty.html **</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 定义数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 实现数据的渲染</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3. 当视图改变数据改变</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4. 当数据改变驱动视图更新</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">value</span>: <span class="string">&#x27;hello kilito&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">dir</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        data.<span class="property">value</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="property">value</span> = data.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 这里的value的作用是形成闭包，拓展函数体内部变量的作用域</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, prop, value, cb</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生获取&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> value</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生了修改！&#x27;</span>, val)</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 将数据修改之后的值 val 在get中返回</span></span></span><br><span class="line"><span class="language-javascript">                value = val</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">cb</span>(val)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineReactive</span>(data, <span class="string">&#x27;value&#x27;</span>, data[<span class="string">&#x27;value&#x27;</span>], update)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// data.value = &#x27;123&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 数据发生了修改！ 123</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#x27;123&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 视图发生了改变 123</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e6bd2fe.png" alt="Snipaste_2023-08-20_16-04-59.png"></p><p>【思考】数据获取的时候触发的哪个方法，数据修改的时候触发的哪个方法？</p><p>【回答】获取触发get 修改触发set</p><p>【思考】上面这段代码实现了什么呢？</p><p>【回答】实现了数据的双向绑定，数据改变视图改变，视图改变数据也改变</p><p>【思考】定义defineReactive函数的时候，里面第三个参数value的作用？</p><p>【回答】在函数体内部形成闭包结构，用开来拓展函数内部变量的作用域</p><h3 id="5、通过data代理，实现数据的访问"><a href="#5、通过data代理，实现数据的访问" class="headerlink" title="5、通过data代理，实现数据的访问"></a>5、通过data代理，实现数据的访问</h3><p>【目标】实现data的代理可以直接通过vm实例获取data中定义的数据</p><p>【思考】在 vue 中的数据是存放在 data 中为什么可以通过 vm.XXX 直接访问数据呢？</p><p>【回答】通过数据代理实现数据的访问</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c9e26c0fb.png" alt="image-20230704114327873.png"></p><p>此时我们想获取数据 a 需要通过 Vue.$options.data.a ，但是在 vue 中只需要 this.a 就可以获取到 a 的值，这是怎么实现的呢？</p><p>在 Vue 中，可以在外部直接通过vm实例进行数据访问和操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">         <span class="attr">b</span>: &#123;</span><br><span class="line">          <span class="attr">c</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">message</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>当前代码中，外部通过vue实例只能拿到 <code>vue.$options</code>，想要拿到<code>data</code>需要 <code>vue.$options.data</code>，要想实现<code>vue.message</code>和<code>vue.$options.data.message</code>等效，就需要想办法将<code>vue</code>实例操作“代理”到<code>$options.data</code>上；这样，就实现了 Vue 的数据代理我们来观察一下vue的实例，在实例上有一个_data属性 还有我们定义的变量。</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c861f0ef8.png" alt="image-20230704115013875.png"></p><p>首先，先做一次代理，将<code>data</code>挂载到 vue._data下（因为Object.defineProperty的第一个参数必须为一的对象，我们，第一层代理更加方便我们在实现属性的追加），这样 vue 实例就能够在外部通过<code>vue._data.message</code>获取到<code>data.message</code>；</p><p>之后，再做一次代理，将 vue 实例操作 vue.message 代理到 vue.<em>data 上，这样，外部就可以直接通过vue.message 获取到 data.message；</em></p><p>Vue 状态初始化阶段，通过 observe() 实现数据响应式之后，通过 Object.defineProperty 对 _data 中的数据操作进行劫持；将 vue.xxx 在 vue 实例上的取值操作，代理到 vue._data.xxx 上，这样可以简化书写。</p><p>下面我们开始实现数据的代理</p><p><code>data</code>挂载到 vue._data下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vue构造函数执行&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">  vm.<span class="property">$options</span> = options</span><br><span class="line">    <span class="comment">// options.data 可能是对象也可能是函数</span></span><br><span class="line">  vm.<span class="property">_data</span> = <span class="title function_">typeof</span>(options.<span class="property">data</span>) === <span class="string">&#x27;function&#x27;</span> ? options.<span class="title function_">data</span>() : options.<span class="property">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将vue实例操作vue.message代理到vue._data上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据代理 实现非侵入的数据修改</span></span><br><span class="line"><span class="comment">// 定义代理方法</span></span><br><span class="line"><span class="comment">// 将vue实例上的操作，代理到 vue._data上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_proxy</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        set (val) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_data</span>[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在Vue的构造器中使用proxy方法代理数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vue构造函数执行&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    vm.<span class="property">$options</span> = options</span><br><span class="line">    vm.<span class="property">_data</span> = <span class="title function_">typeof</span>(options.<span class="property">data</span>) === <span class="string">&#x27;function&#x27;</span> ? options.<span class="title function_">data</span>() : options.<span class="property">data</span></span><br><span class="line">    _proxy.<span class="title function_">call</span>(vm,vm.<span class="property">_data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再访问vue对象中的数据，就不需要.data了，观察打印结果：当从vue实例取值时，就会被代理到vm._data取值；</p><p><img src="https://bu.dusays.com/2023/08/20/64e1c81d1b531.png" alt="Snipaste_2023-08-20_15-54-59.png"></p><p>【总结】vue中实现数据直接访问的实现步骤</p><p>1、将 data 暴露在 vue._ <em>data 实例属性上<br>2、利用 Object.defineProperty 将 vue.xxx 操作代理到 vue.</em> _data 上</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS设计模式"><a href="#JS设计模式" class="headerlink" title="JS设计模式"></a>JS设计模式</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">传送门:wiki-设计模式</a></p><p><a href="https://www.ituring.com.cn/book/1632">传送门:JavaScript设计模式与开发实践</a></p></blockquote><p>设计模式的指的是：在<strong>面向对象软件</strong>设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。</p><p>目前说到设计模式，一般指的是《设计模式：可复用面向对象软件的基础》一书中提到的<strong>23种</strong>常见的软件开发设计模式。</p><p>JavaScript中不需要生搬硬套这些模式，咱们结合实际前端开发中的具体应用场景，来看看有哪些常用的设计模式</p><p>这一节咱们会学习:</p><ol><li>JS中的常用设计模式</li><li>设计模式在开发&#x2F;框架中的应用场景</li></ol><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>在JavaScript中，工厂模式的表现形式就是一个<strong>直接调用即可返回新对象的函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数并实例化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;柯基&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ToyFactory</span>(<span class="params">name,price</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> toy1 = <span class="title class_">ToyFactory</span>(<span class="string">&#x27;布娃娃&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> toy2 = <span class="title class_">ToyFactory</span>(<span class="string">&#x27;玩具车&#x27;</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ol><li><p>Vue2-&gt;Vue3: </p><ol><li>启用了<code>new Vue</code>,改成了工厂函数<code>createApp</code>-<a href="https://v3-migration.vuejs.org/zh/breaking-changes/global-api.html">传送门</a></li><li><em><strong>任何全局改变 Vue 行为的 API(vue2) 现在都会移动到应用实例上(vue3)</strong></em></li><li>就不会出现,Vue2中多个Vue实例共享,相同的全局设置,可以<strong>实现隔离</strong></li><li>避免vue2中全局设置的东西，比如组件，影响后续实例</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#app1</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#app2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>vue2-全局注册组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">    实例1 组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">my-title</span>&gt;</span><span class="tag">&lt;/<span class="name">my-title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">    实例2</span><br><span class="line">    <span class="tag">&lt;<span class="name">my-title</span>&gt;</span><span class="tag">&lt;/<span class="name">my-title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.7.9/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 全局注册组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-title&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 组件的结构</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">template</span>: <span class="string">&#x27;&lt;h2 style=&quot;color:orange&quot;&gt;标题组件&lt;/h2&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app1 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app1&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app2 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app2&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>axios.create:</p><ol><li>基于传入的配置创建一个新的<code>axios</code>实例,<a href="https://www.axios-http.cn/docs/instance">传送门</a></li><li>项目中有2个请求基地址如何设置?</li><li>创建出多个请求不同的对象，比如设置多个基地址</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 基于不同基地址创建多个 请求对象</span></span><br><span class="line"><span class="keyword">const</span> request1 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;基地址1&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> request2 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;基地址2&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> request3 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;基地址3&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过对应的请求对象,调用接口即可</span></span><br><span class="line"><span class="title function_">request1</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;基地址1的接口&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">request2</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;基地址2的接口&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">request3</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;基地址3的接口&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>小结:</p><ol><li>工厂模式:JS中的表现形式,<strong>返回新对象的函数(方法)</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>日常开发中,有2个很经典的场景</p><ol><li><code>vue3</code>中创建实例的api改为<code>createApp</code>,<code>vue2</code>中是<code>new Vue</code><ol><li>Vue3中,没有影响所有Vue实例的api了,全都变成了影响某个app对象的api,比如<code>Vue.component--&gt;app.component</code></li></ol></li><li><code>axios.create</code>基于传入的配置,创建一个新的请求对象,可以用来设置多个基地址</li></ol></li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>单例模式指的是，在使用这个模式时，单例对象整个系统需要保证只有一个存在。</strong></p><p><strong>需求:</strong></p><ol><li>通过静态方法<code>getInstance</code>获取<strong>唯一实例</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1===s2)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义类</li><li>私有静态属性:<code>#instance</code></li><li>提供静态方法<code>getInstance</code>:<ol><li>调用时判断<code>#instance</code>是否存在:</li><li>存在:直接返回</li><li>不存在:实例化,保存,并返回</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">   <span class="comment">// 私有属性，保存唯一实例</span></span><br><span class="line">   <span class="keyword">static</span> #instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取单例的方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(this) // SingleTon类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">SingleTon</span>.#instance === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 内部可以调用构造函数</span></span><br><span class="line">      <span class="title class_">SingleTon</span>.#instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SingleTon</span>.#instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1===s2)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>实际应用:</strong></p><ol><li>vant组件库中的弹框组件,保证弹框是单例<ol><li>toast组件:<a href="https://gitee.com/vant-contrib/vant/blob/main/packages/vant/src/toast/index.ts">传送门</a></li><li>notify组件:<a href="https://gitee.com/vant-contrib/vant/blob/main/packages/vant/src/notify/index.ts">传送门</a></li><li>如果弹框对象<ol><li>不存在,–&gt;创建一个新的</li><li>存在,直接用</li></ol></li></ol></li><li>vue中注册插件,用到了单例的思想(只能注册一次)<ol><li>vue2:<a href="https://gitee.com/vuejs/vue/blob/main/src/core/global-api/use.ts">传送门</a></li><li>vue3:<a href="https://gitee.com/vuejs/core/blob/main/packages/runtime-core/src/apiCreateApp.ts#L256">传送门</a></li></ol></li></ol><p><strong>小结:</strong></p><ol><li><p>单例模式:</p><ol><li>保证,应用程序中,某个对象,只能有一个</li></ol></li><li><p>自己实现:</p><ol><li>getInstance方法,<ol><li>实例存在-&gt;返回</li><li>实例不存在-&gt;创建,保存-&gt;返回</li></ol></li></ol></li><li><p>应用场景:</p><ol><li>我在看源码的时候,发现,vant的toast和notify组件都用到了单例<ol><li>多次弹框,不会创建多个弹框,复用唯一的弹框对象</li></ol></li><li>vue中注册插件,vue3和vue2都会判断插件是否已经注册,已注册,直接提示用户</li></ol></li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在对象之间定义一个<strong>一对多</strong>的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p><strong>举个例子:</strong></p><ol><li><code>dom</code>事件绑定，比如</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load触发1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load触发2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load触发3&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Vue的生命周期钩子:</p><ol><li>vue框架,提供给开发者,在Vue实例特定时期,添加自定义逻辑的,一种机制.</li><li>一共有：<ol><li>beforeCreated </li><li>created</li><li>beforeMount </li><li>Mounted </li><li>beforeUpdate </li><li>Updated </li><li>beforeDestory </li><li>destoryed</li><li>缓存组件（keep-alive）：activated  deactivated</li></ol></li></ol></li><li><p>Vue的响应式原理:</p><ol><li><p><a href="https://v2.cn.vuejs.org/v2/guide/reactivity.html">传送门</a></p></li><li><p><strong>自己描述：响应式原理</strong></p><ol><li><p>创建Vue实例时，会通过Object.definedProperty将data中的数据的每个属性都转为get和set</p></li><li><p>就可以监测到对数据的，取值get和赋值set</p></li><li><p>只要数据发生了变更，就会去通知所有使用数据为止，更新</p><ol><li>页面</li><li>侦听器</li><li>…</li></ol><p><img src="https://bu.dusays.com/2023/08/19/64e0ac0f284d5.png" alt="vue响应式原理.png"></p></li></ol></li><li><p>自己描述2-涉及到虚拟dom：</p><ol><li>可能被追问：<ol><li>为什么需要使用<strong>虚拟dom</strong>？ 虚拟dom内存中，速度快</li><li>新旧dom比较，如何比较的？ <ol><li><strong>diff算法</strong> 找不同</li><li>vue中同级比较<ol><li>有id，id不同，直接不同</li><li>没有id，比元素，在比属性</li></ol></li></ol></li><li>vue的diff算法和react的diff算法有什么区别？</li></ol></li></ol><p><img src="https://bu.dusays.com/2023/08/19/64e0ac9e5e0c8.png" alt="vue响应式原理2.png"></p></li><li><p>自己回答：</p><ol><li>vue2中使用的是 Object.definedProperty，动态新增的属性，没有响应式，this.$set</li><li>vue3中是Proxy<ol><li>没有这个问题，Proxy可以检测到所有属性的改变</li><li>vue3中只用了 Proxy 吗？不是，引用了<code>Object.definedProperty</code></li></ol></li></ol></li></ol></li></ol><h3 id="发布订阅模式01-应用场景"><a href="#发布订阅模式01-应用场景" class="headerlink" title="发布订阅模式01-应用场景"></a>发布订阅模式01-应用场景</h3><p>发布订阅模式可以实现的效果类似观察者模式,但是两者略有差异,一句话描述:一个有中间商(<strong>发布订阅模式</strong>)一个没中间商(<strong>观察者模式</strong>)</p><p><img src="https://bu.dusays.com/2023/08/19/64e0ca7198385.png" alt="image-20230626153656768.png"></p><p><img src="https://bu.dusays.com/2023/08/19/64e0ca7198385.png" alt="image-20230706002933258.png"></p><p><strong>应用场景:</strong></p><ol><li><code>vue2</code>中的<code>EventBus</code>:<a href="https://v2.cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6">传送门</a></li><li><code>vue3</code>中因为移除了实例上对应方法，可以使用替代方案:<a href="https://v3-migration.vuejs.org/zh/breaking-changes/events-api.html">传送门</a><ol><li>官方推荐,用插件</li><li>微微一笑:直接写</li></ol></li></ol><h3 id="发布订阅模式02-自己写一个事件总线"><a href="#发布订阅模式02-自己写一个事件总线" class="headerlink" title="发布订阅模式02-自己写一个事件总线"></a>发布订阅模式02-自己写一个事件总线</h3><p><strong>需求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> <span class="title class_">HMEmitter</span>()</span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">bus.$on(<span class="string">&#x27;事件名1&#x27;</span>,回调函数)</span><br><span class="line">bus.$on(<span class="string">&#x27;事件名1&#x27;</span>,回调函数)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">bus.$emit(<span class="string">&#x27;事件名&#x27;</span>,参数<span class="number">1</span>,...,参数n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">bus.$off(<span class="string">&#x27;事件名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性事件</span></span><br><span class="line">bus.$once(<span class="string">&#x27;事件名&#x27;</span>,回调函数)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义类</li><li>私有属性:<code>#handlers=&#123;事件1:[f1,f2],事件2:[f3,f4]&#125;</code></li><li>实例方法:<ol><li>$on(事件名,回调函数):注册事件</li><li>$emit(事件名,参数列表):触发事件</li><li>$off(事件名):移除事件</li><li>$once(事件名,回调函数):注册一次性事件</li></ol></li></ol><p><strong>基础模板:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>自己实现事件总线<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;on&quot;</span>&gt;</span>注册事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;emit&quot;</span>&gt;</span>触发事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span>移除事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;once-on&quot;</span>&gt;</span>一次性事件注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;once-emit&quot;</span>&gt;</span>一次性事件触发<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">class</span> <span class="title class_">HMEmmiter</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 逻辑略</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 简化 querySelector调用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">qs</span>(<span class="params">selector</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 注册事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.on&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 触发事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.emit&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 移除事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.off&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 一次性事件注册</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.once-on&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 一次性事件触发</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">qs</span>(<span class="string">&#x27;.once-emit&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HMEmmiter</span> &#123;</span><br><span class="line">  #handlers = &#123;&#125;</span><br><span class="line">  <span class="comment">// 注册事件</span></span><br><span class="line">  $on(event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.#handlers[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#handlers[event] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册继续push</span></span><br><span class="line">    <span class="variable language_">this</span>.#handlers[event].<span class="title function_">push</span>(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  $emit(event, ...args) &#123;</span><br><span class="line">      <span class="comment">// 取出保存的时间 []</span></span><br><span class="line">    <span class="keyword">const</span> funcs = <span class="variable language_">this</span>.#handlers[event] || []</span><br><span class="line">      <span class="comment">// 挨个触发，并传入参数</span></span><br><span class="line">    funcs.<span class="title function_">forEach</span>(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">func</span>(...args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  $off(event) &#123;</span><br><span class="line">      <span class="comment">// event 对应的回调函数数组设置空即可</span></span><br><span class="line">    <span class="variable language_">this</span>.#handlers[event] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一次性事件:注册了以后，只能触发一次</span></span><br><span class="line">  $once(event, callback) &#123;</span><br><span class="line">      <span class="comment">// 触发之后，清空，移除</span></span><br><span class="line">    <span class="variable language_">this</span>.$on(event, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 callback</span></span><br><span class="line">      <span class="title function_">callback</span>(...args)</span><br><span class="line">        <span class="comment">// 移除注册的event事件</span></span><br><span class="line">      <span class="variable language_">this</span>.$off(event)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过<strong>克隆原型</strong>的方式来创建出一个与原型一样（共享一套数据&#x2F;方法）的对象。在<code>JavaScript</code>中,<code>Object.create</code>就是实现原型模式的内置<code>api</code></p><p><strong>应用场景:</strong></p><p><code>vue2</code>中重写数组方法:</p><ol><li>调用方法时(<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>)可以触发视图更新:<a href="https://v2.cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95">传送门</a></li><li>源代码:<a href="https://gitee.com/vuejs/vue/blob/main/src/core/observer/array.ts">传送门</a>&#96;</li><li>测试一下:</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>原型模式<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.7.9/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">foods</span>: [<span class="string">&#x27;西瓜&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">foods</span>.<span class="property">push</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/19/64e0bad8f3abf.png" alt="原型模式.png"></p><p><strong>自己描述:</strong></p><ol><li>vue2中数组重写了7个方法,内部基于数组的原型<code>Array.prototype</code>创建了一个新对象</li><li><code>Object.create</code>浅拷贝</li><li>内部<ol><li>调用数组的原方法,获取结果并返回—方法的功能和之前一致</li><li>通知了所有的观察者去更新视图</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">arr</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="property">arr</span>.<span class="property">push</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>原型模式,基于某个对象,创建一个新的对象,JS中,通过Object.create即可实现,Vue中重写数组方法就是这么做的 ↑</li></ol><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式指的是<strong>拦截和控制</strong>与目标对象的交互,在<code>JavaScript</code>中通过<code>Proxy</code>,即可实现对象的代理,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">传送门</a></p><p><strong>核心语法:</strong></p><ol><li>初始对象可以直接修改任意属性</li><li>通过<code>Proxy</code>生成代理对象，限制访问</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前obj对象的name和age属性可以被随意修改</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Proxy创建代理对象 </span></span><br><span class="line"><span class="comment">// 最大的特点就是，无论操作的属性，在对象上是否存在 都会触发 get set</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// []语法进行对象的取值和赋值</span></span><br><span class="line">    <span class="comment">// target: 源对象</span></span><br><span class="line">    <span class="comment">// key： 属性名</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get触发&#x27;</span>)</span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 结合Reflect的静态方法替换[]语法</span></span><br><span class="line">    <span class="comment">// target: 源对象</span></span><br><span class="line">    <span class="comment">// key： 属性名</span></span><br><span class="line">    <span class="comment">// value：设置的值</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set触发&#x27;</span>)</span><br><span class="line">   <span class="comment">// target[key]=value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 代理对象属性赋值，触发set</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;rose&#x27;</span></span><br><span class="line"><span class="comment">// 代理对象属性取值，触发get</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p><strong>需求:</strong></p><p>基于上一份代码实现:</p><ol><li>属性取值和赋值时,如果属性不存在,报错</li><li>修改name时,只能设置字符串,否则报错</li></ol><p><strong>关键步骤:</strong></p><ol><li>在<code>get</code>中添加取值判断逻辑</li><li>在<code>set</code>中添加赋值判断逻辑</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前obj对象的name和age属性可以被随意修改</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Proxy创建代理对象 </span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// []语法进行对象的取值和赋值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target[key]) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;属性不存在&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target[key])&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;属性不存在&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断类型</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        target[key]=value</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;name属性只能设置字符串&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 代理对象属性赋值，触发set</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;rose&#x27;</span></span><br><span class="line"><span class="comment">// 不存在friend 报错</span></span><br><span class="line">objProxy.<span class="property">friend</span> = <span class="string">&#x27;rose&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>实际应用:</strong></p><p><code>Vue3</code>的响应式原理-<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue">传送门</a></p><ol><li><p>通过<code>Proxy</code>创建响应式对象</p></li><li><p><code>getter/setter</code>用于<code>ref</code></p></li><li><p>Vue2考虑兼容,用的是兼容性好的<code>Object.defineProperty</code>,但是无法跟踪动态增加的属性</p></li><li><p><code>Vue3</code>中用了<code>Proxy</code>,他对于动态增加的属性,也可以检测到,但是Vue3中也用了<code>Object.defineProperty</code></p><ol><li><p><code>reactive</code>用的是<code>Proxy</code></p><ol><li>注意点:解构之后会丢失响应性,需要用<code>toRefs</code></li></ol></li><li><p><code>ref</code>用的是<code>Object.defineProperty</code></p></li></ol></li><li><p>观察者模式–&gt;虚拟dom-&gt;diff算法</p></li></ol><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示.简而言之就是:<strong>遍历</strong></p><p>遍历作为日常开发中的<strong>高频</strong>操作,JavaScript中有大量的默认实现:<strong>比如</strong></p><ol><li><code>Array.prototype.forEach</code>:遍历数组</li><li><code>NodeList.prototype.forEach</code>:遍历<code>dom</code>,<code>document.querySelectorAll</code></li><li><code>for in</code></li><li><code>for of</code></li></ol><p><strong>面试题</strong>:</p><ol><li><p><code>for in</code> 和<code>for of</code> 的区别?</p><ol><li><p><strong><code>for...in</code></strong> <strong>语句</strong>以任意顺序迭代一个对象的除<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a>属性，包括继承的可枚举属性。</p><ol><li>对象默认的属性以及动态增加的属性都是<strong>可枚举</strong>属性</li><li>遍历出来的是<strong>属性名</strong></li><li>继承而来的属性也会遍历</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 原型上默认的属性和方法,都是不可枚举(for in不出来)</span></span><br><span class="line">    <span class="comment">// 动态添加的,默认是可枚举(可以for in出来)</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;奔跑&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">swim</span> = <span class="string">&#x27;游泳&#x27;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="string">&#x27;小鸡&#x27;</span>, <span class="string">&#x27;小鸭&#x27;</span>, <span class="string">&#x27;小鱼&#x27;</span>]</span><br><span class="line">        <span class="comment">// 遍历的是key,继承而来的属性也可以遍历出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;key:&#x27;</span>, key) <span class="comment">// key: 0  key: 1  key: 2  key: swim  key: run  </span></span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 遍历的值,继承而来的遍历不出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iterator:&#x27;</span>, iterator) <span class="comment">// key: 小鸡 key: 小鸭 key: 小鱼</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>for...of</code>语句</strong>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">可迭代对象</a>（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a> 对象等等）上创建一个迭代循环</p><ol><li>for of不会遍历<strong>继承</strong>而来的属性</li><li>遍历出来的是<strong>属性值</strong></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;小鸡&#x27;</span>, <span class="string">&#x27;小鸭&#x27;</span>, <span class="string">&#x27;小鱼&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 obj可以 for of for of出来的是他内部的 数组</span></span><br><span class="line"><span class="comment">// 自定义 forof执行的行为</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: <span class="string">&#x27;rose&#x27;</span>,</span><br><span class="line">  <span class="attr">skill</span>: <span class="string">&#x27;jump together&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;沙县&#x27;</span>, <span class="string">&#x27;猪脚饭&#x27;</span>, <span class="string">&#x27;手撕鸡&#x27;</span>],</span><br><span class="line">  <span class="comment">// 属性名表达式</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// console.log(this)</span></span><br><span class="line">    <span class="comment">// 返回一个对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">foods</span>[index++]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历的值,继承而来的遍历不出来</span></span><br><span class="line"><span class="comment">// for (const iterator of arr) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;iterator:&#x27;, iterator)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for of 并不能遍历所有的东西,比如 object无法遍历</span></span><br><span class="line"><span class="comment">// 直接遍历对象: obj is not iterable,obj不可迭代</span></span><br><span class="line"><span class="comment">// [Symbol.iterator] 添加之后,可以迭代,要求返回特定格式的对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iterator:&#x27;</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可迭代协议和迭代器协议:</strong></p><ol><li><p>可迭代协议:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">传送门</a></p><ol><li>给对象增加属方法<code> [Symbol.iterator]()&#123;&#125;</code></li><li>返回一个符合迭代器协议的对象</li></ol></li><li><p>迭代器协议:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">传送门</a></p><ol><li>next方法,返回对象:<ol><li><code>&#123;done:true&#125;</code>,迭代结束</li><li><code>&#123;done:false,value:&#39;xx&#39;&#125;</code>,获取解析并接续迭代</li></ol></li></ol></li><li><p>面试问及:</p><ol><li>for of可以遍历一部分的类型,比如数组,map</li><li>对象无法遍历,因为对象没有实现 可迭代协议,迭代器协议</li><li>可迭代协议,迭代器协议,约定了:<ol><li>可迭代协议:对象上要有一个指定属性的函数,返回 满足迭代器要求的对象</li><li>迭代器协议: <code>next</code>方法,返回<code>&#123;done:true&#125;,&#123;done:false,value:&#39;x&#39;&#125;</code></li><li>我自己尝试写过一下,但是仅针对语法</li><li>可以和面试官讨论一下,可以用在哪?</li></ol></li></ol></li><li><p>直接打印对象,看到<strong>Symbol(Symbol.iterator)</strong>,说明可以使用<code>for of</code></p></li></ol><h2 id="JS调用栈"><a href="#JS调用栈" class="headerlink" title="JS调用栈"></a>JS调用栈</h2><ol><li>执行上下文和调用栈</li><li>栈溢出</li></ol><h3 id="执行上下文和调用栈"><a href="#执行上下文和调用栈" class="headerlink" title="执行上下文和调用栈"></a>执行上下文和调用栈</h3><p><a href="https://262.ecma-international.org/6.0/">执行上下文</a>:是指在代码执行时，JavaScript引擎创建的一种数据结构，它包含了函数执行时的状态信息，例如变量、函数参数、函数返回值等。</p><p>在以下三种情况下会创建执行上下文</p><ol><li><p>JavaScript执行全局代码时，创建<strong>全局执行上下文</strong></p></li><li><p>调用函数时，创建<strong>函数执行上下文</strong></p></li><li><p>使用 eval 函数时，创建<strong>执行上下文</strong></p><ol><li>给他一个字符串,解析为js并执行</li></ol></li></ol><p>我们通过调试工具确认一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funA</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funcB</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="title function_">funA</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> res + c</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="title function_">funcB</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 执行函数时，创建对应执行上下文，内部保存变量，代码等一系列执行函数需要的东西</span></span><br><span class="line"><span class="comment">// 进入JS调用堆栈，执行 ==&gt; 执行完毕之后 =&gt; 出栈</span></span><br><span class="line"><span class="comment">// 所有代码执行完毕为止</span></span><br></pre></td></tr></table></figure><p><strong>调用栈:</strong></p><ol><li>执行上下文会存在JS调用栈中,栈的结构特点是:<strong>先进后出</strong></li></ol><p><img src="https://bu.dusays.com/2023/08/19/64e0ca6fa8242.png" alt="image-20230706133635838.png"></p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈的容量是有限的,如果内部的内容一直得不到释放,就会出现栈溢出,比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈溢出，JS调用栈有容量大小，太大了，会溢出</span></span><br><span class="line"><span class="comment">// JS调用堆栈装满了之后，就会出现</span></span><br><span class="line"><span class="comment">// Maximum call stack size exceeded</span></span><br><span class="line"><span class="comment">// 日常开发常见的：</span></span><br><span class="line"><span class="comment">// 1. 死递归</span></span><br><span class="line"><span class="comment">// 2. 导航守卫</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  i++</span><br><span class="line">  <span class="title function_">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/19/64e0ca7057592.png" alt="image-20230708104801552.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><img src="https://bu.dusays.com/2023/08/19/64e0a7aa72c29.png" alt="设计模式1.png"><br><img src="https://bu.dusays.com/2023/08/19/64e0de1ab6975.png" alt="设计模式2.png"><br><img src="https://bu.dusays.com/2023/08/19/64e0de18eb2b5.png" alt="设计模式3.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://wangdoc.com/es6/">阮一峰-《ECMAScript 6 教程》</a></li><li><a href="https://www.ituring.com.cn/book/2472">图灵社区-JavaScript高级程序设计</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原理二</title>
      <link href="/posts/882eae5.html"/>
      <url>/posts/882eae5.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>Currying 又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p> 柯里化 作为一种高阶技术, 可以提升函数的复用性和灵活性。</p><h3 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h3><p>函数柯里化 (Currying) 是一种<strong>将多个参数的函数转换为单个参数函数</strong>的技术</p><p>转换完毕之后的函数:<strong>只传递函数的一部分参数来调用，让他返回一个新的函数去处理剩下的参数。</strong></p><p><strong>例子:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整函数 sum</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写为 可以实现如下效果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>))<span class="comment">// </span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><code>sum</code>改为接收一个参数，返回一个新函数</li><li>新函数内部将<strong>参数1</strong>，<strong>参数2</strong>累加并返回</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化面试题-全局变量"><a href="#柯里化面试题-全局变量" class="headerlink" title="柯里化面试题-全局变量"></a>柯里化面试题-全局变量</h3><p>柯里化在面试的时候一般以笔试题出现,比如</p><p><strong>需求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改写函数sum实现:参数传递到5个即可实现累加</span></span><br><span class="line"><span class="comment">// sum(1)(2)(3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3,4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4,5)</span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>接收不定长参数</li><li>存储已传递的参数</li><li>判断长度<ol><li>满足5:累加</li><li>不满足:继续返回<strong>函数本身</strong></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存参数</span></span><br><span class="line"><span class="keyword">let</span> nums = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currySum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 将传入的参数 保存到数组中</span></span><br><span class="line">  nums.<span class="title function_">push</span>(...args)</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curv</span>) =&gt;</span> prev + curv, <span class="number">0</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currySum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化面试题-使用闭包"><a href="#柯里化面试题-使用闭包" class="headerlink" title="柯里化面试题-使用闭包"></a>柯里化面试题-使用闭包</h3><p><strong>需求:</strong></p><ol><li>使用<strong>闭包</strong>将上一节代码中的全局变量,保护起来</li><li>支持自定义累加的参数个数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMaker</span>(<span class="params">length</span>)&#123;</span><br><span class="line">    <span class="comment">// 逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支持5个累加</span></span><br><span class="line"><span class="keyword">const</span> sum5 = <span class="title function_">sumMaker</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 支持7个累加</span></span><br><span class="line"><span class="keyword">const</span> sum7 = <span class="title function_">sumMaker</span>(<span class="number">7</span>)</span><br><span class="line"><span class="title function_">sum7</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义外层函数:<ol><li>定义参数<code>length</code></li><li>将全局变量迁移到函数内</li></ol></li><li>定义内层函数:<ol><li>参数长度判断,使用传入的参数<code>length</code></li><li>直接复用上一节的逻辑,并返回</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMaker</span>(<span class="params">length</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> nums = []</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="comment">// 将传递的参数保存到数组中</span></span><br><span class="line">    nums.<span class="title function_">push</span>(...args)</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">        <span class="comment">// 累加 并返回</span></span><br><span class="line">      <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curv</span>) =&gt;</span> prev + curv, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> inner</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持5个累加</span></span><br><span class="line"><span class="keyword">const</span> sum5 = <span class="title function_">sumMaker</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum5</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 支持7个累加</span></span><br><span class="line"><span class="keyword">const</span> sum7 = <span class="title function_">sumMaker</span>(<span class="number">7</span>)</span><br><span class="line"><span class="title function_">sum7</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h3 id="柯里化实际应用-类型判断"><a href="#柯里化实际应用-类型判断" class="headerlink" title="柯里化实际应用-类型判断"></a>柯里化实际应用-类型判断</h3><p>通过<strong>参数复用</strong>,实现一个<strong>类型判断生成器函数</strong></p><p><strong>需求:</strong></p><ol><li>将下列4个类型判断函数,改写为通过函数<code>typeOfTest</code>动态生成</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有如下4个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUndefined</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFunction</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> thing === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为通过 typeOfTest 生成:</span></span><br><span class="line"><span class="keyword">const</span> typeOfTest =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="comment">// 参数 和 逻辑略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isUndefined = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;number&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isString = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="title function_">typeOfTest</span>(<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过 isUndefined,isNumber,isString,isFunction 来判断类型:</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">isUndefined</span>(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isNumber</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">isString</span>(<span class="string">&#x27;memeda&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isFunction</span>(<span class="function">() =&gt;</span> &#123; &#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><code>typeOfTest</code>接收参数<code>type</code>用来接收判断的类型</li><li>内部返回新函数,接收需要判断的值,并基于<code>type</code>进行判断</li><li>使用箭头函数改写为最简形式~~<a href="https://github.com/axios/axios/blob/v1.x/lib/utils.js#L20">传送门</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">typeOfTest</span> = type =&gt; <span class="function"><span class="params">thing</span> =&gt;</span> <span class="keyword">typeof</span> thing === type  </span><br></pre></td></tr></table></figure><h3 id="柯里化实际应用-固定参数"><a href="#柯里化实际应用-固定参数" class="headerlink" title="柯里化实际应用-固定参数"></a>柯里化实际应用-固定参数</h3><p>依旧是一个<strong>参数复用</strong>的实际应用</p><p><strong>需求:</strong></p><ol><li>将如下3个请求的函数(都是<strong>post</strong>请求),变为通过<code>axiosPost</code>函数动态生成</li><li>实现函数<code>axiosPost</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将如下3个请求,改写为调用 axiosPost函数即可实现</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;url1&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;url3&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">axiosPost</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 参数,逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axiosPost</span>(<span class="string">&#x27;url1&#x27;</span>, data1)</span><br><span class="line"><span class="title function_">axiosPost</span>(<span class="string">&#x27;url2&#x27;</span>, data2)</span><br><span class="line"><span class="title function_">axiosPost</span>(<span class="string">&#x27;url3&#x27;</span>, data3)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>函数内部固定请求方法,post</li><li>函数内部调用<code>axios</code>发请求即可</li><li><code>axios</code>内部就是这样实现的<a href="https://github.com/axios/axios/blob/v1.x/dist/axios.js#L2667">传送门:</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">axiosPost</span> = (<span class="params">url, data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    url, data,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结:</p><ol><li><p>函数柯里化是一种函数式编程思想:<strong>将多个参数的函数转换为单个参数函数,调用时返回新的函数接收剩余参数</strong></p></li><li><p>常见面试题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改写函数sum实现:参数传递到5个即可实现累加</span></span><br><span class="line"><span class="comment">// sum(1)(2)(3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3,4)(5)</span></span><br><span class="line"><span class="comment">// sum(1)(2,3)(4,5)</span></span><br></pre></td></tr></table></figure></li><li><p>常见应用:固定参数,比如<code>axios</code>中的:</p><ol><li><a href="https://github.com/axios/axios/blob/v1.x/lib/utils.js#L20">类型判断函数</a></li><li><a href="https://github.com/axios/axios/blob/v1.x/dist/axios.js#L2667">get,post,put等别名方法</a></li></ol></li></ol><h2 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h2><ol><li>实现Promise的核心用法</li><li>Promise的静态方法</li><li>实现Promise的静态方法</li></ol><p>首先明确Promise的核心用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// reject(&#x27;error&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法的参数1: 状态为成功的回调函数</span></span><br><span class="line"><span class="comment">// then方法的参数2: 状态为失败的回调函数</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手写Promise-构造函数"><a href="#手写Promise-构造函数" class="headerlink" title="手写Promise-构造函数"></a>手写Promise-构造函数</h3><p><strong>需求:</strong></p><ol><li>实现MyPromise类，可以用如下的方式实例化</li><li>实例化时传入回调函数<ol><li>回调函数立刻执行</li><li>回调函数接收函数<code>resolve</code>和<code>reject</code></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve() </span></span><br><span class="line">  <span class="comment">// reject() </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义类<code>MyPromise</code></li><li>实现构造函数，接收<code>executor</code>–传入的回调函数</li><li>构造函数中定义<code>resolve</code>和<code>reject</code>并传入<code>executor</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 构造函数 </span></span><br><span class="line">  <span class="comment">// executor 执行器，实例化时立刻调用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 3. 定义 resolve reject 传入executor</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve-call&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject-call&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/17/64de3335713d9.png" alt="promise1.png"></p><h3 id="手写Promise-状态、成功or失败原因"><a href="#手写Promise-状态、成功or失败原因" class="headerlink" title="手写Promise-状态、成功or失败原因"></a>手写Promise-状态、成功or失败原因</h3><p><strong>需求:</strong></p><ol><li><code>MyPromise</code>增加<code>state</code>属性，只能是如下3个值<ol><li><code>pending</code>:待定，默认状态</li><li><code>fulfilled</code>:已兑现，操作成功</li><li><code>rejected</code>:已拒绝，操作失败</li></ol></li><li><code>MyPromise</code>增加<code>result</code>属性，记录成功&#x2F;失败原因</li><li>调用<code>resolve</code>或<code>reject</code>,修改状态,并记录成功&#x2F;失败原因</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;成功结果&#x27;)</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;失败原因&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义常量保存状态，避免<strong>硬编码</strong></li><li><code>MyPromise</code>中定义<ol><li>属性:<code>state</code>保存状态，<code>result</code>成功&#x2F;失败原因</li><li>修改<code>state</code>的私有方法，修改状态并记录<code>result</code></li><li>注意:<code>state</code>只有在<code>pending</code>时，才可以修改，且不可逆</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义常量保存状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 定义属性 state（状态） reason（成功/失败原因）</span></span><br><span class="line">  state = <span class="variable constant_">PENDING</span>  <span class="comment">// 默认状态</span></span><br><span class="line">  result = <span class="literal">undefined</span>  <span class="comment">// 成功或失败的原因 默认不知道</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 3. 实现 resolve和reject内部逻辑</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// if(this.state !== PENDING) &#123;</span></span><br><span class="line">        <span class="comment">//     return 如果状态不是等待，后面不执行 状态确定就不能改变</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// this.state = FULFILLED</span></span><br><span class="line">        <span class="comment">// this.result = result</span></span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 提取resolve和reject内部公共逻辑</span></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/17/64de3335a27f7.png" alt="promise2.png"></p><h3 id="手写Promise-then方法的核心功能"><a href="#手写Promise-then方法的核心功能" class="headerlink" title="手写Promise-then方法的核心功能"></a>手写Promise-then方法的核心功能</h3><p><strong>需求:</strong></p><ol><li>then方法的回调函数1: 状态变为<code>fulfilled</code>时触发，并获取成功结果</li><li>then方法的回调函数2: 状态变为<code>rejected</code>时触发，并获取失败原因</li><li>then方法的回调函数1或2没有传递的特殊情况处理，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#%E5%8F%82%E6%95%B0">参考:then方法的参数</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;成功结果&#x27;)</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;失败原因&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>增加<code>then</code>方法，根据不同的状态执行对应的回调函数，并传入<code>result</code><ol><li>参数1:成功的回调函数</li><li>参数2:失败的回调函数</li></ol></li><li>没有传递<code>onFulfilled</code>,<code>onRejected</code>时，设置默认值(参考文档)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 增加then方法，根据不同的状态执行对应的回调函数</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 处理未传入回调函数的特殊情况</span></span><br><span class="line">      <span class="comment">// 如果不是函数，设置为一个 接受一个参数，直接返回该参数的函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line">      <span class="comment">// 不是函数，设置一个为 接收一个参数，使用 throw 抛出的函数</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 根据状态，调用不同的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功的状态</span></span><br><span class="line">        <span class="comment">// 调用对应的回调函数，并传递结果</span></span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/17/64de33344950c.png" alt="promise3.png"></p><h3 id="手写Promise-then方法支持异步和多次调用（非链式）"><a href="#手写Promise-then方法支持异步和多次调用（非链式）" class="headerlink" title="手写Promise-then方法支持异步和多次调用（非链式）"></a>手写Promise-then方法支持异步和多次调用（非链式）</h3><p><strong>需求:</strong></p><ol><li>实例化传入的回调函数,内部支持异步操作</li><li>then方法支持多次调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;成功结果&#x27;)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;失败原因&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success1:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error1:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success2:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error2:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success3:&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error3:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义属性,保存传入的回调函数:[]</li><li>调用<code>then</code>方法并且状态为<code>pending</code>时保存传入的成功&#x2F;失败回调函数</li><li>调用<code>resolve</code>和<code>reject</code>时执行上一步保存的回调函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 1. 添加handlers属性保存then方法添加的回调函数</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="comment">// 调用保存在handlers中的回调函数</span></span><br><span class="line">      <span class="comment">// 从开头部分取出回调函数执行</span></span><br><span class="line">      <span class="comment">// while(this.handlers.length &gt; 0) &#123;</span></span><br><span class="line">      <span class="comment">//    通过解构获取对应的回调函数</span></span><br><span class="line">      <span class="comment">//    const &#123; onFulfilled &#125; = this.handlers.shift()</span></span><br><span class="line">      <span class="comment">//    onFulfilled(this.result)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 4. 调用runHandlers 执行回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="comment">// 4. 调用runHandlers 执行回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 抽取方法 执行 fulfilled/rejected状态时的回调函数</span></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">          <span class="comment">// 成功</span></span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 失败</span></span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 状态为 pending 时,状态还没改变，回调函数还不能执行，将回调函数添加到数组中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        onFulfilled, onRejected</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-链式编程-成功状态-普通返回值"><a href="#手写Promise-链式编程-成功状态-普通返回值" class="headerlink" title="手写Promise-链式编程-成功状态+普通返回值"></a>手写Promise-链式编程-成功状态+普通返回值</h3><p><strong>需求:</strong></p><ol><li><code>then</code>的链式编程</li><li>目前只考虑<code>resolve</code>内部返回普通值的情况</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>调整<code>then</code>方法，返回一个新的<code>MyPromise</code>对象</li><li>内部获取<code>onFulfilled</code>的执行结果,传入<code>resolve</code>方法继续执行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="comment">// 1. 创建并返回新的Promise对象</span></span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">          <span class="comment">// 成功状态</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        <span class="comment">// 2. 继续调用resolve方法 then方法返回的Promise对象的resolve</span></span><br><span class="line">        <span class="comment">// 传递成功的结果给下一个 then</span></span><br><span class="line">        <span class="title function_">resolve</span>(res)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/18/64df4c7cc60ec.png" alt="promise4.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7da4b18.png" alt="promise5.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7569adf.png" alt="promise6.png"></p><h3 id="手写Promise-链式编程-成功状态-返回Promise"><a href="#手写Promise-链式编程-成功状态-返回Promise" class="headerlink" title="手写Promise-链式编程-成功状态+返回Promise"></a>手写Promise-链式编程-成功状态+返回Promise</h3><p><strong>需求:</strong></p><ol><li><code>then</code>的链式编程</li><li>目前考虑<code>resolve</code>内部返回<code>MyPromise</code>的情况</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>内部获取<code>onFulfilled</code>的执行结果:</li><li>如果是<code>MyPromise</code>实例，继续<code>then</code>下去并传入<code>resolve</code>和<code>reject</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        <span class="comment">// 1. 判断是否为MyPromise的实例</span></span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// 2. 继续调用then方法 传入 resolve 和 reject</span></span><br><span class="line">          res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/18/64df4c7a1e191.png" alt="promise7.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7b1b34c.png" alt="promise8.png"></p><p><img src="https://bu.dusays.com/2023/08/18/64df4c7da8e76.png" alt="promise9.png"></p><h3 id="手写Promise-链式编程-失败状态"><a href="#手写Promise-链式编程-失败状态" class="headerlink" title="手写Promise-链式编程-失败状态"></a>手写Promise-链式编程-失败状态</h3><p><strong>需求:</strong></p><ol><li><code>then</code>的第二个回调函数，执行<code>reject</code>时的链式编程</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>参考<code>resolve</code>的逻辑</li><li>先实现功能,再抽取为函数直接调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">// const res = onFulfilled(this.result)</span></span><br><span class="line">        <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">        <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//   resolve(res)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 参考成功状态的逻辑实现 失败状态</span></span><br><span class="line">        <span class="comment">// const res = onRejected(this.result)</span></span><br><span class="line">        <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">        <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//   reject(res)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 抽取 then中的逻辑，并替换掉原本代码</span></span><br><span class="line">  #<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">     <span class="comment">// 调用回调函数 获取执行的结果</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>) </span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">        <span class="comment">// res 是promise对象 then 方法</span></span><br><span class="line">      res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-链式编程-支持异步"><a href="#手写Promise-链式编程-支持异步" class="headerlink" title="手写Promise-链式编程-支持异步"></a>手写Promise-链式编程-支持异步</h3><p><strong>需求:</strong></p><ol><li>执行异步操作时，支持链式编程</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">    .<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>then的内部将<code>resolve</code>,<code>reject</code>也推送到数组中</li><li>调整<code>runHandlers</code>函数，内部直接调用<code>runPromise</code>函数即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span></span><br><span class="line">  result = <span class="literal">undefined</span></span><br><span class="line">  handlers = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 2. 解构出resolve,reject执行和上一步一样的逻辑</span></span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 将 resolve和reject也推送到数组中</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulfilled, onRejected, resolve, reject</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-使用微任务"><a href="#手写Promise-使用微任务" class="headerlink" title="手写Promise-使用微任务"></a>手写Promise-使用微任务</h3><p><strong>需求:</strong></p><ol><li>如下代码打印结果为<code>1,2,4,3</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>使用<code>queueMicrotask</code>包裹<code>runPromise</code>的内部逻辑即可</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask">传送门:MDN-queueMicrotask</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">传送门:MDN-queueMicrotask使用指南</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 使用queueMicrotask 包裹内部逻辑即可</span></span><br><span class="line">  <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><p>手写<code>Promise</code>的核心代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存状态的常量 避免后续 硬编码（代码中写死某个值）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义类 后续new实例化</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">      <span class="comment">// 状态</span></span><br><span class="line">      state = <span class="variable constant_">PENDING</span></span><br><span class="line">      <span class="comment">// 成功、失败原因 结果</span></span><br><span class="line">      result = <span class="literal">undefined</span> <span class="comment">// 成功或失败的原因 默认不知道</span></span><br><span class="line">      <span class="comment">// 待执行的回调函数 异步的回调函数 [&#123; onFulfilled,onRejected,resolve,reject &#125;]</span></span><br><span class="line">      handlers = []</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造函数 resolve定义 reject定义 执行传入的回调函数</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;  <span class="comment">// 接收 new MyPromise((resolve,reject)=&gt; &#123;console.log(&#x27;立刻执行&#x27;)&#125; ) 传进来的回调函数，然后 resolve，reject 传给回调函数executor</span></span><br><span class="line">        <span class="comment">// 定义 resolve和reject</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 抽取封装 #changeState</span></span><br><span class="line">        <span class="comment">// if(this.state !== PENDING) &#123;</span></span><br><span class="line">        <span class="comment">//     return 如果状态不是等待，后面不执行 状态确定就不能改变</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// this.state = FULFILLED</span></span><br><span class="line">        <span class="comment">// this.result = result</span></span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">FULFILLED</span>, result)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 调用保存在handlers中的回调函数</span></span><br><span class="line">          <span class="comment">// 从开头部分取出回调函数执行</span></span><br><span class="line">          <span class="comment">// while(this.handlers.length &gt; 0) &#123;</span></span><br><span class="line">          <span class="comment">//    通过解构获取对应的回调函数</span></span><br><span class="line">          <span class="comment">//    const &#123; onFulfilled &#125; = this.handlers.shift()</span></span><br><span class="line">          <span class="comment">//    onFulfilled(this.result)</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 调用runHandlers 执行回调函数</span></span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">result</span>) =&gt; &#123;</span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">changeState</span>(<span class="variable constant_">REJECTED</span>, result)</span><br><span class="line">          <span class="variable language_">this</span>.#<span class="title function_">runHandlers</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收传入的执行器，接收定义的resolve和reject</span></span><br><span class="line">        <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据状态执行回调函数的 私有方法</span></span><br><span class="line">      <span class="comment">// 执行回调函数，取出数组中的回调函数，执行到没有为止 用shift()开头弹出</span></span><br><span class="line">      #<span class="title function_">runHandlers</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 循环执行到数组长度为0为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 2. 解构出resolve,reject执行和上一步一样的逻辑</span></span><br><span class="line">          <span class="keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">shift</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;  <span class="comment">// this.state = &#x27;fulfilled&#x27;硬编码</span></span><br><span class="line">          <span class="comment">// 成功 执行 和 then 中类似的逻辑</span></span><br><span class="line">          <span class="comment">// 获取结果，根据是否为Promise以及状态调用对应的逻辑</span></span><br><span class="line">          <span class="comment">// onFulfilled(this.result)</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line">            <span class="comment">// onRejected(this.result)</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//提取resolve，reject内部公共逻辑  修改状态的（pending时才可以修改，执行到没有为止） 私有方法</span></span><br><span class="line">      #<span class="title function_">changeState</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// then方法，接收成功和失败的回调函数 根据不同的状态执行对应的回调函数</span></span><br><span class="line">      <span class="comment">// 链式编程 promise对象.then(xxx).then(xxx)</span></span><br><span class="line">      <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled 和 onRejected 的非空判断</span></span><br><span class="line">        <span class="comment">// 处理未传入回调函数的特殊情况</span></span><br><span class="line">        <span class="comment">// 如果不是函数，设置为一个 接受一个参数，直接返回该参数的函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">        <span class="comment">// 不是函数，设置一个为 接收一个参数，使用 throw 抛出的函数</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证链式编程，返回Promise</span></span><br><span class="line">        <span class="comment">// 创建一个新的Promise对象 并返回</span></span><br><span class="line">        <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//  根据状态，调用不同的回调函数</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="comment">// const res = onFulfilled(this.result)</span></span><br><span class="line">            <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">            <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//   resolve(res)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 抽取封装逻辑</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onFulfilled, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">             <span class="comment">//  参考成功状态的逻辑实现 失败状态</span></span><br><span class="line">             <span class="comment">// const res = onRejected(this.result)</span></span><br><span class="line">             <span class="comment">// if (res instanceof MyPromise) &#123;</span></span><br><span class="line">             <span class="comment">//   res.then(resolve, reject)</span></span><br><span class="line">             <span class="comment">// &#125; else &#123;</span></span><br><span class="line">             <span class="comment">//   reject(res)</span></span><br><span class="line">             <span class="comment">// &#125;</span></span><br><span class="line">            <span class="variable language_">this</span>.#<span class="title function_">runPromise</span>(onRejected, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 状态为 pending 时,状态还没改变，回调函数还不能执行，将回调函数添加到数组中</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">              <span class="comment">//  将 resolve和reject也推送到数组中</span></span><br><span class="line">              onFulfilled, onRejected, resolve, reject</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> p2</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 满足执行条件，执行回调函数的 私有方法</span></span><br><span class="line">      #<span class="title function_">runPromise</span>(<span class="params">callback, resolve, reject</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用微任务队列</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 调用回调函数 获取执行的结果</span></span><br><span class="line">          <span class="keyword">const</span> res = <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">          <span class="comment">// 判断是否为MyPromise的实例</span></span><br><span class="line">          <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">            <span class="comment">// res 是Promise对象 then 方法</span></span><br><span class="line">            <span class="comment">// 继续调用then方法 传入 resolve 和 reject</span></span><br><span class="line">            res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是普通的值，直接resolve</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span> ? <span class="title function_">resolve</span>(res) : <span class="title function_">reject</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/18/64df78c8b6ed3.png" alt="promise10.png"><br><img src="https://bu.dusays.com/2023/08/18/64df78c8e2db3.png" alt="promise11.png"></p><h3 id="手写Promise-实例方法catch"><a href="#手写Promise-实例方法catch" class="headerlink" title="手写Promise-实例方法catch"></a>手写Promise-实例方法catch</h3><p><strong>需求:</strong></p><ol><li>实现实例方法<code>catch</code>,可以实现如下调用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">文档</a>,catch等同于:<code>then(undefined,onRjected)</code></li><li>直接添加<code>catch</code>方法，内部调用<code>then</code></li><li>使用<code>try-catch</code>包裹<code>runPromise</code>,出错时,调用<code>reject</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加catch方法，内部参考文档的方式调用then即可 </span></span><br><span class="line"><span class="comment">// 实例方法：catch 本质  then(undefined, onRjected)</span></span><br><span class="line"><span class="keyword">catch</span>(onRjected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRjected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数执行结果</span></span><br><span class="line">  #<span class="title function_">runPromise</span>(<span class="params">callBack, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，通过 reject 继续传递</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回调函数 获取执行的结果</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">callBack</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// res是Promise对象 then方法</span></span><br><span class="line">          res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果是普通的值,直接resolve</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="手写Promise-实例方法finally"><a href="#手写Promise-实例方法finally" class="headerlink" title="手写Promise-实例方法finally"></a>手写Promise-实例方法finally</h3><p><strong>需求:</strong></p><ol><li>无论成功失败都会执行<code>finally</code>的回调函数</li><li>回调函数不接受任何参数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally执行啦&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally">文档</a>:finally方法类似于调用<code>then(onFinally,onFinally)</code>,且不接受任何回调函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例方法：finally</span></span><br><span class="line"><span class="title function_">finally</span>(<span class="params">onFinally</span>) &#123;</span><br><span class="line">    <span class="comment">// 将传入的回调函数，作为成功/失败的回调函数</span></span><br><span class="line">    <span class="comment">// 成功/失败都会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(onFinally,onFinally)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法resolve"><a href="#手写Promise-静态方法resolve" class="headerlink" title="手写Promise-静态方法resolve"></a>手写Promise-静态方法resolve</h3><p><strong>需求:</strong></p><ol><li>返回一个带有成功原因的<code>Promise</code>对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个值为2的Promise对象</span></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 直接返回传入的p</span></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>增加静态方法<code>resolve</code>，根据传入的值返回不同的结果即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 静态方法 resolve</span></span><br><span class="line">  <span class="comment">// 根据传入的值，返回不同的结果即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是Promise 返回Promise，后续即可链式调用</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果都不是的话，直接返回一个新的Promise对象 将value传递给resolve</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法reject"><a href="#手写Promise-静态方法reject" class="headerlink" title="手写Promise-静态方法reject"></a>手写Promise-静态方法reject</h3><p><strong>需求:</strong></p><ol><li>返回一个带有拒绝原因的<code>Promise</code>对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>添加静态方法内部返回有拒绝原因的<code>Promise</code>对象即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个两个方法在axios拦截器里可以发现到。</p><h3 id="手写Promise-静态方法race"><a href="#手写Promise-静态方法race" class="headerlink" title="手写Promise-静态方法race"></a>手写Promise-静态方法race</h3><p><strong>需求:</strong></p><ol><li>接收Promise数组<ol><li>第一个Promise成功或失败时，返回一个该Promise对象及原因</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">race</span>([promise1, promise2]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>,value)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>内部返回新的Promise对象:<ol><li>参数判断:<ol><li>不是数组:报错</li><li>是数组:挨个解析<ol><li>任意一个Promise对象成功或失败，直接resolve或reject即可</li></ol></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="comment">// race的后面需要 .then.catch</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验 传入的是数组才继续执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的promises是空数组，则返回的promise就将永远等待</span></span><br><span class="line">      promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Promise.resolve进行处理，只要有任何一个为 成功/拒绝 即可响应结果</span></span><br><span class="line">        <span class="comment">// MyPromise.resolve 传入的无论是不是Promise--&gt;都变成Promise</span></span><br><span class="line">        <span class="comment">// 如果不处理的话，传入普通的值，会直接报错</span></span><br><span class="line">        <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 参数错误</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法all"><a href="#手写Promise-静态方法all" class="headerlink" title="手写Promise-静态方法all"></a>手写Promise-静态方法all</h3><p><strong>需求:</strong></p><ol><li>接收Promise数组，<ol><li>所有Promise都成功时，返回一个成功的Promise对象及成功数组</li><li>任何一个Promise失败，返回一个失败的Promise对象及第一个失败原因</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><p>包裹一个新的Promise并返回，内部进行参数校验</p><ol><li><p>非数组:报错</p></li><li><p>数组:循环挨个解析</p><ol><li><p>长度为0:直接返回成功状态的Promise</p></li><li><p>长度不为0:挨个解析:forEach</p><ol><li><p>不是Promise对象:直接记录结果并判断是否解析完毕</p></li><li><p>是Promise对象:调用then</p><ol><li>成功:记录结果并判断是否解析完毕</li><li>失败:直接reject</li></ol></li></ol></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="comment">// 本质：外部可以 then catch</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 参数校验</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">       <span class="comment">// 是数组再继续执行</span></span><br><span class="line">       <span class="comment">// 存储结果</span></span><br><span class="line">       <span class="keyword">const</span> result = []</span><br><span class="line">       <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 记录结果的个数，判断是否完结</span></span><br><span class="line">       <span class="comment">// 如果长度为0 直接返回 fulfilled状态的Promise即可</span></span><br><span class="line">       <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">resolve</span>(promises)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 挨个处理</span></span><br><span class="line">       promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果是Promise</span></span><br><span class="line">           item.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">             count++</span><br><span class="line">             <span class="comment">// 这么做的目的是保证 结果的顺序 和 promise每一项的一致</span></span><br><span class="line">             result[index] = res</span><br><span class="line">             count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">           &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 任何一个失败 无视其他的promise直接 reject即可</span></span><br><span class="line">             <span class="title function_">reject</span>(err)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果不是Promise 原样添加在数组中</span></span><br><span class="line">           count++</span><br><span class="line">           result[index] = item</span><br><span class="line">           <span class="comment">// 全部处理完毕时，响应结果</span></span><br><span class="line">           count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">       <span class="comment">// 错误提示</span></span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法allSettled"><a href="#手写Promise-静态方法allSettled" class="headerlink" title="手写Promise-静态方法allSettled"></a>手写Promise-静态方法allSettled</h3><p><strong>需求:</strong></p><ol><li>传入Promise数组，当所有对象都已敲定时</li><li>返回一个新的Promise对象及以数组形式保存的结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取传入的Promise数组 的 敲定状态 和结果</span></span><br><span class="line"><span class="comment">// 包装到对象中 &#123; value：&#x27;成功的值&#x27; , reason: &#x27;失败原因&#x27; , status: &#x27;状态&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).</span><br><span class="line">  <span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(results) &#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>增加静态方法<code>allSettled</code></li><li>内部逻辑和<code>all</code>类似，需要特别注意的地方:<ol><li>成功和失败的原因都会通过对象记录起来</li><li>返回一个记录了成功<code>&#123;state:FULFILLED,value:&#39;xxx&#39;&#125;</code>失败<code>&#123;state:REJECTED,reason:&#39;xxx&#39;&#125;</code>的结果数组</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 参数校验</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">         <span class="keyword">let</span> result = []<span class="comment">// 结果数组</span></span><br><span class="line">         <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 计数器</span></span><br><span class="line">         <span class="comment">// 空数组直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(promises)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 挨个处理内部的Promise对象</span></span><br><span class="line">         promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="comment">// 使用resolve转为promise统一处理</span></span><br><span class="line">           <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 成功状态</span></span><br><span class="line">             count++</span><br><span class="line">             result[index] = &#123;</span><br><span class="line">               <span class="attr">state</span>: <span class="variable constant_">FULFILLED</span>,</span><br><span class="line">               value</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 处理完毕之后 resolve</span></span><br><span class="line">             count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">           &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 失败状态</span></span><br><span class="line">             count++</span><br><span class="line">             <span class="comment">// 失败状态 值为 reason</span></span><br><span class="line">             result[index] = &#123;</span><br><span class="line">               <span class="attr">state</span>: <span class="variable constant_">REJECTED</span>,</span><br><span class="line">               reason</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 成功和失败最终都对应到 resolve</span></span><br><span class="line">             count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 不是数组，报错</span></span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="手写Promise-静态方法any"><a href="#手写Promise-静态方法any" class="headerlink" title="手写Promise-静态方法any"></a>手写Promise-静态方法any</h3><p><strong>需求:</strong>-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any">传送门</a></p><ol><li>传入<code>Promise</code>数组，<ol><li>任何一个<code>Promise</code>对象敲定时，返回一个新的<code>Promise</code>对象，及对应的结果</li><li>所有Promise都被拒绝时，返回一个包含所有拒绝原因的<code>AggregateError</code>错误数组</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;success1&#x27;)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error3&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">any</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>类似于<code>all</code>核心区别<ol><li>数组长度为0，直接返回错误数组</li><li>任何一个成功，直接成功</li><li>通过数组记录失败原因，都失败时响应错误</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">      <span class="keyword">let</span> errors = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="comment">// AggregateError包含多个错误对象的 单个错误对象（错误对象容器）</span></span><br><span class="line">      <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(<span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 挨个处理</span></span><br><span class="line">      promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 只要一个成功 就成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(value)</span><br><span class="line">        &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          count++</span><br><span class="line">          errors.<span class="title function_">push</span>(reason)</span><br><span class="line">          <span class="comment">// 如果没有一个promise成功 就把所有的错误原因合并到一起 一起抛出</span></span><br><span class="line">          count++ === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(errors))</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 参数格式有误</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Argument is not iterable&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise需要掌握的点："><a href="#promise需要掌握的点：" class="headerlink" title="promise需要掌握的点："></a>promise需要掌握的点：</h3><ol><li><p>组织异步，回调函数 &#x3D;&gt; 链式编程</p></li><li><p>async await : await会等待后面Promise成功，并获取结果，try-catch捕获异常</p></li><li><p>多个异步管理：</p><ol><li><p>all ：都成功，第一个失败</p></li><li><p>race：第一个成功或失败</p></li><li><p>allSettled: 所有都敲定（成功&#x2F;失败），以对象数组的形式获取结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;成功原因&#x27;</span>,</span><br><span class="line">        <span class="attr">status</span>:<span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">reason</span>: <span class="string">&#x27;失败原因&#x27;</span></span><br><span class="line">        <span class="attr">status</span>:<span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>any : 第一个成功，或者都失败</p></li><li><p><strong>被追问</strong>：用在哪里：</p><ol><li><p>all：多个接口数据，获取完毕再渲染</p></li><li><p>race: 多个服务器的相同接口，都可以获取同一份数据，为了让用户尽可能的拿到结果，race调用相同的多个接口，只要拿到就渲染。</p><p>1.服务器1–新闻接口</p><p>2.服务器2–新闻接口</p><p>3.同时调用，哪个先获取到，就直接渲染</p></li><li><p>allSettled,any 了解过代码</p></li></ol></li></ol><p><strong>手写promise</strong></p><ol><li>构造函数：传入回调函数，并接收resolve和reject</li><li>状态和成功&#x2F;失败结果：<ol><li>定义常量保存状态，定义实例属性保存状态和结果</li><li>resolve和reject中修改状态记录结果</li></ol></li><li>then方法<ol><li>多次调用：用数组来保存回调函数</li><li>链式调用：内部返回Promise</li></ol></li><li>实例方法：<ol><li>catch: 本质就是 then(undefined,onRejected)</li><li>finally: 本质 then(onFinally,onFinally)</li></ol></li><li>静态方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 柯里化 </tag>
            
            <tag> 手写Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原理一</title>
      <link href="/posts/882eae.html"/>
      <url>/posts/882eae.html</url>
      
        <content type="html"><![CDATA[<h1 id="JS原理"><a href="#JS原理" class="headerlink" title="JS原理"></a>JS原理</h1><h3 id="知识点自测"><a href="#知识点自测" class="headerlink" title="知识点自测"></a>知识点自测</h3><div class="tabs" id="test"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test-1">call🍧</button><button type="button" class="tab " data-href="test-2">apply🍧</button><button type="button" class="tab " data-href="test-3">bind🍧</button><button type="button" class="tab " data-href="test-4">剩余参数🍧</button><button type="button" class="tab " data-href="test-5">Promise🍧</button><button type="button" class="tab " data-href="test-6">URLSearchParams🍧</button><button type="button" class="tab " data-href="test-7">Object.create🍧</button><button type="button" class="tab " data-href="test-8">Object.assign🍧</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><ol><li>函数的<code>call</code>方法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以指定的this调用函数，并通过 从第二个参数开始依次传递参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">name,drink</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 指向obj  &#123;name: &#x27;kilito&#x27;&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(drink)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call 参数1: this  </span></span><br><span class="line"><span class="comment">//      参数2: 2-n函数的参数</span></span><br><span class="line">func.<span class="title function_">call</span>(obj,<span class="string">&#x27;kilito&#x27;</span>,<span class="string">&#x27;咖啡&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-2"><ol start="2"><li>函数的<code>apply</code>方法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以指定的this调用函数，并通过 数组的形式 传递参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">name,drink</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 指向obj  &#123;name: &#x27;kilito&#x27;&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(drink)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apply 参数1: this</span></span><br><span class="line"><span class="comment">//       参数2: 以数组的形式传入参数</span></span><br><span class="line">func.<span class="title function_">apply</span>(obj,[<span class="string">&#x27;xiaoqing&#x27;</span>,<span class="string">&#x27;咖啡&#x27;</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-3"><ol start="3"><li>函数的<code>bind</code>方法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">food, drink</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// &#123;name: &#x27;kilito&#x27;&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(food)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(drink)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个绑定了this的新函数！</span></span><br><span class="line"><span class="keyword">const</span> bindFunc = func.<span class="title function_">bind</span>(obj, <span class="string">&#x27;花菜&#x27;</span>)</span><br><span class="line"><span class="title function_">bindFunc</span>(<span class="string">&#x27;可乐&#x27;</span>)</span><br><span class="line"><span class="comment">// const bindFunc = func.bind(obj)</span></span><br><span class="line"><span class="comment">// bindFunc(&#x27;花菜&#x27;,可乐&#x27;)</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-4"><ol start="4"><li>剩余参数-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args)<span class="comment">// 以数组的形式获取传入的所有参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(<span class="string">&#x27;西蓝花&#x27;</span>,<span class="string">&#x27;西葫芦&#x27;</span>,<span class="string">&#x27;西洋参&#x27;</span>,<span class="string">&#x27;西芹&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-5"><ol start="5"><li>Promise核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">`成功啦--<span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">`失败啦--<span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-6"><ol start="6"><li>URLSearchParams核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化时支持传入JS对象</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="comment">// toString方法 返回搜索参数组成的字符串，可直接使用在 URL 上。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-7"><ol start="7"><li>Object.create核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将传入的对象作为原型，创建一个新对象（浅拷贝）</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line">clone.<span class="property">name</span> = <span class="string">&#x27;itheima&#x27;</span></span><br><span class="line">clone.<span class="property">foods</span>.<span class="title function_">push</span>(<span class="string">&#x27;西北风&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clone.<span class="property">foods</span> === person.<span class="property">foods</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test-8"><ol start="8"><li>Object.assign核心用法-<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">文档链接</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;rose&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1 目标对象</span></span><br><span class="line"><span class="comment">// 参数2 源对象</span></span><br><span class="line"><span class="comment">// 将源对象的自身属性复制到目标对象，并返回目标对象</span></span><br><span class="line"><span class="keyword">const</span> returnTarget = <span class="title class_">Object</span>.<span class="title function_">assign</span>(son, person)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnTarget === son)<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">name</span>)<span class="comment">// itheima</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">foods</span> === person.<span class="property">foods</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="xmind"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="xmind-1">this🍧</button><button type="button" class="tab " data-href="xmind-2">继承🍧</button><button type="button" class="tab " data-href="xmind-3">class🍧</button><button type="button" class="tab " data-href="xmind-4">fetch🍧</button><button type="button" class="tab " data-href="xmind-5">geneator🍧</button></ul><div class="tab-contents"><div class="tab-item-content active" id="xmind-1"><p><img src="https://bu.dusays.com/2023/08/17/64dda1ff4a71d.png" alt="xmthis.png"></p></div><div class="tab-item-content" id="xmind-2"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a4e42783.png" alt="xmjichen.png"></p></div><div class="tab-item-content" id="xmind-3"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a44529ff.png" alt="xmclass.png"></p></div><div class="tab-item-content" id="xmind-4"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a48a0993.png" alt="xmfetch.png"></p></div><div class="tab-item-content" id="xmind-5"><p><img src="https://bu.dusays.com/2023/08/17/64dd8a435f5dc.png" alt="xmgeneator.png"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="JS中的this"><a href="#JS中的this" class="headerlink" title="JS中的this"></a>JS中的this</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">传送门：MDN-this</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">传送门：MDN-call</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">传送门：MDN-apply</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">传送门：MDN-bind</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">传送门：MDN-箭头函数</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/rest_parameters">传送门：MDN-剩余参数</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">传送门：MDN-Symbol</a></p></blockquote><h3 id="如何确认this指向："><a href="#如何确认this指向：" class="headerlink" title="如何确认this指向："></a>如何确认this指向：</h3><p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p><p><strong>谁调用就是谁，直接调用就是window</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例2</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// person</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// 直接调用就是 window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inner</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// person</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">// window</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">sayHi</span>()</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h3 id="如何改变this指向"><a href="#如何改变this指向" class="headerlink" title="如何改变this指向"></a>如何改变this指向</h3><p>主要有2类改变函数内部<code>this</code>指向的方法：</p><ol><li><p>调用函数并传入具体的<code>this</code>:</p><ol><li><p><code>call</code>:</p><ol><li>参数1:<code>this</code>() （希望this指向谁就传哪个）</li><li>参数2-n:传递给函数的参数</li></ol></li><li><p><code>apply</code>-数组作为参数</p><ol><li>参数1:<code>this</code></li><li>参数2:以数组的形式,传递给函数的参数</li></ol></li></ol></li><li><p>创建绑定<code>this</code>的函数:</p><ol><li>bind:返回一个绑定了<code>this</code>的新函数</li><li>箭头函数:最近的this是谁,就是谁</li></ol></li></ol><p><strong>调用函数并传入具体的this：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcA</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;funcA-调用&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1:&#x27;</span>, p1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2:&#x27;</span>, p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call参数</span></span><br><span class="line"><span class="comment">// 参数1 this值 </span></span><br><span class="line"><span class="comment">// 参数2-参数n 挨个传入函数的参数  </span></span><br><span class="line">funcA.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// apply参数</span></span><br><span class="line"><span class="comment">// 参数1 this值</span></span><br><span class="line"><span class="comment">// 参数2 以数组的形式传入函数的参数</span></span><br><span class="line">funcA.<span class="title function_">apply</span>(obj, [<span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><strong>创建绑定this的函数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcB</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;funcB-调用&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1:&#x27;</span>, p1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2:&#x27;</span>, p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bind参数</span></span><br><span class="line"><span class="comment">// 参数1 this值</span></span><br><span class="line"><span class="comment">// 参数2-参数n 绑定的参数</span></span><br><span class="line"><span class="keyword">const</span> bindFuncB = funcB.<span class="title function_">bind</span>(person, <span class="number">123</span>)</span><br><span class="line"><span class="title function_">bindFuncB</span>(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// student</span></span><br><span class="line">    <span class="comment">// 箭头会从自己作用域链的上一层继承this</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inner</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inner-调用了&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// student 箭头函数中的this，指向所在作用域中的this 沿用上一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inner</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.<span class="title function_">sayHi</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="comment">// 这个大括号没有创建作用域</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// person</span></span><br><span class="line">    <span class="comment">// 箭头会从自己作用域链的上一层继承this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// person</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">     <span class="comment">// 易混淆情况（不要这样写）</span></span><br><span class="line">  <span class="attr">sayHello</span>:<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//person.sayHi()</span></span><br><span class="line">    person.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h3 id="手写call方法"><a href="#手写call方法" class="headerlink" title="手写call方法"></a>手写call方法</h3><p>这一节咱们来实现<code>myCall</code>方法，实际用法和<code>call</code>方法一致，核心步骤有4步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  实现myCall 可以实现如下的调用效果</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1：this</span></span><br><span class="line"><span class="comment">// 参数2-参数n：参数列表 </span></span><br><span class="line">func2.<span class="title function_">myCall</span>(obj2, <span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>如何定义<code>myCall</code>?</li><li>如何让函数内部的<code>this</code>为某个对象？</li><li>如何让<code>myCall</code>接收参数2-参数n?</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>调优<code>myCall</code>？<ol><li>添加到原型上，所有函数均可调用</li><li>通过给对象动态添加属性的方式来指定 this</li><li>…args 剩余参数 实现参数传递</li><li>通过 Symbo 解决了和默认属性重名的问题</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如何定义`myCall`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 如何让函数内部的`this`为某个对象                 // thisArg =&gt; &#123; name:&#x27;kilito&#x27; &#125;</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123; <span class="comment">// 1. 接收原函数的this要指向的对象 thisArg</span></span><br><span class="line">  <span class="comment">// this 是调用myCall的 函数</span></span><br><span class="line">  <span class="comment">// thisArg 指定的this</span></span><br><span class="line">  <span class="comment">// 2.为他添加一个自定义属性，让函数成为他的该属性  &#123; name:&#x27;kilito&#x27;,func: 原函数 &#125; </span></span><br><span class="line">  thisArg.<span class="property">func</span> = <span class="variable language_">this</span> <span class="comment">// 这个this 是原函数（谁调用，this就指向谁）</span></span><br><span class="line">  <span class="comment">// 3.调用并获取结果</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg.<span class="title function_">func</span>()</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">func</span></span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func.myCall(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 如何让`myCall`接收参数2-参数n</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123; <span class="comment">// ...args接受传过来的参数</span></span><br><span class="line">  thisArg.<span class="property">func</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用并获取结果</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg.<span class="title function_">func</span>(...args)  <span class="comment">// 使用展开运算符传入原函数</span></span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">func</span></span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func.myCall(obj,1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 使用`Symbol`调优`myCall`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用Symbol生成唯一标记，避免和原属性冲突</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  <span class="comment">// 给对象动态添加方法 指定为 this</span></span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">func2.<span class="title function_">myCall</span>(obj2, <span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// symbol</span></span><br><span class="line"><span class="comment">// 调用全局函数 Symbol 可以传入标记（可选）</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;kilito&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/16/64dcb002560a2.png" alt="手写call.png"></p><h3 id="手写apply方法"><a href="#手写apply方法" class="headerlink" title="手写apply方法"></a>手写apply方法</h3><p>这一节咱们来实现<code>myApply</code>方法，实际用法和<code>apply</code>方法一致，核心步骤依旧<code>4</code>步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  实现myApply 可以实现如下的调用效果</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1：this</span></span><br><span class="line"><span class="comment">// 参数2：数组形式传入的参数列表</span></span><br><span class="line">func2.<span class="title function_">myApply</span>(obj2, [<span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>如何定义<code>myApply</code>? 函数Function的原型上</li><li>如何让函数内部的<code>this</code>为某个对象？给对象动态增加方法,方法为原函数,通过对象调用即可</li><li>如何让<code>myApply</code>接收数组形式的参数列表? 定义一个参数接收数组即可 形参: args,调用时,…args</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>调优<code>myApply</code>？和原对象的属性重名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如何定义`myApply`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 如何让函数内部的`this`为某个对象</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// 为他添加一个自定义属性，让函数成为他的该属性</span></span><br><span class="line">  thisArg[<span class="string">&#x27;fn&#x27;</span>] = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用并获取结果</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[<span class="string">&#x27;fn&#x27;</span>]()</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[<span class="string">&#x27;fn&#x27;</span>]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 如何让`myApply`接收参数2-参数n</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  thisArg[<span class="string">&#x27;fn&#x27;</span>] = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 调用并获取结果</span></span><br><span class="line">  <span class="comment">// 用... 将args展开传入</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[<span class="string">&#x27;fn&#x27;</span>](...args)</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[<span class="string">&#x27;fn&#x27;</span>]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 使用`Symbol`调优`myApply`</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用Symbol生成唯一标记，避免和原属性冲突</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="comment">// 移除添加的自定义属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="comment">// 返回调用结果</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">func2.<span class="title function_">myApply</span>(obj2, [<span class="string">&#x27;咖啡&#x27;</span>, <span class="string">&#x27;西兰花炒蛋&#x27;</span>])</span><br></pre></td></tr></table></figure><p>小结：手写apply方法</p><ol><li>如何定义<code>myApply</code>? 函数的原型上</li><li>如何让函数内部的<code>this</code>为某个对象？ 动态给对象添加方法,通过对象的方式调用方法</li><li>如何让<code>myApply</code>接收数组形式的参数列表?   形参: args,调用时,…args</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>调优<code>myApply</code>？避免和默认属性重名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">  thisArg[fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisArg[fn](...args)</span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写bind方法"><a href="#手写bind方法" class="headerlink" title="手写bind方法"></a>手写bind方法</h3><p>这一节咱们来实现<code>myBind</code>方法，实际用法和<code>bind</code>方法一致，核心步骤为2步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用bind获取绑定this的新函数，参数1为可乐</span></span><br><span class="line"><span class="keyword">const</span> bindFunc = func.<span class="title function_">bind</span>(obj, <span class="string">&#x27;可乐&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用函数，只需要传递参数2即可</span></span><br><span class="line"><span class="title function_">bindFunc</span>(<span class="string">&#x27;西蓝花炒蛋&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>如何返回一个绑定了<code>this</code>的函数？</li><li>如何实现绑定的参数，及传入的参数合并?</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 如何返回一个绑定了`this`的函数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// myBind函数调用时，this就是函数本身 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过call方法将传入的 thisArg 作为this进行调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">call</span>(thisArg)  <span class="comment">// this 指向 func</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 如何实现绑定的参数，及传入的参数合并</span></span><br><span class="line"><span class="comment">// ...args 接收绑定参数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...args2 接收调用时的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// thisArg 需要指定的this</span></span><br><span class="line">    <span class="comment">// args 调用myBind时传入的参数</span></span><br><span class="line">    <span class="comment">// args2 调用新函数时传入的参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">call</span>(thisArg, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;我是小小黑&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">drink, food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢喝<span class="subst">$&#123;drink&#125;</span>,我爱吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用bind获取绑定this的新函数，参数1为可乐</span></span><br><span class="line"><span class="keyword">const</span> bindFunc = func.<span class="title function_">bind</span>(obj, <span class="string">&#x27;可乐&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用函数，只需要传递参数2即可</span></span><br><span class="line"><span class="title function_">bindFunc</span>(<span class="string">&#x27;西蓝花炒蛋&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/08/16/64dcb004b93cc.png" alt="手写bind.png"></p><p>小结：手写bind方法</p><ol><li>如何返回一个绑定了<code>this</code>的函数？</li><li>如何实现绑定的参数，及传入的参数合并?</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">call</span>(thisArg, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS继承-ES5"><a href="#JS继承-ES5" class="headerlink" title="JS继承-ES5"></a>JS继承-ES5</h2><blockquote><p>这一节咱们来学习如何在JS中实现<strong>继承</strong>，首先看看在ES6之前可以如何实现继承</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">传送门:继承与原型链</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">传送门:继承（计算机科学）</a></p><p><a href="https://www.ituring.com.cn/book/2472">传送门:JavaScript高级程序设计</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">传送门:MDN-Object.create</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">传送门:MDN-Object.assign</a></p></blockquote><p><strong>继承：</strong>继承可以使子类具有父类的各种属性和方法，而不需要再次编写相同的代码</p><p>这一节咱们会学习ES5中常见的继承写法(命令来源于 <strong>《JavaScript高级程序设计》</strong>)</p><ol><li>原型链实现继承</li><li>构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foods</span> = [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayFoods</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foods</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES5-原型链实现继承"><a href="#ES5-原型链实现继承" class="headerlink" title="ES5-原型链实现继承"></a>ES5-原型链实现继承</h3><p><strong>核心步骤：</strong>希望继承谁，就将谁作为原型</p><p><strong>缺点：</strong>父类中的引用数据类型，会被所有子类共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foods</span> = [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayFoods</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foods</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类的实例 作为子类的原型</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">s1.<span class="title function_">sayFoods</span>()<span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">s2.<span class="title function_">sayFoods</span>() <span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 引用数据类型是同一个</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">foods</span> === s2.<span class="property">foods</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s2.<span class="property">foods</span>.<span class="title function_">push</span>(<span class="string">&#x27;西葫芦&#x27;</span>)  <span class="comment">// 会影响到 s1</span></span><br><span class="line"></span><br><span class="line">s2.<span class="title function_">sayFoods</span>()<span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;, &#x27;西葫芦&#x27;]</span></span><br><span class="line">s1.<span class="title function_">sayFoods</span>()<span class="comment">// [&#x27;西蓝花&#x27;, &#x27;西红柿&#x27;, &#x27;西葫芦&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="ES5-构造函数继承"><a href="#ES5-构造函数继承" class="headerlink" title="ES5-构造函数继承"></a>ES5-构造函数继承</h3><p><strong>核心步骤：</strong>在子类的构造函数中通过<code>call</code>或<code>apply</code>父类的构造函数</p><p><strong>缺点：</strong>子类没法使用父类原型上的属性&#x2F;方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name           <span class="comment">// 3. 给传入的 this 设置属性/方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好,我叫:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)  <span class="comment">// 2. this 指向 son 的实例化对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lucy&#x27;</span>)  <span class="comment">// 1. 调用子类构造函数</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;rose&#x27;</span>)</span><br><span class="line">s1.<span class="title function_">sayHi</span>() <span class="comment">// 报错 子类没法用到父类原型上的属性/方法</span></span><br></pre></td></tr></table></figure><h3 id="ES5-组合继承"><a href="#ES5-组合继承" class="headerlink" title="ES5-组合继承"></a>ES5-组合继承</h3><p>通过组合继承,结合原型链继承和构造函数继承2种方法的优点</p><p><strong>核心步骤：</strong></p><ol><li>通过原型链继承公共的属性和方法</li><li>通过构造函数继承实例独有的属性和方法</li></ol><p><strong>特点：</strong>调用了2次构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公共的属性和方法加父类原型上</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用父类构造函数传入this</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="comment">// 子类独有的属性和方法单独设置</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置子类的原型为 父类实例</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">// 调用子类的构造函数</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李雷&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用原型链上的 属性和方法 也可以使用 通过构造函数获取的父类的属性和方法</span></span><br></pre></td></tr></table></figure><h3 id="ES5-原型式继承"><a href="#ES5-原型式继承" class="headerlink" title="ES5-原型式继承"></a>ES5-原型式继承</h3><p>直接基于对象实现继承</p><p>**核心步骤:**对某个对象进行浅拷贝(工厂函数或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>),实现继承</p><p>**缺点:**父类中的引用数据类型，会被所有子类共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">friend</span>: [<span class="string">&#x27;rose&#x27;</span>, <span class="string">&#x27;ice&#x27;</span>, <span class="string">&#x27;robot&#x27;</span>],</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 Object.create替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数：返回一个新对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义构造函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 传入父类的对象，设置给构造函数的原型</span></span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="comment">// 返回了实例化对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son1 = <span class="title function_">objectFactory</span>(parent)</span><br><span class="line"><span class="keyword">const</span> son2 = <span class="title function_">objectFactory</span>(parent)</span><br><span class="line">son1.<span class="property">friend</span>.<span class="title function_">push</span>(<span class="string">&#x27;lucy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类中的引用数据类型，会被所有子类共享</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="property">friend</span>) <span class="comment">// [&#x27;rose&#x27;, &#x27;ice&#x27;, &#x27;robot&#x27;,&#x27;lucy&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son2.<span class="property">friend</span>) <span class="comment">// [&#x27;rose&#x27;, &#x27;ice&#x27;, &#x27;robot&#x27;,&#x27;lucy&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承，基于构造函数</span></span><br><span class="line"><span class="comment">// 原型继承，基于实例</span></span><br></pre></td></tr></table></figure><h3 id="ES5-寄生式继承"><a href="#ES5-寄生式继承" class="headerlink" title="ES5-寄生式继承"></a>ES5-寄生式继承</h3><p><strong>核心步骤:</strong></p><p>定义工厂函数,并在内部:</p><ol><li>对传入的对象进行浅拷贝(公共属性&#x2F;方法)</li><li>为浅拷贝对象增加属性&#x2F;方法(独有属性&#x2F;方法)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决引用类型共享问题</span></span><br><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">foods</span>: [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;炒蛋&#x27;</span>, <span class="string">&#x27;花菜&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="comment">// Object.create基于原型创建新对象，对属性进行浅拷贝</span></span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(origin)</span><br><span class="line">  <span class="comment">// 为对象增加属性/方法</span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son1 = <span class="title function_">createAnother</span>(parent)</span><br><span class="line"><span class="keyword">const</span> son2 = <span class="title function_">createAnother</span>(parent)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create() 静态方法以一个现有对象作为原型，创建一个新对象。</span></span><br><span class="line"><span class="comment">// 基于一个对象作为原型，创建一个新对象</span></span><br><span class="line"><span class="comment">// 对传入的对象进行浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> father = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kilito&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">foods</span>: [<span class="string">&#x27;西瓜&#x27;</span>, <span class="string">&#x27;西兰花&#x27;</span> ,<span class="string">&#x27;西葫芦&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newF = <span class="title class_">Object</span>.<span class="title function_">create</span>(father)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newF === father) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newF.<span class="property">foods</span> === father.<span class="property">foods</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>寄生式继承</p><ol><li><p>寄生式继承的核心步骤是?</p><ol><li><p>基于对象,创建新对象</p></li><li><p>增加新的<strong>属性和方法</strong></p></li></ol></li><li><p>寄生式继承和原型式原型式继承的区别是?</p><ol><li>创建出来的新对象,会额外的增加新的<strong>属性&#x2F;方法</strong></li></ol></li></ol><h3 id="ES5-寄生组合式继承"><a href="#ES5-寄生组合式继承" class="headerlink" title="ES5-寄生组合式继承"></a>ES5-寄生组合式继承</h3><p><strong>核心步骤:</strong></p><ol><li>通过构造函数来继承属性</li><li>通过原型链来继承方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承原型函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">son, parent</span>)&#123;</span><br><span class="line">    <span class="comment">//  基于父类的原型 创建新的对象</span></span><br><span class="line">    <span class="keyword">const</span> prototype = object.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 保证原型三角的关系</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = son</span><br><span class="line">    <span class="comment">// 设置给子类的类型</span></span><br><span class="line">    son.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foods</span> = [<span class="string">&#x27;西蓝花&#x27;</span>, <span class="string">&#x27;西葫芦&#x27;</span>, <span class="string">&#x27;西红柿&#x27;</span>]     <span class="comment">// 实例属性，写构造函数内</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;        <span class="comment">// 公共的方法写在原型上</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="string">`我喜欢吃,<span class="subst">$&#123;<span class="variable language_">this</span>.foods&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类借用父类的构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成原型继承</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Son</span>,<span class="title class_">Parent</span>)</span><br><span class="line"><span class="comment">// 可以继续在原型上添加属性/方法</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的年龄是&#x27;</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;rose&#x27;</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><h2 id="JS继承-ES6"><a href="#JS继承-ES6" class="headerlink" title="JS继承-ES6"></a>JS继承-ES6</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class">传送门:mdn类</a></p><p><a href="https://wangdoc.com/es6/class">传送门:阮一峰ES6-class</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">传送门:mdn-super</a></p></blockquote><p>ES6中推出了<code>class</code>类,是用来创建对象的模板.<code>class</code>可以看作是一个语法糖,它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h3 id="class核心语法"><a href="#class核心语法" class="headerlink" title="class核心语法"></a>class核心语法</h3><p><strong>核心语法:</strong></p><ol><li>如何定义及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes#%E7%B1%BB%E5%A3%B0%E6%98%8E">类</a>:</li><li>如何定义实例属性&#x2F;方法:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：class本质还是基于原型的</span></span><br><span class="line"><span class="comment">// 属性，在实例上</span></span><br><span class="line"><span class="comment">// 方法，在原型上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 实例属性，方便一眼确认有哪些（直接写，并且可以设置值）</span></span><br><span class="line">  <span class="comment">// 可以不写，构造函数中可以通过 this 动态添加</span></span><br><span class="line">  <span class="comment">// 建议写上</span></span><br><span class="line">  name</span><br><span class="line">  food</span><br><span class="line">  <span class="comment">// 构造方法，类似于构造函数，new的时候会调用，内部的this就是实例化的对象</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, food</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">food</span> = food</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢吃<span class="subst">$&#123;<span class="variable language_">this</span>.food&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小黑&#x27;</span>, <span class="string">&#x27;西蓝花&#x27;</span>)</span><br><span class="line">p.<span class="title function_">sayHi</span>()</span><br></pre></td></tr></table></figure><h3 id="class实现继承"><a href="#class实现继承" class="headerlink" title="class实现继承"></a>class实现继承</h3><p><strong>关键语法:</strong></p><ol><li><strong>子类</strong>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends">extends</a>继承<strong>父类</strong></li><li>子类构造函数中通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">super</a>调用父类构造函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上一份代码的基础上继续编写下面代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  song</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, food, song</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类构造函数使用this以前必须最开始调用super调用父类的构造函数！！！</span></span><br><span class="line">    <span class="variable language_">super</span>(name, food)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">song</span> = song</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  <span class="title function_">sing</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,我喜欢唱<span class="subst">$&#123;<span class="variable language_">this</span>.song&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李雷&#x27;</span>, <span class="string">&#x27;花菜&#x27;</span>, <span class="string">&#x27;孤勇者&#x27;</span>)</span><br><span class="line">s.<span class="title function_">sayHi</span>()</span><br><span class="line">s.<span class="title function_">sing</span>()</span><br></pre></td></tr></table></figure><h3 id="class私有-静态属性和方法"><a href="#class私有-静态属性和方法" class="headerlink" title="class私有,静态属性和方法"></a>class私有,静态属性和方法</h3><p><strong>补充语法:</strong></p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Private_class_fields">私有</a>属性&#x2F;方法的定义及使用(内部调用)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static">静态</a>属性&#x2F;方法的定义及使用(类直接访问)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过#作为前缀添加的属性会变为私有</span></span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  #secret = <span class="string">&#x27;我有一个小秘密，就不告诉你&#x27;</span></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  #<span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有属性可以在</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;私有的say方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">info</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在类的内部可以访问私有属性调用私有方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#secret)</span><br><span class="line">    <span class="variable language_">this</span>.#<span class="title function_">say</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 static定义静态属性/方法</span></span><br><span class="line">  <span class="comment">// 访问的时候 通过 类 直接访问</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个静态方法&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> info = <span class="string">&#x27;直立行走，双手双脚&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line"><span class="comment">// 外部无法访问 点语法访问直接报错，通过[]无法动态获取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p[<span class="string">&#x27;#secret&#x27;</span>])</span><br><span class="line">p.<span class="title function_">info</span>()</span><br><span class="line"><span class="comment">// 通过类访问静态属性/方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">staticMethod</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">info</span>)</span><br></pre></td></tr></table></figure><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><blockquote><p>这一节咱们来学习内置函数<code>fetch</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">传送门-fetch</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response">传送门-Response</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">传送门-Headers</a></p></blockquote><p>全局的<code>fetch</code>函数用来发起获取资源请求.他返回一个<code>promise</code>,这个<code>promise</code>会在请求响应后被<code>resolve</code>,并传回Response对象</p><ol><li><p><code>fetch</code>核心语法</p></li><li><p><code>fetch</code>结合<code>URLSearchParams</code>发送get请求:</p><ol><li><pre><code class="javascript">const obj = &#123;    name:&#39;jack&#39;,    age:18&#125;name=jack&amp;age=17<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. `fetch`发送post请求,提交`JSON`数据</span><br><span class="line"></span><br><span class="line">4. `fetch`发送post请求,提交`FormData`数据</span><br><span class="line"></span><br><span class="line">### fetch核心语法</span><br><span class="line"></span><br><span class="line">**核心语法:**</span><br><span class="line"></span><br><span class="line">1. 如何[发请求](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch):</span><br><span class="line">2. 如何处理[响应](https://developer.mozilla.org/zh-CN/docs/Web/API/Response):</span><br><span class="line">3. 注:[测试用接口](https://apifox.com/apidoc/project-1937884/api-49760223)</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">document.querySelector(&#x27;.request&#x27;).addEventListener(&#x27;click&#x27;,() =&gt; &#123;</span><br><span class="line">    // 1. fetch(url地址) ===&gt; Promise对象</span><br><span class="line">    fetch(&#x27;http://hmajax.itheima.net/api/news&#x27;).then(response =&gt; &#123;</span><br><span class="line">        // console.log(response)</span><br><span class="line">        // 2. 请求成功之后， resolve  --&gt; then 获取 response</span><br><span class="line">        // 3. 调用 json 方法，获取解析之后的结果，返回Promise</span><br><span class="line">        response.json().then(res =&gt; &#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// async await 改写</span><br><span class="line">document.querySelector(&#x27;.request&#x27;).addEventListener(&#x27;click&#x27;, async() =&gt; &#123;</span><br><span class="line">   const response =  await fetch(&#x27;http://hmajax.itheima.net/api/news&#x27;)</span><br><span class="line">   const res = response.json()</span><br><span class="line">   console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h3 id="fetch结合URLSearchParams发送get请求"><a href="#fetch结合URLSearchParams发送get请求" class="headerlink" title="fetch结合URLSearchParams发送get请求:"></a>fetch结合URLSearchParams发送get请求:</h3><p><strong>需求:</strong></p><ol><li>使用<code>fetch</code>结合<code>URLSearchParams</code>调用地区查询<a href="https://apifox.com/apidoc/project-1937884/api-49760217">接口</a></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;</span><br><span class="line">    <span class="attr">pname</span>: <span class="string">&#x27;安徽省&#x27;</span>,</span><br><span class="line">    <span class="attr">cname</span>: <span class="string">&#x27;合肥市&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// console.log(params) URLSearchParams &#123; size: 2 &#125; 2组键值对</span></span><br><span class="line">  <span class="comment">// 传入的对象，转为查询字符串</span></span><br><span class="line">  <span class="comment">// key=value&amp;key=value</span></span><br><span class="line">  <span class="comment">// 中文会编码</span></span><br><span class="line">  <span class="comment">// params.toString() </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`http://hmajax.itheima.net/api/area?<span class="subst">$&#123;params.toString()&#125;</span>`</span></span><br><span class="line">  <span class="comment">// fetch函数返回的是 Promise对象，通过await等待获取response对象</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">  <span class="comment">// .json方法返回的是Promise对象 继续通过await等待</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="post请求-提交JSON"><a href="#post请求-提交JSON" class="headerlink" title="post请求-提交JSON"></a>post请求-提交JSON</h3><p><strong>需求:</strong></p><ol><li><code>fetch</code>发送post请求,提交<code>JSON</code>数据</li><li><a href="https://apifox.com/apidoc/project-1937884/api-49760218">测试接口-用户注册</a></li></ol><p><strong>核心步骤:</strong></p><ol><li>根据文档设置请求头</li><li>通过配置项设置,请求方法,请求头,请求体</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; (<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过headers设置请求头</span></span><br><span class="line">  <span class="keyword">const</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>()</span><br><span class="line">  <span class="comment">// 通过 content-type指定请求体数据格式</span></span><br><span class="line">  headers.<span class="title function_">append</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 参数1 url</span></span><br><span class="line">  <span class="comment">// 参数2 请求配置</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/register&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">// 请求方法</span></span><br><span class="line">    headers, <span class="comment">// 请求头</span></span><br><span class="line">    <span class="comment">// 请求体</span></span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">username</span>: <span class="string">&#x27;itheima9876&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>post请求-提交JSON</p><ol><li><code>fetch</code>函数的第二个参数可以设置请求头,请求方法,请求体</li></ol><h3 id="post请求-提交FormData"><a href="#post请求-提交FormData" class="headerlink" title="post请求-提交FormData"></a>post请求-提交FormData</h3><p><strong>需求:</strong></p><ol><li><code>fetch</code>发送post请求,提交<code>FormData</code>数据(上传+回显)</li><li><a href="https://apifox.com/apidoc/project-1937884/api-49760221">测试接口-上传图片</a></li></ol><p><strong>核心步骤:</strong></p><ol><li>通过<code>FormData</code>添加文件</li><li>通过配置项设置,请求方法,请求体(<code>FormData</code>不需要设置请求头)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;file&quot;</span> accept=<span class="string">&quot;image/*&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.file&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 生成FormData对象并添加数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    data.<span class="title function_">append</span>(<span class="string">&#x27;img&#x27;</span>, <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/uploadimg&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">body</span>: data</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> json = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">传送门-Generator</a></p></blockquote><p><code>Generator</code>对象由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*">生成器函数</a>返回并且它符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">可迭代协议</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">迭代器协议</a>.他可以用来<strong>控制流程</strong>,语法行为和之前学习的函数不一样</p><h3 id="Generator-核心语法"><a href="#Generator-核心语法" class="headerlink" title="Generator-核心语法"></a>Generator-核心语法</h3><p><strong>核心语法:</strong></p><ol><li>如何定义生成器函数:</li><li>如何获取<code>generator</code>对象</li><li><code>yield</code>表达式的使用</li><li>通过<code>for of</code>获取每一个<code>yield</code>的值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过function* 创建生成器函数 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 生成器函数内部的逻辑，不会自动调用，调用 Generator 对象的 next() 方法  </span></span><br><span class="line">  <span class="comment">// 遇到yield表达式时会暂停后续的操作 （*对应async  yield对应await）</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用函数获取生成器</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">foo</span>()</span><br><span class="line"><span class="comment">// 3. 通过next方法获取yield 之后的表达式结果，会被包装到一个对象中</span></span><br><span class="line"><span class="comment">// 执行一次next 即可获取一次 yield之后的表达式结果</span></span><br><span class="line"><span class="keyword">const</span> res1 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1)<span class="comment">// &#123;value: &#x27;a&#x27;, done: false&#125;</span></span><br><span class="line"><span class="keyword">const</span> res2 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2)<span class="comment">// &#123;value: &#x27;b&#x27;, done: false&#125;</span></span><br><span class="line"><span class="keyword">const</span> res3 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res3)<span class="comment">// &#123;value: &#x27;c&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// 最后一次可以拿到return的结果</span></span><br><span class="line"><span class="keyword">const</span> res4 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res4)<span class="comment">// &#123;value: &#x27;d&#x27;, done: true&#125; </span></span><br><span class="line"><span class="comment">// done 为true之后，获取到的value为undefined</span></span><br><span class="line"><span class="keyword">const</span> res5 = f.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res5)<span class="comment">// &#123;value: undefined, done: true&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器，函数创建之后，代码不执行</span></span><br><span class="line"><span class="comment">// 每调用一次next执行到yield，获取结果</span></span><br><span class="line"><span class="comment">// 如果执行next之后无法获取结果， done: false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 通过for of 获取每一个yield之后的值，</span></span><br><span class="line"><span class="comment">// 迭代器协议 可以自定义 for of 的时候的行为</span></span><br><span class="line"><span class="comment">// iterator迭代（循环的每一项）</span></span><br><span class="line"><span class="comment">// f2 循环的内容</span></span><br><span class="line"><span class="keyword">const</span> f2 = <span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> f2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator)  <span class="comment">// a b c d 获取每一个 yeild 之后的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for of</span></span><br><span class="line"><span class="comment">// 可以用来遍历一些符合 迭代器协议的数据 比如数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Generator-id生成器"><a href="#Generator-id生成器" class="headerlink" title="Generator-id生成器"></a>Generator-id生成器</h3><p>**需求:**使用<code>Generator</code>实现一个id生成器id</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">idGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> idMaker = <span class="title function_">idGenerator</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用next方法,获取id(每次累加1)</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id1 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id1)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id2 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id2)</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li>定义生成器函数</li><li>内部使用循环,通过<code>yield</code>返回<code>id</code>并累加</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过function* 创建生成器函数 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 无限循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// id累加并返回</span></span><br><span class="line">    <span class="keyword">yield</span> id++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用函数获取生成器</span></span><br><span class="line"><span class="keyword">const</span> idMaker = <span class="title function_">generator</span>()</span><br><span class="line"><span class="comment">// 3. 需要id的时候 通过next获取即可</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id1 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id1)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: id2 &#125; = idMaker.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id2)</span><br></pre></td></tr></table></figure><h3 id="Generator-流程控制"><a href="#Generator-流程控制" class="headerlink" title="Generator-流程控制"></a>Generator-流程控制</h3><p>遇到<code>yield</code>表达式时会<strong>暂停</strong>后续的操作</p><p>**需求:**使用<code>Generator</code>实现流程控制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">weatherGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 逻辑略</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">axios</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取Generator实例</span></span><br><span class="line"><span class="keyword">const</span> weather = <span class="title function_">weatherGenerator</span>()</span><br><span class="line"><span class="comment">// 依次获取 北上广深的天气 (axios)</span></span><br><span class="line">weather.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><p><strong>核心步骤:</strong></p><ol><li><code>yield</code>后面跟上天气查询逻辑</li><li><a href="https://apifox.com/apidoc/project-1937884/api-49760220">接口文档-天气预报</a></li><li>参考<code>code</code>:北京 110100  上海 310100  广州 440100 深圳 440300</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;getWeather&quot;</span>&gt;</span>天气查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.6/axios.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * 需求：流程控制，依次查询，北上广深的天气预报</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * 参考code: 北京 110100  上海 310100  广州 440100 深圳 440300</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * 接口文档: https://apifox.com/apidoc/project-1937884/api-49760220</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   * */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span>* <span class="title function_">weatherGenerator</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// yield 会暂停代码的执行</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 北京</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=110100&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 上海</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=310100&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 广州</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=440100&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 深圳</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">yield</span> <span class="title function_">axios</span>(<span class="string">&#x27;http://hmajax.itheima.net/api/weather?city=440300&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> cityWeather = <span class="title function_">weatherGenerator</span>()</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//const response = weather.next()</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 继续 .then</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//response.value.then(res =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//   console.log(res)</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//&#125;)</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.getWeather&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> res = <span class="keyword">await</span> genCity.<span class="title function_">next</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> 手写 </tag>
            
            <tag> 继承 </tag>
            
            <tag> fetch </tag>
            
            <tag> Generato </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在nodejs环境中应用并代理跨域</title>
      <link href="/posts/882eae4.html"/>
      <url>/posts/882eae4.html</url>
      
        <content type="html"><![CDATA[<h2 id="在nodejs环境中应用并代理跨域"><a href="#在nodejs环境中应用并代理跨域" class="headerlink" title="在nodejs环境中应用并代理跨域"></a>在nodejs环境中应用并代理跨域</h2><p>**<code>目标</code>**将打包好的代码打包上线，并在nodejs中代理跨域</p><h3 id="使用koa框架部署项目"><a href="#使用koa框架部署项目" class="headerlink" title="使用koa框架部署项目"></a>使用koa框架部署项目</h3><blockquote><p>到现在为止，我们已经完成了一个前端工程师的开发流程，按照常规的做法，此时，运维会将我们的代码部署到阿里云的ngix服务上，对于我们而言，我们可以将其部署到本机的nodejs环境中</p></blockquote><p>部署 自动化部署 &#x2F;手动部署</p><p>第一步，建立web服务文件夹  <strong><code>hrServer</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> hrServer <span class="comment">#建立hrServer文件夹 </span></span><br></pre></td></tr></table></figure><p>第二步，在该文件夹下，初始化npm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><p>第三步，安装服务端框架koa(也可以采用express或者egg)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i koa koa-static</span><br></pre></td></tr></table></figure><p>第四步，拷贝上小节打包的dist目录到**<code>hrServer/public</code>**下</p><p>第五步，在根目录下创建app.js，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span>  = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)  <span class="comment">// 引入Koa包</span></span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();  <span class="comment">// 实例化一个web服务</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(__dirname + <span class="string">&quot;/public&quot;</span>)); <span class="comment">//将public下的代码静态化</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3333</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人资项目启动&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>node app</p><p>此时，我们可以访问，<a href="http://localhost:3333/">http://localhost:3333</a></p></blockquote><p>页面出来了</p><h3 id="解决history页面404问题"><a href="#解决history页面404问题" class="headerlink" title="解决history页面404问题"></a>解决history页面404问题</h3><p>但是，此时存在两个问题，</p><ol><li><strong>当我们刷新页面，发现404</strong></li></ol><blockquote><p>  这是因为我们采用了history的模式，地址的变化会引起服务器的刷新，我们只需要在app.js对所有的地址进行一下处理即可</p></blockquote><p>安装 koa中间件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i koa2-connect-history-api-fallback <span class="comment">#专门处理history模式的中间件</span></span><br></pre></td></tr></table></figure><p><strong>注册中间件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span>  = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span>  &#123; historyApiFallback &#125; = <span class="built_in">require</span>(<span class="string">&#x27;koa2-connect-history-api-fallback&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="comment">// 这句话 的意思是除接口之外所有的请求都发送给了 index.html</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">historyApiFallback</span>(&#123;      <span class="comment">//应该先使用 处理访问的中间件 再使用静态化服务</span></span><br><span class="line">     <span class="attr">whiteList</span>: [<span class="string">&#x27;/prod-api&#x27;</span>]  <span class="comment">//prod-api代理跨域的问题  表示不要帮我处理 /prod-api 由自己处理</span></span><br><span class="line"> &#125;));  <span class="comment">// 这里的whiteList是 白名单的意思</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(__dirname + <span class="string">&quot;/public&quot;</span>)); <span class="comment">//将public下的代码静态化</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3333</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人资项目启动http://localhost:3333&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解决生产环境跨域问题"><a href="#解决生产环境跨域问题" class="headerlink" title="解决生产环境跨域问题"></a>解决生产环境跨域问题</h3><ol><li>当点击登录时，发现接口404</li></ol><blockquote><p>  前面我们讲过，vue-cli的代理只存在于开发期，当我们上线到node环境或者ngix环境时，需要我们再次在环境中代理</p></blockquote><p>在nodejs中代理</p><p>安装跨域代理中间件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i koa2-proxy-middleware</span><br></pre></td></tr></table></figure><p>配置跨越代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; historyApiFallback &#125; = <span class="built_in">require</span>(<span class="string">&#x27;koa2-connect-history-api-fallback&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;koa2-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册跨域代理的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">proxy</span>(&#123;</span><br><span class="line">    <span class="attr">targets</span>: &#123;</span><br><span class="line">        <span class="comment">// 代理哪个地址  代理以 &#x27;/prod-api&#x27;为开头的地址</span></span><br><span class="line">        <span class="string">&#x27;/prod-api/(.*)&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;https://heimahr.itheima.net/api&#x27;</span>, <span class="comment">// 将以prod/api开头的内容代理到该地址  后端服务器地址</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;/prod-api&#x27;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这句话 的意思是除接口之外所有的请求都发送给了 index.html</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">historyApiFallback</span>(&#123; <span class="comment">//应该先使用 处理访问的中间件 再使用静态化服务</span></span><br><span class="line">    <span class="attr">whiteList</span>: [<span class="string">&#x27;/prod-api&#x27;</span>] <span class="comment">// prod-api代理跨域的问题  表示不要帮我处理 /prod-api 由自己处理</span></span><br><span class="line">&#125;)); <span class="comment">// 这里的whiteList是 白名单的意思</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(__dirname + <span class="string">&quot;/public&quot;</span>)); <span class="comment">//将public下的代码静态化</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3333</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人资项目启动http://localhost:3333&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：这里之所以用了<strong>pathRewrite</strong>，是因为生产环境的请求基础地址是 <strong>&#x2F;prod-api</strong>，需要将该地址去掉</p><p>此时，我们的项目就可以跨域访问了！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阳光不错，微风正好</title>
      <link href="/posts/b313554c.html"/>
      <url>/posts/b313554c.html</url>
      
        <content type="html"><![CDATA[<h1 id="夏至"><a href="#夏至" class="headerlink" title="夏至"></a>夏至</h1><p>  一生的时间很短<br>  短到不过是两颗心之间的距离<br>  一生的时间也很长<br>  不如我们试着走走看</p>  <button type="button" onclick="SAONotify('Update','link start...','location.reload(true);')">SAO刷新按钮</button>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
